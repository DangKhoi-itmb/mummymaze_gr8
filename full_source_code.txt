

==============================
PATH: MummyMaze\pyproject.toml
==============================

[project]
name = "core"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.14"
dependencies = [
    "pygame-ce>=2.5.6",
]


==============================
PATH: MummyMaze\README.md
==============================

Coming soon...

==============================
PATH: MummyMaze\__init__.py
==============================



==============================
PATH: MummyMaze\api\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\entities\Enemy.py
==============================

import pygame
import os
import random
from collections import deque
from enum import Enum
from api.io.Lightning.entities.EntityLoader import Entity
from api.io.Lightning.manager.SoundReader import sfx_manager
from api.io.Lightning.utils.ConfigFile import ENTITIES_PATH, maze_coord_x, maze_coord_y, UI_PATH, OBJECTS_PATH


# ... (Keep EnemyAI class and EnemyState Enum exactly as they are) ...

class EnemyAI:
    def __init__(self, maze_size, walls, gate=None):
        self.maze_size = maze_size
        self.walls = walls
        self.gate = gate

    def _is_valid_move(self, from_pos, to_pos):
        return Entity.validate_move(from_pos[0], from_pos[1], to_pos[0], to_pos[1], self.maze_size, self.walls,
                                    self.gate)

    def _find_shortest_path(self, start, end):
        start = tuple(start);
        end = tuple(end)
        if start == end: return []
        queue = deque([(start, [])]);
        visited = set([start])
        while queue:
            current, path = queue.popleft()
            cx, cy = current
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = cx + dx, cy + dy
                neighbor = (nx, ny)
                if neighbor in visited: continue
                if self._is_valid_move([cx, cy], [nx, ny]):
                    new_path = path + [[nx, ny]]
                    if neighbor == end: return new_path
                    visited.add(neighbor)
                    queue.append((neighbor, new_path))
        return []

    def _get_classic_path(self, start_pos, target_pos, steps, priority="horizontal"):
        path = []
        cur_x, cur_y = start_pos
        target_x, target_y = target_pos

        for _ in range(steps):
            dist_x = target_x - cur_x
            dist_y = target_y - cur_y
            moved_this_attempt = False

            check_order = [('x', dist_x), ('y', dist_y)] if priority == "horizontal" else [('y', dist_y), ('x', dist_x)]

            for axis, dist in check_order:
                if axis == 'x' and dist != 0:
                    step_x = 1 if dist > 0 else -1
                    nx = cur_x + step_x
                    if self._is_valid_move([cur_x, cur_y], [nx, cur_y]):
                        cur_x = nx
                        path.append([cur_x, cur_y])
                        moved_this_attempt = True
                        break

                elif axis == 'y' and dist != 0:
                    step_y = 1 if dist > 0 else -1
                    ny = cur_y + step_y
                    if self._is_valid_move([cur_x, cur_y], [cur_x, ny]):
                        cur_y = ny
                        path.append([cur_x, cur_y])
                        moved_this_attempt = True
                        break

            if not moved_this_attempt:
                break

        return path

    def _random_valid_move(self, enemy_pos):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        random.shuffle(directions)
        for dx, dy in directions:
            new_pos = [enemy_pos[0] + dx, enemy_pos[1] + dy]
            if self._is_valid_move(enemy_pos, new_pos): return [new_pos]
        return []

    def get_move_path(self, enemy, player_pos, difficulty='medium'):
        etype = enemy['type']
        curr = enemy['pos']

        # Hard mode logic swap from previous requests
        if difficulty == 'hard' and 'scorpion' in etype:
            steps = 1
            full_path = self._find_shortest_path(curr, player_pos)
            return full_path[:steps]

        steps = 2 if 'mummy' in etype else 1

        if difficulty == 'easy' and random.random() < 0.3:
            return self._random_valid_move(curr)

        if etype == 'white_mummy':
            return self._get_classic_path(curr, player_pos, steps, priority="horizontal")
        elif etype == 'red_mummy':
            return self._get_classic_path(curr, player_pos, steps, priority="vertical")
        elif etype == 'scorpion':
            return self._get_classic_path(curr, player_pos, 1, "horizontal")
        elif etype == 'red_scorpion':
            dist = abs(curr[0] - player_pos[0]) + abs(curr[1] - player_pos[1])
            if dist <= 3 or difficulty == 'hard':
                return self._get_classic_path(curr, player_pos, 1, "horizontal")
            else:
                return self._random_valid_move(curr)
        return []


class EnemyState(Enum):
    IDLE = "idle";
    WALK = "walk";
    DIE = "die"
    AFK_LISTEN = "listen";
    AFK_DANCE = "dance";
    AFK_SPIN = "spin"


class Enemy(Entity):
    def __init__(self, x, y, enemy_type, maze_size, tile_size, walls, gate=None):
        super().__init__(x, y)
        self.type = enemy_type
        self.maze_size = maze_size
        self.tile_size = tile_size
        self.ai = EnemyAI(maze_size, walls, gate)

        self.state = EnemyState.IDLE
        self.direction = 'down'
        self.is_dead = False
        self.strength = 0
        self._set_stats()

        self.pixel_x = x * tile_size
        self.pixel_y = y * tile_size
        self.target_x = self.pixel_x
        self.target_y = self.pixel_y

        self.move_queue = deque()
        self.move_speed = 3
        self.is_moving = False
        self.paused = False  # --- NEW: Controls turn flow ---

        self.is_retreating = False
        self.locked_direction = None
        self.is_turning = False
        self.turn_timer = 0
        self.current_walk_variant = None

        # --- NEW: AFK Cooldown Timer ---
        self.last_afk_time = 0
        # -------------------------------

        self.frame_index = 0
        self.animation_speed = 0.05
        self.last_update_time = pygame.time.get_ticks()
        self.animations = {}
        self._load_assets()

    def _set_stats(self):
        if self.type == 'scorpion':
            self.strength = 1
        elif self.type == 'red_scorpion':
            self.strength = 2
        elif self.type == 'white_mummy':
            self.strength = 3
        elif self.type == 'red_mummy':
            self.strength = 4

    def _load_assets(self):
        # ... (Keep existing asset loading logic) ...
        # [Snippet omitted for brevity, ensure previous asset loading code is here]
        def load_img(name):
            search_paths = [ENTITIES_PATH, UI_PATH, OBJECTS_PATH]
            for folder in search_paths:
                for sz in [self.maze_size, 6, ""]:
                    for ext in [".png", ".gif"]:
                        filename = f"{name}{sz}{ext}"
                        path = os.path.join(folder, filename)
                        if os.path.exists(path): return pygame.image.load(path).convert_alpha()
            return None

        def load_grid(sheet):
            if not sheet: return {'up': [], 'right': [], 'down': [], 'left': []}
            w, h = sheet.get_size();
            fw, fh = w // 5, h // 4
            anims = {'up': [], 'right': [], 'down': [], 'left': []}
            for row, d in enumerate(['up', 'right', 'down', 'left']):
                for col in range(5): anims[d].append(sheet.subsurface((col * fw, row * fh, fw, fh)))
            return anims

        def load_strip(sheet):
            if not sheet: return []
            h = sheet.get_height();
            count = sheet.get_width() // h
            return [sheet.subsurface((i * h, 0, h, h)) for i in range(count)]

        name_map = {'scorpion': 'scorpion', 'red_scorpion': 'redscorpion', 'white_mummy': 'mummy',
                    'red_mummy': 'redmummy'}
        base_name = name_map.get(self.type, 'mummy')
        sheet = load_img(base_name)
        if not sheet and self.type == 'red_mummy':
            sheet = load_img('mummy')
            if sheet:
                tint = pygame.Surface(sheet.get_size(), pygame.SRCALPHA)
                tint.fill((255, 100, 100))
                sheet.blit(tint, (0, 0), special_flags=pygame.BLEND_MULT)
        if sheet:
            walks = load_grid(sheet)
            self.animations['walk_up'] = walks['up'];
            self.animations['walk_right'] = walks['right']
            self.animations['walk_down'] = walks['down'];
            self.animations['walk_left'] = walks['left']
        if 'mummy' in self.type:
            pre = "white" if self.type == 'white_mummy' else "red"
            self.animations[EnemyState.AFK_LISTEN] = load_strip(load_img(f"{pre}listen")) or load_strip(
                load_img("whitelisten"))
            self.animations[EnemyState.AFK_DANCE] = load_strip(load_img(f"{pre}dance")) or load_strip(
                load_img("whitedance"))
            self.animations[EnemyState.AFK_SPIN] = load_strip(load_img(f"{pre}spin")) or load_strip(
                load_img("whitespin"))
        self.animations[EnemyState.DIE] = load_strip(load_img("dust"))

    def move_logic(self, player_pos, difficulty='medium'):
        if self.state == EnemyState.DIE: return
        path = self.ai.get_move_path({'type': self.type, 'pos': [self.x, self.y]}, player_pos, difficulty)
        for step in path:
            if step != [self.x, self.y]: self.move_queue.append(step)

    def face_target(self, target_x, target_y):
        if self.is_dead: return
        dx = target_x - self.x
        dy = target_y - self.y
        new_dir = self.direction
        if abs(dx) > abs(dy):
            new_dir = 'right' if dx > 0 else 'left'
        elif abs(dy) > abs(dx):
            new_dir = 'down' if dy > 0 else 'up'
        if new_dir != self.direction:
            self.direction = new_dir
            if not self.is_moving:
                self.is_turning = True
                self.turn_timer = pygame.time.get_ticks()
                self.state = EnemyState.WALK

    def retreat_to(self, target_x, target_y):
        self.is_retreating = True
        self.locked_direction = self.direction
        self.move_queue.clear()
        self.move_queue.append([target_x, target_y])

    def trigger_afk(self):
        if pygame.time.get_ticks() - self.last_afk_time < 7000:
            return
        if 'mummy' in self.type and not self.is_moving and not self.move_queue and self.state != EnemyState.DIE and "AFK" not in self.state.name:
            self.state = random.choice([EnemyState.AFK_LISTEN, EnemyState.AFK_DANCE, EnemyState.AFK_SPIN])
            self.frame_index = 0

    # --- UPDATED: Support instant death to avoid double-dust ---
    def trigger_die(self, instant=False):
        if instant:
            self.is_dead = True
        else:
            self.state = EnemyState.DIE
            self.frame_index = 0
            self.is_moving = False
            self.move_queue.clear()

    def update(self):
        if self.is_turning:
            if pygame.time.get_ticks() - self.turn_timer > 50:
                self.is_turning = False
                if not self.is_moving and self.state == EnemyState.WALK:
                    self.state = EnemyState.IDLE
                    self.frame_index = 0

        # --- UPDATED: Respect PAUSED state ---
        # If paused, we DO NOT pop the next move from the queue.
        # We only allow the current move (interpolation) to finish.
        can_start_new_move = (not self.is_moving and self.move_queue and not self.paused)

        if can_start_new_move:
            next_pos = self.move_queue.popleft()
            dx, dy = next_pos[0] - self.x, next_pos[1] - self.y

            self.current_walk_variant = sfx_manager.play_walk_start(self.type)

            if not self.is_retreating:
                if dx > 0:
                    self.direction = 'right'
                elif dx < 0:
                    self.direction = 'left'
                elif dy > 0:
                    self.direction = 'down'
                elif dy < 0:
                    self.direction = 'up'
            elif self.locked_direction:
                self.direction = self.locked_direction

            self.x, self.y = next_pos
            self.target_x = self.x * self.tile_size
            self.target_y = self.y * self.tile_size
            self.is_moving = True
            self.state = EnemyState.WALK
            self.is_turning = False

        # 2. Move (Visual Interpolation) - Always runs to finish current step
        if self.is_moving:
            if self.pixel_x < self.target_x:
                self.pixel_x = min(self.pixel_x + self.move_speed, self.target_x)
            elif self.pixel_x > self.target_x:
                self.pixel_x = max(self.pixel_x - self.move_speed, self.target_x)
            if self.pixel_y < self.target_y:
                self.pixel_y = min(self.pixel_y + self.move_speed, self.target_y)
            elif self.pixel_y > self.target_y:
                self.pixel_y = max(self.pixel_y - self.move_speed, self.target_y)

            if self.pixel_x == self.target_x and self.pixel_y == self.target_y:
                self.is_moving = False
                if self.current_walk_variant:
                    sfx_manager.play_walk_end(self.type, self.current_walk_variant)
                    self.current_walk_variant = None

                if not self.move_queue and not self.is_turning:
                    if self.state == EnemyState.WALK: self.state = EnemyState.IDLE
                if self.is_retreating:
                    self.is_retreating = False
                    self.locked_direction = None

        # 3. Animate
        current_time = pygame.time.get_ticks()
        if current_time - self.last_update_time > (self.animation_speed * 1000):
            self.last_update_time = current_time
            anim_list = []
            if self.state == EnemyState.WALK:
                anim_list = self.animations.get(f'walk_{self.direction}', [])
                if anim_list: self.frame_index = (self.frame_index + 1) % len(anim_list)
            elif self.state == EnemyState.IDLE:
                anim_list = self.animations.get(f'walk_{self.direction}', [])
                if anim_list: self.frame_index = 0
            elif "AFK" in self.state.name:
                anim_list = self.animations.get(self.state, [])
                if anim_list:
                    if self.frame_index < len(anim_list) - 1:
                        self.frame_index += 1
                    else:
                        self.state = EnemyState.IDLE
                        self.direction = 'down'
                        self.frame_index = 0
            elif self.state == EnemyState.DIE:
                anim_list = self.animations.get(self.state, [])
                if anim_list:
                    if self.frame_index < len(anim_list) - 1:
                        self.frame_index += 1
                    else:
                        self.is_dead = True

    def draw(self, surface):
        if self.is_dead: return
        anim_list = []
        if self.state == EnemyState.WALK or self.state == EnemyState.IDLE:
            anim_list = self.animations.get(f'walk_{self.direction}', [])
        else:
            anim_list = self.animations.get(self.state, [])
        if anim_list:
            safe_idx = self.frame_index if self.frame_index < len(anim_list) else 0
            img = anim_list[safe_idx]
            draw_x = maze_coord_x + self.pixel_x
            draw_y = maze_coord_y + self.pixel_y
            offset_x = (self.tile_size - img.get_width()) // 2
            offset_y = (self.tile_size - img.get_height()) // 2
            surface.blit(img, (draw_x + offset_x, draw_y + offset_y))

==============================
PATH: MummyMaze\api\io\Lightning\entities\EntityLoader.py
==============================

import pygame


class Entity:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.direction = 'down'
        self.pixel_x = 0
        self.pixel_y = 0

    def check_position(self, entity):
        return (entity.x == self.x) and (entity.y == self.y)

    def set_position(self, x, y):
        self.x = x
        self.y = y

    def get_pos(self):
        return self.x, self.y

    def set_direction(self, new_x, new_y):
        if new_x > self.x:
            self.direction = 'right'
        elif new_x < self.x:
            self.direction = 'left'
        elif new_y > self.y:
            self.direction = 'down'
        elif new_y < self.y:
            self.direction = 'up'

    def set_x(self, x):
        self.x = x

    def set_y(self, y):
        self.y = y

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    @staticmethod
    def validate_move(start_x, start_y, end_x, end_y, maze_size, walls, gate=None):
        """
        Static method to check if a move from (start_x, start_y) to (end_x, end_y) is valid.
        """
        # 1. Check Map Boundaries
        if not (0 <= end_x < maze_size and 0 <= end_y < maze_size):
            return False

        # 2. Check Gate Collision
        if gate and gate.is_blocking():
            gx, gy = gate.grid_x, gate.grid_y

            # The gate is visually at the TOP of cell (gx, gy).
            # It acts as a wall between (gx, gy) and (gx, gy-1).

            # Case A: Moving DOWN into the gate cell from above
            # From (gx, gy-1) -> To (gx, gy)
            if start_x == gx and start_y == gy - 1 and end_x == gx and end_y == gy:
                return False

            # Case B: Moving UP out of the gate cell
            # From (gx, gy) -> To (gx, gy-1)
            if start_x == gx and start_y == gy and end_x == gx and end_y == gy - 1:
                return False

        # 3. Check Wall Collision
        # Moving RIGHT
        if end_x > start_x:
            for w in walls:
                if w['x'] == end_x and w['y'] == end_y and w['dir'] in ['vertical', 'both']: return False
        # Moving LEFT
        elif end_x < start_x:
            for w in walls:
                if w['x'] == start_x and w['y'] == start_y and w['dir'] in ['vertical', 'both']: return False
        # Moving DOWN
        elif end_y > start_y:
            for w in walls:
                if w['x'] == end_x and w['y'] == end_y and w['dir'] in ['horizontal', 'both']: return False
        # Moving UP
        elif end_y < start_y:
            for w in walls:
                if w['x'] == start_x and w['y'] == start_y and w['dir'] in ['horizontal', 'both']: return False

        return True

    def check_eligible_move(self, new_x, new_y, maze_size, walls, gate=None):
        """Wrapper for instance-based check"""
        return Entity.validate_move(self.x, self.y, new_x, new_y, maze_size, walls, gate)

==============================
PATH: MummyMaze\api\io\Lightning\entities\Player.py
==============================

import pygame
import os
import random
from enum import Enum
from api.io.Lightning.entities.EntityLoader import Entity
from api.io.Lightning.manager.SoundReader import sfx_manager
from api.io.Lightning.utils.ConfigFile import ENTITIES_PATH, maze_coord_x, maze_coord_y


class PlayerState(Enum):
    IDLE = "idle"
    WALK = "walk"
    # AFK
    AFK_READMAP = "readmap"
    AFK_LIGHT = "light"
    AFK_SEARCH = "search"
    AFK_SHRUG = "shrug"
    # Deaths
    DIE_WHITE_MUMMY = 'whitefight'
    DIE_RED_MUMMY = 'redfight'
    DIE_STUNG = "stung"
    DIE_TRAP = "freakout"


class Player(Entity):
    def __init__(self, x, y, maze_size, tile_size):
        super().__init__(x, y)
        self.maze_size = maze_size
        self.tile_size = tile_size

        # --- Position Management ---
        self.target_x = x
        self.target_y = y
        self.pixel_x = x * tile_size
        self.pixel_y = y * tile_size
        self.move_speed = 2
        self.is_moving = False

        # --- Cooldown System ---
        self.next_move_time = 0
        self.move_cooldown = 50  # 1000ms = 1 second cooldown

        # --- State Management ---
        self.state = PlayerState.IDLE
        self.direction = 'down'

        self.frame_index = 0
        self.animation_speed = 0.20
        self.animation_counter = 0

        # --- AFK System ---
        self.last_input_time = pygame.time.get_ticks()
        self.afk_delay = 7000

        # --- Assets ---
        self.current_walk_variant = None
        self.animations = {}
        self._load_assets()

        print(f"üéÆ Player initialized at Grid({x}, {y})")

    def _load_assets(self):
        """Loads assets using 'Key.py' logic"""

        def load_img(name):
            for ext in [".png", ".gif"]:
                path = os.path.join(ENTITIES_PATH, f"{name}{self.maze_size}{ext}")
                if os.path.exists(path):
                    try:
                        return pygame.image.load(path).convert_alpha()
                    except:
                        pass
            return None

        def load_strip_square(sheet):
            if not sheet: return []
            sheet_w, sheet_h = sheet.get_size()
            frame_h = sheet_h
            frame_w = sheet_h
            count = sheet_w // frame_w
            frames = []
            for i in range(count):
                frame = pygame.Surface((frame_w, frame_h), pygame.SRCALPHA)
                frame.blit(sheet, (0, 0), (i * frame_w, 0, frame_w, frame_h))
                frames.append(frame)
            return frames

        def load_grid_explorer(sheet):
            if not sheet: return {'up': [], 'right': [], 'down': [], 'left': []}
            sheet_w, sheet_h = sheet.get_size()
            cols = 5
            rows = 4
            fw = sheet_w // cols
            fh = sheet_h // rows
            anims = {'up': [], 'right': [], 'down': [], 'left': []}
            directions = ['up', 'right', 'down', 'left']
            for row, direction in enumerate(directions):
                for col in range(cols):
                    frame = pygame.Surface((fw, fh), pygame.SRCALPHA)
                    frame.blit(sheet, (0, 0), (col * fw, row * fh, fw, fh))
                    anims[direction].append(frame)
            return anims

        # 1. Load Explorer (Grid)
        explorer_sheet = load_img("explorer")
        if explorer_sheet:
            walk_anims = load_grid_explorer(explorer_sheet)
            self.animations['walk_up'] = walk_anims['up']
            self.animations['walk_right'] = walk_anims['right']
            self.animations['walk_down'] = walk_anims['down']
            self.animations['walk_left'] = walk_anims['left']

        # 2. Load Strips (Use Square Logic)
        self.animations[PlayerState.AFK_READMAP] = load_strip_square(load_img("readmap"))
        self.animations[PlayerState.AFK_LIGHT] = load_strip_square(load_img("light"))
        self.animations[PlayerState.AFK_SEARCH] = load_strip_square(load_img("search"))
        self.animations[PlayerState.AFK_SHRUG] = load_strip_square(load_img("shrug"))

        # 3. Load Deaths
        self.animations[PlayerState.DIE_TRAP] = load_strip_square(load_img("freakout"))
        self.animations[PlayerState.DIE_STUNG] = load_strip_square(load_img("stung"))
        self.animations[PlayerState.DIE_RED_MUMMY] = load_strip_square(load_img("redfight"))
        self.animations[PlayerState.DIE_WHITE_MUMMY] = load_strip_square(load_img("whitefight"))

    def is_ready(self):
        """Check if player can move (not moving AND cooldown finished)"""
        current_time = pygame.time.get_ticks()
        # Allow if not moving, not dead, and cooldown has passed
        return (not self.is_moving
                and "DIE" not in self.state.name
                and current_time >= self.next_move_time)

    def handle_input(self):
        # Allow input only if ready, or allow interrupting AFK
        if not self.is_ready() and "AFK" not in self.state.name:
            return None

        keys = pygame.key.get_pressed()
        dx, dy = 0, 0

        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            dx = -1
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            dx = 1
        elif keys[pygame.K_UP] or keys[pygame.K_w]:
            dy = -1
        elif keys[pygame.K_DOWN] or keys[pygame.K_s]:
            dy = 1
        elif keys[pygame.K_SPACE]:
            self._reset_afk()
            return (0, 0)

        if dx != 0 or dy != 0:
            self._reset_afk()
            return (dx, dy)

        return None

    def _reset_afk(self):
        """Reset AFK timer and state"""
        self.last_input_time = pygame.time.get_ticks()
        if "AFK" in self.state.name:
            self.state = PlayerState.IDLE
            self.frame_index = 0

    def move_player(self, dx, dy):
        # Set cooldown timer
        self.next_move_time = pygame.time.get_ticks() + self.move_cooldown

        # WAIT command
        if dx == 0 and dy == 0:
            self.state = PlayerState.IDLE
            self._reset_afk()
            return

        # START MOVING
        self.x += dx
        self.y += dy
        self.target_x = self.x * self.tile_size
        self.target_y = self.y * self.tile_size

        self.is_moving = True
        self.state = PlayerState.WALK
        self._reset_afk()

        # --- NEW: PLAY START SOUND ---
        # Returns '15', '30', or '60' so we know which one to finish with
        self.current_walk_variant = sfx_manager.play_walk_start('player')

        if dx > 0: self.direction = 'right'
        if dx < 0: self.direction = 'left'
        if dy > 0: self.direction = 'down'
        if dy < 0: self.direction = 'up'

    def update(self):
        current_time = pygame.time.get_ticks()

        # --- 1. Movement Logic ---
        if self.is_moving:
            if self.pixel_x < self.target_x:
                self.pixel_x = min(self.pixel_x + self.move_speed, self.target_x)
            elif self.pixel_x > self.target_x:
                self.pixel_x = max(self.pixel_x - self.move_speed, self.target_x)

            if self.pixel_y < self.target_y:
                self.pixel_y = min(self.pixel_y + self.move_speed, self.target_y)
            elif self.pixel_y > self.target_y:
                self.pixel_y = max(self.pixel_y - self.move_speed, self.target_y)

            # Check if movement finished
            if self.pixel_x == self.target_x and self.pixel_y == self.target_y:
                self.is_moving = False

                if self.current_walk_variant:
                    sfx_manager.play_walk_end('player', self.current_walk_variant)
                    self.current_walk_variant = None  # Reset

                self.state = PlayerState.IDLE
                self.frame_index = 0
                self.last_input_time = current_time

                # --- 2. AFK Trigger Logic ---
        # Ensure we only trigger AFK if we are TRULY idle (cooldown passed + delay passed)
        elif self.state == PlayerState.IDLE:
            # Wait until cooldown allows movement before counting AFK time
            if current_time >= self.next_move_time:
                if current_time - self.last_input_time > self.afk_delay:
                    self._trigger_random_afk()

        # --- 3. Animation Update ---
        anim_list = []
        if self.state == PlayerState.WALK:
            anim_list = self.animations.get(f'walk_{self.direction}', [])
        elif self.state == PlayerState.IDLE:
            frames = self.animations.get(f'walk_{self.direction}', [])
            if frames: anim_list = [frames[0]]
        else:
            anim_list = self.animations.get(self.state, [])

        if not anim_list: return

        self.animation_counter += self.animation_speed
        if self.animation_counter >= 1.0:
            self.animation_counter = 0

            if self.state == PlayerState.WALK:
                self.frame_index = (self.frame_index + 1) % len(anim_list)

            elif "AFK" in self.state.name:
                if self.frame_index < len(anim_list) - 1:
                    self.frame_index += 1
                else:
                    self.state = PlayerState.IDLE
                    self.direction = 'down'
                    self.last_input_time = current_time
                    self.frame_index = 0

            elif "DIE" in self.state.name:
                if self.frame_index < len(anim_list) - 1:
                    self.frame_index += 1

    def _trigger_random_afk(self):
        options = [PlayerState.AFK_READMAP, PlayerState.AFK_LIGHT, PlayerState.AFK_SEARCH, PlayerState.AFK_SHRUG]
        self.state = random.choice(options)
        self.frame_index = 0

    def draw(self, surface):
        anim_list = []
        if self.state == PlayerState.WALK or self.state == PlayerState.IDLE:
            anim_list = self.animations.get(f'walk_{self.direction}', [])
        else:
            anim_list = self.animations.get(self.state, [])

        if anim_list:
            idx = self.frame_index if self.frame_index < len(anim_list) else 0
            image = anim_list[idx]

            draw_x = maze_coord_x + self.pixel_x
            draw_y = maze_coord_y + self.pixel_y

            offset_x = (self.tile_size - image.get_width()) // 2
            offset_y = (self.tile_size - image.get_height()) // 2

            surface.blit(image, (draw_x + offset_x, draw_y + offset_y))

==============================
PATH: MummyMaze\api\io\Lightning\gui\GameUI.py
==============================

import pygame
import os
from enum import Enum

from api.io.Lightning.gui.MapTracker import WorldMapPanel
from api.io.Lightning.manager.SoundReader import sfx_manager, music_manager
from api.io.Lightning.manager.TextDesigner import PyramidFont
from api.io.Lightning.maze.MazeLoader import MazeLoader
from api.io.Lightning.listener.AnimatedListener import initialize_torch_animation
from api.io.Lightning.utils.ConfigFile import *
from api.io.Lightning.manager.ButtonManager import ButtonManager
from api.io.Lightning.entities.Player import Player, PlayerState


class TurnState(Enum):
    PLAYER_INPUT = 0
    PLAYER_MOVING = 1
    ENEMY_TURN = 2
    ENEMY_MOVING = 3
    PLAYER_DYING = 4
    FIGHT_PAUSE = 5


_button_manager = None
_torch_animation = None
_maze_loader = None
_maze_size = None
_player = None
_world_map = None
_turn_state = TurnState.PLAYER_INPUT
_death_timer = 0
_killer_ref = None
_death_step = 0
_death_step_timer = 0
_fight_pause_timer = 0
_show_options = False

# ‚úÖ Cache UI images (load 1 l·∫ßn, d√πng l·∫°i)
_snake_img = None
_mumlogo_img = None


def _get_ui_images():
    """Load/cached snake + mumlogo once to avoid reloading every frame."""
    global _snake_img, _mumlogo_img

    if _snake_img is None:
        _snake_img = pygame.image.load(os.path.join(UI_PATH, "snake.png")).convert_alpha()

    if _mumlogo_img is None:
        _mumlogo_img = pygame.image.load(os.path.join(UI_PATH, "mumlogo.png")).convert_alpha()

    return _snake_img, _mumlogo_img

def _reset_runtime_state():
    global _turn_state, _death_timer, _killer_ref
    global _death_step, _death_step_timer, _fight_pause_timer
    global _show_options

    _turn_state = TurnState.PLAYER_INPUT
    _death_timer = 0
    _killer_ref = None
    _death_step = 0
    _death_step_timer = 0
    _fight_pause_timer = 0
    _show_options = False

def initialize_ui(mode="random", level_id=1, size=8, difficulty="medium"):
    global _button_manager, _torch_animation, _maze_loader, _player, _turn_state, _world_map
    global _snake_img, _mumlogo_img, _maze_size

    # ‚úÖ reset cache when init (optional but safe)
    _snake_img = None
    _mumlogo_img = None

    _maze_size = size  # l∆∞u ƒë·ªÉ debug n·∫øu c·∫ßn
    _reset_runtime_state()

    _button_manager = ButtonManager()
    _torch_animation = initialize_torch_animation()
    sfx_manager.initialize()
    music_manager.initialize()
    _world_map = WorldMapPanel(x=8, y=320)

    try:
        if mode == "campaign":
            _maze_loader = MazeLoader(level_id=level_id, difficulty=None, generate_infinite=False)
        else:
            _maze_loader = MazeLoader(level_id=None, difficulty=difficulty, generate_infinite=True, maze_size=size)
    except Exception as e:
        print(f"‚ö†Ô∏è MazeLoader init failed (mode={mode}, level_id={level_id}): {e}")
        # fallback ƒë·ªÉ game v·∫´n ch·∫°y
        _maze_loader = MazeLoader(level_id=None, difficulty=difficulty, generate_infinite=True, maze_size=size)
        mode = "random"

    if _maze_loader and _maze_loader.parsed:
        p = _maze_loader.parsed["player"]
        _player = Player(p["x"], p["y"], _maze_loader.maze_size, _maze_loader.cell_size)

    _turn_state = TurnState.PLAYER_INPUT



def restart_level():
    _reset_runtime_state()
    global _player, _maze_loader, _turn_state, _death_timer, _killer_ref
    if _maze_loader:
        _maze_loader.reset()
        p = _maze_loader.parsed["player"]
        _player = Player(p["x"], p["y"], _maze_loader.maze_size, _maze_loader.cell_size)

    _turn_state = TurnState.PLAYER_INPUT
    _death_timer = 0
    _killer_ref = None
    reset_input()


def undo_move():
    global _player, _maze_loader, _turn_state, _death_timer, _killer_ref
    if _maze_loader and _player:
        if _maze_loader.undo_last_move(_player):
            _turn_state = TurnState.PLAYER_INPUT
            _death_timer = 0
            _killer_ref = None
            _player.state = PlayerState.IDLE
            _player.frame_index = 0
            print("‚Ü∫ Undo successful: State reset to PLAYER_INPUT")
        else:
            print("Cannot Undo: History stack empty")


def reset_input():
    if _button_manager:
        _button_manager.clear_clicked()

def _is_win():
    """Win n·∫øu player ƒë·ª©ng t·∫°i √¥ 'win cell' do MazeLoader t√≠nh (th·ªëng nh·∫•t v·ªõi c√°ch v·∫Ω stairs)."""
    global _maze_loader, _player
    if not _maze_loader or not _player:
        return False

    win = _maze_loader.get_win_cell()  # (x,y) trong grid
    if not win:
        return False

    return (_player.x == win[0] and _player.y == win[1])



def draw_screen(screen, hovered=None, clicked=None, draw_mumlogo=True, mumlogo_y=None):
    global _torch_animation, _maze_loader, _player, _turn_state
    global _death_step, _death_step_timer, _fight_pause_timer, _killer_ref

    # ‚úÖ Use cached images
    snake, mumlogo = _get_ui_images()

    # --- Update gameplay state ---
    if not _show_options and _player and _maze_loader:
        _player.update()
        _maze_loader.update()

        if _turn_state == TurnState.PLAYER_MOVING:
            if not _player.is_moving:
                _maze_loader.check_key_collision(_player.x, _player.y)
                # Trap is deadly: stepping onto a trap triggers immediate loss animation.
                if _maze_loader.check_trap_collision(_player.x, _player.y):
                    _maze_loader.pause_enemies()
                    _player.state = PlayerState.DIE_TRAP
                    _player.frame_index = 0
                    _turn_state = TurnState.PLAYER_DYING
                    _death_step = 3
                    _death_step_timer = 0
                    _killer_ref = None
                    return None
                if _is_win():
                    return "win"
                _turn_state = TurnState.ENEMY_TURN
                _maze_loader.init_enemy_turn_sequence()

        elif _turn_state == TurnState.ENEMY_TURN:
            for e in _maze_loader.enemies_list:
                e.prev_x = e.x
                e.prev_y = e.y
            _maze_loader.init_enemy_turn_sequence()
            _turn_state = TurnState.ENEMY_MOVING

        elif _turn_state == TurnState.ENEMY_MOVING:
            kill = False
            for e in _maze_loader.enemies_list:
                if e.x == _player.x and e.y == _player.y:
                    sfx_manager.play("pummel")
                    e.move_queue.clear()
                    _killer_ref = e
                    _maze_loader.spawn_fight_cloud(_player.x, _player.y)
                    _killer_ref.face_target(_player.x, _player.y)

                    _turn_state = TurnState.PLAYER_DYING
                    _death_step = 1
                    _death_step_timer = pygame.time.get_ticks()
                    kill = True
                    break

            if not kill:
                if _maze_loader.resolve_enemy_collisions():
                    _maze_loader.pause_enemies()
                    _turn_state = TurnState.FIGHT_PAUSE
                    _fight_pause_timer = pygame.time.get_ticks()
                else:
                    if _maze_loader.update_turn_sequence(_player.get_pos()):
                        _maze_loader.face_enemies_to_player(_player)
                        _turn_state = TurnState.PLAYER_INPUT
                        _player.last_input_time = pygame.time.get_ticks()
                        _maze_loader.check_solvability(_player)

        elif _turn_state == TurnState.FIGHT_PAUSE:
            if pygame.time.get_ticks() - _fight_pause_timer > 500:
                _maze_loader.process_pending_deaths()
                _maze_loader.resume_enemies()
                _turn_state = TurnState.ENEMY_MOVING

        elif _turn_state == TurnState.PLAYER_DYING:
            now = pygame.time.get_ticks()
            if _death_step == 1:
                if now - _death_step_timer > 550:
                    if _killer_ref and "scorpion" in _killer_ref.type:
                        _killer_ref.retreat_to(_killer_ref.prev_x, _killer_ref.prev_y)
                        _death_step = 2
                    else:
                        if _killer_ref and "mummy" in _killer_ref.type:
                            _player.state = (
                                PlayerState.DIE_RED_MUMMY
                                if _killer_ref.type == "red_mummy"
                                else PlayerState.DIE_WHITE_MUMMY
                            )
                            if _killer_ref in _maze_loader.enemies_list:
                                _maze_loader.enemies_list.remove(_killer_ref)
                        _player.frame_index = 0
                        _death_step = 3

            elif _death_step == 2:
                if _killer_ref and not _killer_ref.is_moving:
                    _player.state = PlayerState.DIE_STUNG
                    sfx_manager.play("poison")
                    _player.frame_index = 0
                    _death_step = 3
                    _death_step_timer = now

            elif _death_step == 3:
                anim = _player.animations.get(_player.state, [])
                if anim and _player.frame_index >= len(anim) - 1:
                    if _death_step_timer == 0:
                        _death_step_timer = now
                    if now - _death_step_timer > 1000:
                        return "lose"

        elif _turn_state == TurnState.PLAYER_INPUT:
            if "AFK" in _player.state.name:
                _maze_loader.trigger_enemy_afk()

    # --- Render ---
    if _maze_loader:
        _maze_loader.draw_background(screen)

    if _torch_animation and _torch_animation.loaded and _maze_loader:
        _torch_animation.update()
        ms = _maze_loader.maze_size
        if ms == 6:
            _torch_animation.draw(screen, 300, 40)
            _torch_animation.draw(screen, 475, 40)
        elif ms == 8:
            _torch_animation.draw(screen, 320, 40)
            _torch_animation.draw(screen, 455, 40)
        elif ms == 10:
            _torch_animation.draw(screen, 295, 40)
            _torch_animation.draw(screen, 475, 40)

    if _maze_loader:
        m = pygame.mouse.get_pos() if _turn_state == TurnState.PLAYER_INPUT else None
        _maze_loader.draw(screen, _player, None, m)

    # Left UI
    screen.blit(snake, (8, 80))
    if draw_mumlogo:
        screen.blit(mumlogo, (14, mumlogo_y if mumlogo_y else 14))

    if _world_map and _maze_loader:
        current_lvl = int(_maze_loader.level_id) if _maze_loader.level_id else 15
        _world_map.draw(screen, current_lvl)

    if _maze_loader:
        _maze_loader.draw_ankh(screen)

    if _button_manager:
        _button_manager.draw_buttons(screen, hovered, clicked)

    if _show_options:
        _draw_options_menu(screen)

    return None


def _draw_options_menu(screen):
    overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 150))
    screen.blit(overlay, (0, 0))

    cx, cy = screen.get_width() // 2, screen.get_height() // 2
    rect = pygame.Rect(cx - 150, cy - 100, 300, 200)

    pygame.draw.rect(screen, (40, 30, 10), rect)
    pygame.draw.rect(screen, (150, 100, 50), rect, 3)

    font = pygame.font.SysFont("arial", 24, bold=True)
    small = pygame.font.SysFont("arial", 18)

    t = font.render("OPTIONS", True, (255, 200, 50))
    screen.blit(t, (cx - t.get_width() // 2, rect.y + 15))

    m_vol = int(music_manager.get_volume() * 100)
    s_vol = int(sfx_manager.get_volume() * 100)

    screen.blit(small.render(f"Music: {m_vol}%  [- / +]", True, (255, 255, 255)), (rect.x + 40, rect.y + 60))
    screen.blit(small.render(f"SFX: {s_vol}%  [- / +]", True, (255, 255, 255)), (rect.x + 40, rect.y + 100))

    c = small.render("Click OPTIONS to Close", True, (150, 150, 150))
    screen.blit(c, (cx - c.get_width() // 2, rect.bottom - 30))


def handle_game_input(event, mouse_pos):
    global _button_manager, _player, _maze_loader, _turn_state, _show_options
    
    # --- KEYBOARD SHORTCUTS ---
    if event.type == pygame.KEYDOWN:
        # ESC: toggle options
        if event.key == pygame.K_ESCAPE:
            _show_options = not _show_options
            return "option"

        # Khi ƒëang m·ªü options: M v·ªÅ menu
        if _show_options and event.key == pygame.K_m:
            _show_options = False
            return "menu"

        # Khi ƒëang m·ªü options: +/- ch·ªânh volume nhanh
        if event.key in (pygame.K_MINUS, pygame.K_KP_MINUS):
            v = music_manager.get_volume() - 0.1
            music_manager.set_volume(max(0.0, min(1.0, v)))
            return None

        if event.key in (pygame.K_EQUALS, pygame.K_PLUS, pygame.K_KP_PLUS):
            v = music_manager.get_volume() + 0.1
            music_manager.set_volume(max(0.0, min(1.0, v)))
            return None

    # --------------------------

    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        clicked_btn = None
        for name, rect in _button_manager.button_rects.items():
            if rect.collidepoint(mouse_pos):
                clicked_btn = name
                _button_manager.set_clicked(name)
                break

        if clicked_btn == "option":
            _show_options = not _show_options
            return "option"

        if not _show_options:
            if clicked_btn == "undo":
                if _turn_state == TurnState.PLAYER_INPUT:
                    undo_move()
                return "undo"

            if clicked_btn == "reset":
                restart_level()
                return "reset"

        if _show_options:
            cx, cy = 640 // 2, 480 // 2
            bx, by = cx - 150, cy - 100
            if bx < mouse_pos[0] < bx + 300:
                if by + 50 < mouse_pos[1] < by + 80:
                    dv = 0.1 if mouse_pos[0] > cx else -0.1
                    music_manager.set_volume(max(0.0, min(1.0, music_manager.get_volume() + dv)))
                elif by + 90 < mouse_pos[1] < by + 120:
                    dv = 0.1 if mouse_pos[0] > cx else -0.1
                    sfx_manager.set_volume(max(0.0, min(1.0, sfx_manager.get_volume() + dv)))
            return None

    if _show_options:
        return None
    if _turn_state != TurnState.PLAYER_INPUT:
        return None

    if _player and _maze_loader:
        move = _player.handle_input()
        if move:
            dx, dy = move
            _execute_player_move(dx, dy)

    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        if _player and _maze_loader:
            mx, my = mouse_pos
            gx = (mx - maze_coord_x) // _maze_loader.cell_size
            gy = (my - maze_coord_y) // _maze_loader.cell_size
            if 0 <= gx < _maze_loader.maze_size and 0 <= gy < _maze_loader.maze_size:
                dx = gx - _player.x
                dy = gy - _player.y
                if dx == 0 and dy == 0:
                    _execute_player_move(0, 0)
                elif abs(dx) + abs(dy) == 1:
                    _execute_player_move(dx, dy)

    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
        _button_manager.clear_clicked()

    return None


def _execute_player_move(dx, dy):
    global _player, _maze_loader, _turn_state
    if not _player.is_ready():
        return

    tx = _player.x + dx
    ty = _player.y + dy

    for e in _maze_loader.enemies_list:
        if e.x == tx and e.y == ty:
            return

    if _player.check_eligible_move(tx, ty, _maze_loader.maze_size, _maze_loader.parsed["walls"], _maze_loader.gate_obj):
        _maze_loader.save_state(_player)
        _player.move_player(dx, dy)
        _turn_state = TurnState.PLAYER_MOVING


def get_hover_state(mouse_pos):
    if not _button_manager:
        return None
    for name, rect in _button_manager.button_rects.items():
        if rect.collidepoint(mouse_pos):
            return name
    return None


def get_clicked_state():
    return _button_manager.clicked_button if _button_manager else None


==============================
PATH: MummyMaze\api\io\Lightning\gui\Interface.py
==============================

import pygame
import os

from api.io.Lightning.gui import GameUI
from api.io.Lightning.gui.LoseState import lose_screen
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.utils.ConfigFile import UI_PATH, SOUNDS_PATH, fps
from api.io.Lightning.manager.SoundReader import music_manager


def init():
    pygame.init()
    screen = pygame.display.set_mode((640, 480))
    pygame.display.set_caption("Mummy Maze Ultimate 1.0")
    icon = pygame.image.load(os.path.join(UI_PATH, 'game.ico'))
    pygame.display.set_icon(icon)
    GameUI.initialize_ui()
    return screen


def loading_screen(screen, clock):
    music_manager.initialize()
    title = pygame.image.load(os.path.join(UI_PATH, 'title.jpg'))
    progress_bar = pygame.image.load(os.path.join(UI_PATH, 'titlebar.jpg')).convert_alpha()
    color = TextDesigner(color=(255, 125, 17), hover_color=(255, 255, 255))
    play = color.render('CLICK HERE TO PLAY', outline_thickness=1, hovered=False)
    play_hovered = color.render('CLICK HERE TO PLAY', outline_thickness=1, hovered=True)
    play_rect = play.get_rect(topleft=(190, 430))

    progress = 0
    speed = 0.2
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            music_manager.handle_event(event)
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and progress >= 100:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                mouse_pos = pygame.mouse.get_pos()
                if play_rect.collidepoint(mouse_pos):
                    return "main_menu"

        screen.blit(title, (0, 0))
        fill_px = int((progress / 100) * 340)
        bar_crop = progress_bar.subsurface((0, 0, fill_px, 24))
        screen.blit(bar_crop, (147, 392))
        if progress < 100:
            progress += speed
            if progress > 100: progress = 100
        else:
            mouse_pos = pygame.mouse.get_pos()
            if play_rect.collidepoint(mouse_pos):
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
                screen.blit(play_hovered, (190, 430))
            else:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                screen.blit(play, (190, 430))
        pygame.display.flip()
        clock.tick(fps)
    return None


def main_menu(screen, clock):
    menuback = pygame.image.load(os.path.join(UI_PATH, 'menuback.jpg'))
    menufront = pygame.image.load(os.path.join(UI_PATH, 'menufront.png'))
    logo = pygame.image.load(os.path.join(UI_PATH, 'menulogo.png'))
    color = TextDesigner(color=(0, 0, 0), hover_color=(245, 0, 0))
    tombslide_sound = pygame.mixer.Sound(os.path.join(SOUNDS_PATH, 'tombslide.wav'))
    tombslide_sound.play()

    classic = color.render('CLASSIC MODE', outline=False, hovered=False)
    classic_hovered = color.render('CLASSIC MODE', outline_thickness=1, hovered=True)
    classic_rect = classic.get_rect(topleft=(100, 360))
    tutorial = color.render('TUTORIAL', outline=False, hovered=False)
    tutorial_hovered = color.render('TUTORIAL', outline_thickness=1, hovered=True)
    tutorial_rect = tutorial.get_rect(topleft=(390, 360))

    logo_x = 92.5
    logo_target_y = 10
    logo_start_y = -logo.get_height()
    menu_target_y = 0
    menu_start_y = 480
    animation_progress = 0.0
    animation_speed = 0.02
    animation_complete = False

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: return None
            music_manager.handle_event(event)
            if animation_complete and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if classic_rect.collidepoint(mouse_pos):
                    return "classic_mode"
                elif tutorial_rect.collidepoint(mouse_pos):
                    return "tutorial"

        screen.blit(menuback, (0, 0))
        if animation_progress < 1.0:
            animation_progress += animation_speed
            if animation_progress > 1.0:
                animation_progress = 1.0
                animation_complete = True
            eased_progress = 1 - (1 - animation_progress) ** 2
            current_logo_y = logo_start_y + (logo_target_y - logo_start_y) * eased_progress
            current_menu_y = menu_start_y + (menu_target_y - menu_start_y) * eased_progress
            screen.blit(menufront, (0, current_menu_y))
            button_y = 360 + (current_menu_y - menu_target_y)
            screen.blit(classic, (100, button_y))
            screen.blit(tutorial, (390, button_y))
            screen.blit(logo, (logo_x, current_logo_y))
        else:
            screen.blit(menufront, (0, menu_target_y))
            mouse_pos = pygame.mouse.get_pos()
            hovered = 'classic' if classic_rect.collidepoint(mouse_pos) else 'tutorial' if tutorial_rect.collidepoint(
                mouse_pos) else None

            if hovered == 'classic':
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
                screen.blit(classic_hovered, (100, 360))
                screen.blit(tutorial, (390, 360))
            elif hovered == 'tutorial':
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
                screen.blit(classic, (100, 360))
                screen.blit(tutorial_hovered, (390, 360))
            else:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
                screen.blit(classic, (100, 360))
                screen.blit(tutorial, (390, 360))
            screen.blit(logo, (logo_x, logo_target_y))
        pygame.display.flip()
        clock.tick(fps)
    return None


def classic_mode(screen, clock):
    GameUI.reset_input()
    music_manager.start_hard_mode_music()
    tombslide_sound = pygame.mixer.Sound(os.path.join(SOUNDS_PATH, 'tombslide.wav'))
    tombslide_sound.play()
    mumlogo = pygame.image.load(os.path.join(UI_PATH, 'mumlogo.png')).convert_alpha()

    mumlogo_target_y = 14
    mumlogo_start_y = -mumlogo.get_height()
    mumlogo_x = 14
    animation_progress = 0.0
    animation_speed = 0.02
    animation_complete = False

    running = True
    while running:
        mouse_pos = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT: return None
            music_manager.handle_event(event)
            if animation_complete:
                action = GameUI.handle_game_input(event, mouse_pos)
                if action == 'quit': return "main_menu"

        hovered = GameUI.get_hover_state(mouse_pos) if animation_complete else None
        clicked = GameUI.get_clicked_state() if animation_complete else None

        if animation_complete:
            if hovered:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
            else:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)

        if animation_progress < 1.0:
            animation_progress += animation_speed
            if animation_progress > 1.0:
                animation_progress = 1.0
                animation_complete = True
            eased_progress = 1 - (1 - animation_progress) ** 2
            current_mumlogo_y = mumlogo_start_y + (mumlogo_target_y - mumlogo_start_y) * eased_progress
            GameUI.draw_screen(screen, hovered, clicked, draw_mumlogo=False, mumlogo_y=current_mumlogo_y)
            screen.blit(mumlogo, (mumlogo_x, current_mumlogo_y))
        else:
            status = GameUI.draw_screen(screen, hovered, clicked)
            if status == "lose":
                # Snapshot GameUI for the overlay background
                game_snapshot = screen.copy()
                return "lose_screen", game_snapshot

        pygame.display.flip()
        clock.tick(fps)
    return None


if __name__ == '__main__':
    screen = init()
    clock = pygame.time.Clock()
    current_screen = "classic_mode"
    background_capture = None

    while current_screen:
        if current_screen == "loading":
            current_screen = loading_screen(screen, clock)
        elif current_screen == "main_menu":
            current_screen = main_menu(screen, clock)
        elif current_screen == "classic_mode":
            result = classic_mode(screen, clock)

            if isinstance(result, tuple):
                status, data = result
                if status == "lose_screen":
                    background_capture = data
                    current_screen = "lose_screen"
            elif result == "main_menu":
                current_screen = "main_menu"
                music_manager.start_menu_music()
            else:
                current_screen = None

        elif current_screen == "lose_screen":
            current_screen = lose_screen(screen, clock, background_surf=background_capture)
            if current_screen == "retry":
                # CALL THE RESTART FUNCTION HERE
                GameUI.restart_level()
                current_screen = "classic_mode"
            elif current_screen == "save_quit":
                GameUI.restart_level()
                current_screen = "main_menu"
                music_manager.start_menu_music()
            elif current_screen == "undo":
                # FIX: Actually call the undo function!
                GameUI.undo_move()
                current_screen = "classic_mode"

        elif current_screen == "tutorial":
            current_screen = None
            if current_screen == "main_menu":
                music_manager.start_menu_music()
        else:
            break

    pygame.quit()

==============================
PATH: MummyMaze\api\io\Lightning\gui\LoseState.py
==============================

import pygame
import os

from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.utils.ConfigFile import UI_PATH, fps


def lose_screen(screen, clock, background_surf=None):
    """
    Displays the Lose Screen.
    If background_surf is provided, it is drawn as the static background (overlay effect).
    """

    # 1. Load Background Assets
    if background_surf:
        menuback = background_surf
    else:
        menuback = pygame.image.load(os.path.join(UI_PATH, 'menuback.jpg'))

    menufront = pygame.image.load(os.path.join(UI_PATH, 'menufront.png'))

    # 2. Setup Text Designer
    designer = TextDesigner(color=(0, 0, 0), hover_color=(245, 0, 0))

    # 3. Create Button Surfaces
    btn_try = designer.render('TRY AGAIN', outline=False, hovered=False)
    btn_try_h = designer.render('TRY AGAIN', outline_thickness=1, hovered=True)

    btn_abandon = designer.render('ABANDON HOPE', outline=False, hovered=False)
    btn_abandon_h = designer.render('ABANDON HOPE', outline_thickness=1, hovered=True)

    btn_undo = designer.render('UNDO MOVE', outline=False, hovered=False)
    btn_undo_h = designer.render('UNDO MOVE', outline_thickness=1, hovered=True)

    btn_save = designer.render('SAVE AND QUIT', outline=False, hovered=False)
    btn_save_h = designer.render('SAVE AND QUIT', outline_thickness=1, hovered=True)

    # 4. Define Layout Positions
    col1_x = 110
    col2_x = 360
    row1_y = 360
    row2_y = 410

    rect_try = btn_try.get_rect(topleft=(col1_x, row1_y))
    rect_abandon = btn_abandon.get_rect(topleft=(col2_x, row1_y))
    rect_undo = btn_undo.get_rect(topleft=(col1_x, row2_y))
    rect_save = btn_save.get_rect(topleft=(col2_x, row2_y))

    # 5. Animation Variables
    menu_target_y = 0
    menu_start_y = 480

    animation_progress = 0.0
    animation_speed = 0.02
    animation_complete = False

    running = True
    while running:
        # --- Event Handling ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return "quit"

            if animation_complete and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()

                if rect_try.collidepoint(mouse_pos):
                    return "retry"
                elif rect_abandon.collidepoint(mouse_pos):
                    return "main_menu"
                elif rect_undo.collidepoint(mouse_pos):
                    return "undo"
                elif rect_save.collidepoint(mouse_pos):
                    return "save_quit"

        # --- Update Animation ---
        current_menu_y = menu_target_y

        if animation_progress < 1.0:
            animation_progress += animation_speed
            if animation_progress > 1.0:
                animation_progress = 1.0
                animation_complete = True

            eased_progress = 1 - (1 - animation_progress) ** 2
            current_menu_y = menu_start_y + (menu_target_y - menu_start_y) * eased_progress

        # --- Drawing ---
        screen.blit(menuback, (0, 0))
        screen.blit(menufront, (0, current_menu_y))

        # Draw Buttons
        y_offset = current_menu_y - menu_target_y
        mouse_pos = pygame.mouse.get_pos()

        # Try Again
        if animation_complete and rect_try.collidepoint(mouse_pos):
            screen.blit(btn_try_h, (col1_x, row1_y + y_offset))
        else:
            screen.blit(btn_try, (col1_x, row1_y + y_offset))

        # Abandon Hope
        if animation_complete and rect_abandon.collidepoint(mouse_pos):
            screen.blit(btn_abandon_h, (col2_x, row1_y + y_offset))
        else:
            screen.blit(btn_abandon, (col2_x, row1_y + y_offset))

        # Undo Move
        if animation_complete and rect_undo.collidepoint(mouse_pos):
            screen.blit(btn_undo_h, (col1_x, row2_y + y_offset))
        else:
            screen.blit(btn_undo, (col1_x, row2_y + y_offset))

        # Save and Quit
        if animation_complete and rect_save.collidepoint(mouse_pos):
            screen.blit(btn_save_h, (col2_x, row2_y + y_offset))
        else:
            screen.blit(btn_save, (col2_x, row2_y + y_offset))

        # Cursor Logic
        if animation_complete:
            is_hovering = (rect_try.collidepoint(mouse_pos) or
                           rect_abandon.collidepoint(mouse_pos) or
                           rect_undo.collidepoint(mouse_pos) or
                           rect_save.collidepoint(mouse_pos))

            if is_hovering:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
            else:
                pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)

        pygame.display.flip()
        clock.tick(fps)

    return "quit"

==============================
PATH: MummyMaze\api\io\Lightning\gui\MapTracker.py
==============================

import pygame, os

from api.io.Lightning.manager.TextDesigner import PyramidFont
from api.io.Lightning.utils.ConfigFile import UI_PATH

class WorldMapPanel:
    def __init__(self, x=8, y=320):
        # 1. Load Assets
        self.bg_map = pygame.image.load(os.path.join(UI_PATH, 'map.png')).convert_alpha()
        self.label_pyramid = pygame.image.load(os.path.join(UI_PATH, 'pyramidtext.gif')).convert_alpha()
        self.icon_head = pygame.image.load(os.path.join(UI_PATH, 'maphead.png')).convert_alpha()
        self.icon_x = pygame.image.load(os.path.join(UI_PATH, 'mapx.png')).convert_alpha()
        self.number_font = PyramidFont()

        # Set Rect based on loaded map image
        self.rect = self.bg_map.get_rect()
        self.rect.topleft = (x, y)

        # 2. Define Pyramid Node Positions

        # --- ADJUSTMENT SETTINGS ---
        # 1. Spacing Settings (Significantly tightened to stop drifting right)
        col_w = 20  # Reduced from 23 -> 20 (This pulls the nodes closer together)
        row_h = 15  # Kept vertical spacing the same
        bottom_y = 93

        # 2. Global Horizontal Shift
        # Since we shrank the spacing, we need to shift the center LEFT to keep Node 1
        # in the same place you liked.
        manual_x_offset = -2

        center_x = (self.rect.width // 2) + manual_x_offset
        self.nodes = []

        # --- Row 1 (Bottom): Levels 1-5 ---
        y = bottom_y
        self.nodes.extend([
            (center_x - col_w * 2, y),  # Lvl 1
            (center_x - col_w, y),  # Lvl 2
            (center_x, y),  # Lvl 3
            (center_x + col_w, y),  # Lvl 4
            (center_x + col_w * 2, y)  # Lvl 5
        ])

        # --- Row 2: Levels 6-9 ---
        y -= row_h
        self.nodes.extend([
            (center_x - col_w * 1.5, y),  # Lvl 6
            (center_x - col_w * 0.5, y),  # Lvl 7
            (center_x + col_w * 0.5, y),  # Lvl 8
            (center_x + col_w * 1.5, y)  # Lvl 9
        ])

        # --- Row 3: Levels 10-12 ---
        y -= row_h
        self.nodes.extend([
            (center_x - col_w, y),  # Lvl 10
            (center_x, y),  # Lvl 11
            (center_x + col_w, y)  # Lvl 12
        ])

        # --- Row 4: Levels 13-14 ---
        y -= row_h
        self.nodes.extend([
            (center_x - col_w * 0.5, y),  # Lvl 13
            (center_x + col_w * 0.5, y)  # Lvl 14
        ])

        # --- Row 5 (Top): Level 15 ---
        y -= row_h
        self.nodes.append((center_x, y))  # Lvl 15

    def draw(self, screen, current_level_idx):
        """
        current_level_idx: 1-based index (1 to 15)
        """
        # 1. Draw Background Map
        screen.blit(self.bg_map, self.rect.topleft)

        # 2. Draw "Pyramid" Label
        screen.blit(self.label_pyramid, (self.rect.x + 10, self.rect.y + 10))

        # 3. Draw "1" (Pyramid Number)
        pyramid_num_surf = self.number_font.render("1")
        screen.blit(pyramid_num_surf, (self.rect.x + 28, self.rect.y + 25))

        # 4. Draw Nodes
        for i, (node_x, node_y) in enumerate(self.nodes):
            level_num = i + 1

            # Calculate absolute screen position
            draw_pos_x = self.rect.x + node_x
            draw_pos_y = self.rect.y + node_y

            if level_num < current_level_idx:
                # Completed Level -> Draw X
                dest = (draw_pos_x - self.icon_x.get_width() // 2,
                        draw_pos_y - self.icon_x.get_height() // 2)
                screen.blit(self.icon_x, dest)

            elif level_num == current_level_idx:
                # Current Level -> Draw Head
                # Head is drawn slightly higher (-2) for visual overlap
                dest = (draw_pos_x - self.icon_head.get_width() // 2,
                        draw_pos_y - self.icon_head.get_height() // 2 - 2)
                screen.blit(self.icon_head, dest)

==============================
PATH: MummyMaze\api\io\Lightning\gui\WinState.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\listener\AnimatedListener.py
==============================

import pygame
import os
from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH

class TorchAnimation:
    def __init__(self):
        self.torch_frames = []
        self.torch_glow_frames = []
        self.frame_index = 0
        self.animation_speed = 0.15  # Adjust speed (lower = slower)
        self.animation_counter = 0
        self.loaded = False

    def load(self):
        """Load torch flame and glow animation frames"""
        try:
            # Load single torch image
            torch_image = pygame.image.load(os.path.join(OBJECTS_PATH, 'torch.png')).convert_alpha()

            # Load torch glow strip (10 frames horizontally)
            torch_glow_strip = pygame.image.load(os.path.join(OBJECTS_PATH, 'glow.png')).convert_alpha()

            # Load flame animation strip (10 frames horizontally)
            flame_strip = pygame.image.load(os.path.join(OBJECTS_PATH, 'flame.png')).convert_alpha()

            # Get dimensions
            glow_frame_width = torch_glow_strip.get_width() // 10  # 10 frames
            glow_frame_height = torch_glow_strip.get_height()

            flame_frame_width = flame_strip.get_width() // 10  # 10 frames
            flame_frame_height = flame_strip.get_height()

            print(f"Torch dimensions - Glow: {glow_frame_width}x{glow_frame_height}, "
                  f"Flame:  {flame_frame_width}x{flame_frame_height}, "
                  f"Base: {torch_image.get_width()}x{torch_image.get_height()}")

            # Extract glow frames
            self.torch_glow_frames = []
            for i in range(10):
                frame = torch_glow_strip.subsurface((i * glow_frame_width, 0, glow_frame_width, glow_frame_height))
                self.torch_glow_frames.append(frame.copy())

            # Extract flame frames and combine with torch base
            self.torch_frames = []
            for i in range(10):
                # Calculate combined dimensions
                combined_width = max(torch_image.get_width(), flame_frame_width)
                combined_height = torch_image.get_height() + flame_frame_height

                # Create a surface to hold the complete torch (base + flame)
                torch_complete = pygame.Surface((combined_width, combined_height), pygame.SRCALPHA)

                # Extract flame frame
                flame_frame = flame_strip.subsurface((i * flame_frame_width, 0, flame_frame_width, flame_frame_height))

                # Center the torch base and flame
                torch_x = (combined_width - torch_image.get_width()) // 2
                flame_x = (combined_width - flame_frame_width) // 2

                # Composite:  flame on top, torch base below (with slight overlap)
                torch_complete.blit(flame_frame, (flame_x, 0))  # Flame at top
                torch_complete.blit(torch_image, (torch_x, flame_frame_height - 5))  # Torch base (slight overlap)

                self.torch_frames.append(torch_complete)

            self.loaded = True
            print(
                f"TorchAnimation:  Loaded {len(self.torch_frames)} torch frames and {len(self.torch_glow_frames)} glow frames")

        except Exception as e:
            print(f"Error loading torch animation:  {e}")
            import traceback
            traceback.print_exc()
            # Create dummy frames as fallback
            self.torch_frames = [pygame.Surface((20, 30), pygame.SRCALPHA)]
            self.torch_glow_frames = [pygame.Surface((40, 40), pygame.SRCALPHA)]
            self.loaded = False

    def update(self):
        """Update torch animation frame"""
        if not self.loaded:
            return

        self.animation_counter += self.animation_speed

        if self.animation_counter >= 1.0:
            self.animation_counter = 0
            self.frame_index = (self.frame_index + 1) % len(self.torch_frames)

    def draw(self, screen, x, y):
        """Draw an animated torch with glow at position (x, y)"""
        if not self.loaded or not self.torch_frames or not self.torch_glow_frames:
            return

        glow = self.torch_glow_frames[self.frame_index]
        torch = self.torch_frames[self.frame_index]

        # Calculate torch center point
        torch_center_x = x + (torch.get_width() // 2)
        torch_flame_y = y + 10  # Position on the flame area

        # Center glow on the torch's flame
        glow_x = torch_center_x - (glow.get_width() // 2)
        glow_y = torch_flame_y - (glow.get_height() // 2)

        # Draw glow first (behind torch)
        screen.blit(glow, (glow_x, glow_y))

        # Draw torch with flame on top
        screen.blit(torch, (x, y))

    def set_speed(self, speed):
        """Set animation speed"""
        self.animation_speed = speed

# Global torch animation instance
torch_animation = None

def initialize_torch_animation():
    """Initialize torch animation"""
    global torch_animation
    if torch_animation is None:
        torch_animation = TorchAnimation()
        torch_animation.load()
    return torch_animation

def get_torch_animation():
    """Get torch animation instance"""
    return torch_animation

==============================
PATH: MummyMaze\api\io\Lightning\listener\DirectionListener.py
==============================

import pygame
import os

from api.io.Lightning.manager.Spritesheet import Spritesheet
from api.io.Lightning.utils.ConfigFile import UI_PATH

class Direction:
    def __init__(self, maze_size):
        self.spritesheet = Spritesheet(os.path.join(UI_PATH, f"arrows{maze_size}.gif"))
        self.circle = pygame.image.load(os.path.join(UI_PATH, f"circle{maze_size}.gif")).convert_alpha()
        self.animations = []
        self.move_images = {}

    def load_move_images(self, maze_size):
        w = self.spritesheet.sheet.get_width()
        h = self.spritesheet.sheet.get_height() // 4

        self.move_images = {
            'DOWN': self.spritesheet.get_image(0, 0, w, h),
            'RIGHT': self.spritesheet.get_image(0, h, w, h),
            'LEFT': self.spritesheet.get_image(0, h * 2, w, h),
            'UP': self.spritesheet.get_image(0, h * 3, w, h),
            'STAY': self.circle
        }

==============================
PATH: MummyMaze\api\io\Lightning\listener\GameState.py
==============================

import pygame

class GameState:
    def __init__(self):
        pygame.init()


==============================
PATH: MummyMaze\api\io\Lightning\listener\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\manager\ButtonManager.py
==============================

import pygame
import os

from api.io.Lightning.utils.ConfigFile import *
from api.io.Lightning.manager.Spritesheet import Spritesheet

class ButtonManager:
    def __init__(self):
        # Load buttonstrip using Spritesheet
        buttonstrip_path = os.path.join(UI_PATH, 'buttonstrip.jpg')
        spritesheet = Spritesheet(buttonstrip_path)

        # Calculate button dimensions
        button_width = 135
        button_height = 42

        # Extract each button from the spritesheet
        self.buttons = {
            'undo_move_hover': spritesheet.get_image(0, 0 * button_height, button_width, button_height),
            'undo_move_clicked': spritesheet.get_image(0, 1 * button_height, button_width, button_height),
            'reset_maze_hover': spritesheet.get_image(0, 2 * button_height, button_width, button_height),
            'reset_maze_clicked':  spritesheet.get_image(0, 3 * button_height, button_width, button_height),
            'options_hover': spritesheet.get_image(0, 4 * button_height, button_width, button_height),
            'options_clicked': spritesheet.get_image(0, 5 * button_height, button_width, button_height),
            'world_map_disabled': spritesheet.get_image(0, 8 * button_height, button_width, button_height),
            'quit_to_main_hover': spritesheet.get_image(0, 9 * button_height, button_width, button_height),
            'quit_to_main_clicked': spritesheet.get_image(0, 10 * button_height, button_width, button_height),
        }

        # Define button rectangles for collision detection
        self.button_rects = {
            'undo': pygame.Rect(8, 130, button_width, button_height),
            'reset': pygame.Rect(8, 172, button_width, button_height),
            'option': pygame.Rect(8, 225, button_width, button_height),
            'quit': pygame.Rect(8, 430, button_width, button_height),
        }

        # Track which button is currently being clicked
        self.clicked_button = None

        print(f"ButtonManager initialized successfully!")

    def get_button(self, name):
        return self.buttons. get(name)

    def set_clicked(self, button_name):
        """Set which button is being clicked"""
        self.clicked_button = button_name

    def clear_clicked(self):
        """Clear the clicked button state"""
        self.clicked_button = None

    def draw_buttons(self, screen, hovered=None, clicked=None):
        """Draw all buttons with hover and click states"""
        # Only draw buttons when hovered or clicked

        # Undo button
        if clicked == 'undo':
            screen.blit(self.buttons['undo_move_clicked'], (8, 130))
        elif hovered == 'undo':
            screen.blit(self.buttons['undo_move_hover'], (8, 130))

        # Reset button
        if clicked == 'reset':
            screen.blit(self.buttons['reset_maze_clicked'], (8, 172))
        elif hovered == 'reset':
            screen.blit(self. buttons['reset_maze_hover'], (8, 172))

        # Options button
        if clicked == 'option':
            screen.blit(self.buttons['options_clicked'], (8, 225))
        elif hovered == 'option':
            screen.blit(self.buttons['options_hover'], (8, 225))

        # World map (always visible - disabled)
        screen.blit(self.buttons['world_map_disabled'], (8, 267))

        # Quit button
        if clicked == 'quit':
            screen.blit(self.buttons['quit_to_main_clicked'], (8, 430))
        elif hovered == 'quit':
            screen.blit(self.buttons['quit_to_main_hover'], (8, 430))

==============================
PATH: MummyMaze\api\io\Lightning\manager\GameManager.py
==============================

from api.io.Lightning.maze.MazeGenerator import MazeBuilder
from api.io.Lightning.utils.ConfigFile import *

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((640, 480))
        self.clock = pygame.time.Clock()

        pygame.display.set_caption("Mummy Maze Ultimate 1.0")
        icon = pygame.image.load(os.path.join(UI_PATH, 'game.ico'))
        pygame.display.set_icon(icon)

        self.maze = MazeBuilder('none')
        cell_size = self.maze.cell_size

    def run_game(self):
        while self.running:
            self.events()
            self.update()
            self.draw()

            self.clock.tick(fps)
        pygame.quit()

==============================
PATH: MummyMaze\api\io\Lightning\manager\SoundReader.py
==============================

import random
import pygame, os
from api.io.Lightning.utils.ConfigFile import UI_PATH, MUSIC_PATH, SOUNDS_PATH

class MusicManager:
    def __init__(self):
        self.music_enabled = False
        self.current_track = 0
        self.loop_tracks = list(range(1, 13))
        self.current_loop_index = 0
        self.MUSIC_END = pygame.USEREVENT + 1
        self.initialized = False
        self.current_mode = "menu"
        self.volume = 0.5  # Default volume

    def initialize(self):
        if self.initialized: return
        try:
            if not pygame.mixer.get_init(): pygame.mixer.init()
            pygame.mixer.music.set_volume(self.volume)

            start_music = os.path.join(MUSIC_PATH, "00.mp3")
            if os.path.exists(start_music):
                pygame.mixer.music.load(start_music)
                pygame.mixer.music.play()
                pygame.mixer.music.set_endevent(self.MUSIC_END)
                self.music_enabled = True
                self.initialized = True
        except Exception as e:
            print(f'Music Init Error: {e}')

    def set_volume(self, vol):
        self.volume = max(0.0, min(1.0, vol))
        if self.initialized:
            pygame.mixer.music.set_volume(self.volume)

    def get_volume(self):
        return self.volume

    def handle_event(self, event):
        if event.type == self.MUSIC_END and self.music_enabled:
            try:
                if self.current_mode == "menu":
                    if self.current_track == 0:
                        self.current_track = self.loop_tracks[self.current_loop_index]
                    else:
                        self.current_loop_index = (self.current_loop_index + 1) % len(self.loop_tracks)
                        self.current_track = self.loop_tracks[self.current_loop_index]
                    self._play_track(f'{self.current_track:02d}.mp3')

                elif self.current_mode == "classic":
                    self.current_loop_index = (self.current_loop_index + 1) % len(self.loop_tracks)
                    self.current_track = self.loop_tracks[self.current_loop_index]
                    self._play_track(f'{self.current_track:02d}.mp3')

                elif self.current_mode == "hard":
                    self._play_track("hard_mode.mp3")

            except Exception as e:
                print(f'Music Loop Error: {e}')

    def _play_track(self, filename):
        path = os.path.join(MUSIC_PATH, filename)
        if os.path.exists(path):
            pygame.mixer.music.load(path)
            pygame.mixer.music.play()
        else:
            print(f"Missing track: {path}")

    def start_classic_mode_music(self):
        self.current_mode = "classic"
        self.loop_tracks = list(range(23, 39))
        self.current_loop_index = 0
        self.current_track = self.loop_tracks[0]
        self._play_track(f'{self.current_track:02d}.mp3')

    def start_menu_music(self):
        self.current_mode = "menu"
        self.loop_tracks = list(range(1, 13))
        self.current_loop_index = 0
        self.current_track = self.loop_tracks[0]
        self._play_track(f'{self.current_track:02d}.mp3')

    def start_hard_mode_music(self):
        self.current_mode = "hard"
        self._play_track("hard_mode.mp3")

    def stop(self):
        if self.music_enabled:
            pygame.mixer.music.stop()


class SoundEffectManager:
    def __init__(self):
        self.sounds = {}
        self.initialized = False
        self.volume = 0.5  # Default volume

    def initialize(self):
        if self.initialized: return
        if not pygame.mixer.get_init(): pygame.mixer.init()

        def load(name):
            path = os.path.join(SOUNDS_PATH, name)
            if os.path.exists(path):
                snd = pygame.mixer.Sound(path)
                snd.set_volume(self.volume)
                return snd
            return None

        # 1. Load Walk Sounds
        for variant in ['15', '30', '60']:
            self.sounds[f'exp_start_{variant}'] = load(f'expwalk{variant}a.wav')
            self.sounds[f'exp_end_{variant}'] = load(f'expwalk{variant}b.wav')
            self.sounds[f'mum_start_{variant}'] = load(f'mumwalk{variant}a.wav')
            self.sounds[f'mum_end_{variant}'] = load(f'mumwalk{variant}b.wav')

        self.sounds['scorp_1'] = load('scorpwalk1.wav')
        self.sounds['scorp_2'] = load('scorpwalk2.wav')

        # 2. Load Action Sounds
        self.sounds['pummel'] = load('pummel.wav')
        self.sounds['tombslide'] = load('tombslide.wav')
        self.sounds['gate'] = load('gate.wav')

        # --- FIX: Ensure these are loaded for the death/ankh logic ---
        self.sounds['badankh'] = load('badankh.wav')
        self.sounds['poison'] = load('poison.wav')
        # -------------------------------------------------------------

        self.initialized = True

    def set_volume(self, vol):
        self.volume = max(0.0, min(1.0, vol))
        if self.initialized:
            for sound in self.sounds.values():
                if sound: sound.set_volume(self.volume)

    def get_volume(self):
        return self.volume

    def play(self, name):
        if name in self.sounds and self.sounds[name]:
            self.sounds[name].play()

    def play_walk_start(self, entity_type):
        variant = random.choice(['15', '30', '60'])
        if entity_type == 'player':
            self.play(f'exp_start_{variant}')
        elif 'mummy' in entity_type:
            self.play(f'mum_start_{variant}')
        elif 'scorpion' in entity_type:
            scorp_var = random.choice(['1', '2'])
            self.play(f'scorp_{scorp_var}')
            return None
        return variant

    def play_walk_end(self, entity_type, variant):
        if not variant: return
        if entity_type == 'player':
            self.play(f'exp_end_{variant}')
        elif 'mummy' in entity_type:
            self.play(f'mum_end_{variant}')

music_manager = MusicManager()
sfx_manager = SoundEffectManager()

==============================
PATH: MummyMaze\api\io\Lightning\manager\Spritesheet.py
==============================

import pygame

class Spritesheet:
    def __init__(self, filepath):
        self.sheet = pygame.image.load(filepath).convert_alpha()  # alpha d√πng ƒë·ªÉ x·ª≠ l√Ω v√πng trong su·ªët

    def get_image(self, x, y, width, height):  # (left, top, width, height)
        image = pygame.Surface((width, height), pygame.SRCALPHA)  # flag ƒë·∫£m b·∫£o surface n√†y h·ªó tr·ª£ ƒë·ªô trong su·ªët
        image.blit(self.sheet, (0, 0), (x, y, width, height))
        return image

==============================
PATH: MummyMaze\api\io\Lightning\manager\TextDesigner.py
==============================

import pygame

from api.io.Lightning.utils.ConfigFile import *


class TextDesigner:
    def __init__(self, color=(0, 255, 255), hover_color=(255, 255, 0)):
        self.color = color
        self.hover_color = hover_color

        # Load the original white bitmap (biggestfont)
        self.original_image = pygame.image.load(os.path.join(UI_PATH, 'biggestfont.gif')).convert_alpha()
        self.original_image.set_colorkey((0, 0, 0))

        # Create colored version
        self.image = self.original_image.copy()
        self.image.fill(color, special_flags=pygame.BLEND_MULT)

        # Create hover colored version
        self.hover_image = self.original_image.copy()
        self.hover_image.fill(hover_color, special_flags=pygame.BLEND_MULT)

        self.letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        height = self.image.get_height()

        widths = {
            "A": 16, "B": 14, "C": 11, "D": 15, "E": 12, "F": 11, "G": 15, "H": 15,
            "I": 6, "J": 7, "K": 14, "L": 10, "M": 19, "N": 16, "O": 16, "P": 15,
            "Q": 17, "R": 15, "S": 13, "T": 12, "U": 16, "V": 15, "W": 23, "X": 15,
            "Y": 16, "Z": 12
        }
        spacings = [4, 4, 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 3, 4]

        # Create colored glyphs
        self.glyphs = {}
        x = 0
        for i, ch in enumerate(self.letters):
            w = widths[ch]
            rect = pygame.Rect(x, 0, w, height)
            self.glyphs[ch] = self.image.subsurface(rect).copy()

            if i < len(spacings):
                x += w + spacings[i]
            else:
                x += w

        # Create hover colored glyphs
        self.hover_glyphs = {}
        x = 0
        for i, ch in enumerate(self.letters):
            w = widths[ch]
            rect = pygame.Rect(x, 0, w, height)
            self.hover_glyphs[ch] = self.hover_image.subsurface(rect).copy()

            if i < len(spacings):
                x += w + spacings[i]
            else:
                x += w

        # Create original white glyphs (keep for compatibility)
        self.white_glyphs = {}
        x = 0
        for i, ch in enumerate(self.letters):
            w = widths[ch]
            rect = pygame.Rect(x, 0, w, height)
            self.white_glyphs[ch] = self.original_image.subsurface(rect).copy()

            if i < len(spacings):
                x += w + spacings[i]
            else:
                x += w

        # Support lowercase
        for ch in self.letters:
            self.glyphs[ch.lower()] = self.glyphs[ch]
            self.hover_glyphs[ch.lower()] = self.hover_glyphs[ch]
            self.white_glyphs[ch.lower()] = self.white_glyphs[ch]

        # Initialize PyramidFont glyphs
        self._init_pyramid_font()

        # Initialize DefaultFont glyphs
        self._init_default_font()

    def _init_pyramid_font(self):
        """Initialize PyramidFont (0-9) from pyramidfont.png"""
        self.pyramid_image = pygame.image.load(os.path.join(UI_PATH, 'pyramidfont.png')).convert_alpha()
        self.pyramid_image.set_colorkey((0, 0, 0))

        pyramid_chars = "0123456789"
        height = self.pyramid_image.get_height()

        # Font bitmap is 70x12 with 1px spacing between digits
        pyramid_widths = {
            "0": 6, "1": 5, "2": 6, "3": 6, "4": 6,
            "5": 6, "6": 6, "7": 6, "8": 6, "9": 6
        }

        self.pyramid_glyphs = {}
        x = 0
        source_spacing = 1  # 1 pixel spacing between digits

        for ch in pyramid_chars:
            w = pyramid_widths.get(ch, 6)
            if x + w <= self.pyramid_image.get_width():
                rect = pygame.Rect(x, 0, w, height)
                self.pyramid_glyphs[ch] = self.pyramid_image.subsurface(rect).copy()
            x += w + source_spacing

    def _init_default_font(self):
        """Initialize DefaultFont (A-Z, a-z, 0-9, symbols) from font1.png"""
        self.default_image = pygame.image.load(os.path.join(UI_PATH, 'font1.png')).convert_alpha()
        self.default_image.set_colorkey((0, 0, 0))

        self.default_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`!@#$%&*()+=\\/'\":?-.,"
        height = self.default_image.get_height()

        default_width = 6
        default_widths = {
            # Uppercase
            "I": 4, "M": 8, "W": 8, "L": 5,
            # Lowercase
            "i": 3, "l": 3, "j": 4, "t": 4, "f": 4, "m": 8, "w": 8,
            # Numbers
            "1": 4,
            # Symbols
            "`": 3, "!": 3, "(": 4, ")": 4, ".": 3, ",": 3,
            ":": 3, "'": 3, "\"": 5, "-": 5
        }

        self.default_glyphs = {}
        x = 0
        source_padding = 1

        for ch in self.default_chars:
            w = default_widths.get(ch, default_width)

            if x + w <= self.default_image.get_width():
                rect = pygame.Rect(x, 0, w, height)
                self.default_glyphs[ch] = self.default_image.subsurface(rect).copy()

            x += w + source_padding

    def render(self, text, letter_spacing=2, word_spacing=12, outline=True, outline_thickness=2, hovered=False):
        """Render text using the big font with optional outline and hover effect"""
        text = text.upper()
        height = self.image.get_height()

        # Choose glyphs based on hover state
        glyphs = self.hover_glyphs if hovered else self.glyphs

        # Calculate final surface width
        width = 0
        for ch in text:
            if ch == " ":
                width += word_spacing
            elif ch in glyphs:
                width += glyphs[ch].get_width() + letter_spacing

        width -= letter_spacing

        # Create base surface for the colored text
        base_surf = pygame.Surface((width, height), pygame.SRCALPHA)
        x = 0

        for ch in text:
            if ch == " ":
                x += word_spacing
            elif ch in glyphs:
                glyph = glyphs[ch]
                base_surf.blit(glyph, (x, 0))
                x += glyph.get_width() + letter_spacing

        if not outline:
            return base_surf

        # Create outlined version
        padded_width = width + outline_thickness * 2
        padded_height = height + outline_thickness * 2
        final_surf = pygame.Surface((padded_width, padded_height), pygame.SRCALPHA)

        # Create black version of the text
        black_surf = pygame.Surface((width, height), pygame.SRCALPHA)
        for x in range(width):
            for y in range(height):
                pixel = base_surf.get_at((x, y))
                if pixel.a > 0:
                    black_surf.set_at((x, y), (0, 0, 0, pixel.a))

        # Draw the black outline
        offsets = [
            (-1, -1), (0, -1), (1, -1),
            (-1, 0), (1, 0),
            (-1, 1), (0, 1), (1, 1)
        ]

        for dx, dy in offsets:
            for layer in range(outline_thickness):
                final_surf.blit(black_surf,
                                (outline_thickness + dx * (layer + 1), outline_thickness + dy * (layer + 1)))

        # Draw the colored text on top
        final_surf.blit(base_surf, (outline_thickness, outline_thickness))

        return final_surf

    def render_pyramid(self, text, letter_spacing=1):
        """Render numbers using PyramidFont (no outline, no hover)"""
        text = str(text)
        height = self.pyramid_image.get_height()

        width = 0
        for ch in text:
            if ch in self.pyramid_glyphs:
                width += self.pyramid_glyphs[ch].get_width() + letter_spacing
        width -= letter_spacing
        if width < 0:
            width = 0

        surf = pygame.Surface((width, height), pygame.SRCALPHA)
        x = 0
        for ch in text:
            if ch in self.pyramid_glyphs:
                glyph = self.pyramid_glyphs[ch]
                surf.blit(glyph, (x, 0))
                x += glyph.get_width() + letter_spacing
        return surf

    def render_default(self, text, letter_spacing=1, word_spacing=4):
        """Render text using DefaultFont (no outline, no hover)"""
        height = self.default_image.get_height()

        width = 0
        for ch in text:
            if ch == " ":
                width += word_spacing
            elif ch in self.default_glyphs:
                width += self.default_glyphs[ch].get_width() + letter_spacing
        width -= letter_spacing
        if width < 0:
            width = 0

        surf = pygame.Surface((width, height), pygame.SRCALPHA)
        x = 0
        for ch in text:
            if ch == " ":
                x += word_spacing
            elif ch in self.default_glyphs:
                glyph = self.default_glyphs[ch]
                surf.blit(glyph, (x, 0))
                x += glyph.get_width() + letter_spacing

        return surf


class PyramidFont:
    """
    Handles the number-only font from pyramidfont.png (0-9)
    """

    def __init__(self):
        self.image = pygame.image.load(os.path.join(UI_PATH, 'pyramidfont.png')).convert_alpha()
        self.image.set_colorkey((0, 0, 0))

        self.chars = "0123456789"
        height = self.image.get_height()

        # Font bitmap is 70x12 with 1px spacing between digits
        widths = {
            "0": 6, "1": 5, "2": 6, "3": 6, "4": 6,
            "5": 6, "6": 6, "7": 6, "8": 6, "9": 6
        }

        # Spacing between numbers in the source image strip
        self.source_spacing = 1

        self.glyphs = {}
        x = 0
        for ch in self.chars:
            w = widths.get(ch, 6)
            if x + w <= self.image.get_width():
                rect = pygame.Rect(x, 0, w, height)
                self.glyphs[ch] = self.image.subsurface(rect).copy()
            x += w + self.source_spacing

    def render(self, text, letter_spacing=1):
        text = str(text)  # Ensure input is string
        height = self.image.get_height()

        width = 0
        for ch in text:
            if ch in self.glyphs: width += self.glyphs[ch].get_width() + letter_spacing
        width -= letter_spacing
        if width < 0: width = 0

        surf = pygame.Surface((width, height), pygame.SRCALPHA)
        x = 0
        for ch in text:
            if ch in self.glyphs:
                glyph = self.glyphs[ch]
                surf.blit(glyph, (x, 0))
                x += glyph.get_width() + letter_spacing
        return surf


class DefaultFont:
    r"""
    Handles the small white font from font1.png
    Supports: A-Z, a-z, 0-9, and symbols `!@#$%&*()+=\/'":?-.,
    """

    def __init__(self):
        self.image = pygame.image.load(os.path.join(UI_PATH, 'font1.png')).convert_alpha()
        self.image.set_colorkey((0, 0, 0))

        # The Exact order provided
        # Note: double quotes " and backslashes \ are escaped
        self.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`!@#$%&*()+=\\/'\":?-.,"

        height = self.image.get_height()

        # SETUP WIDTHS
        # Most chars in small pixel fonts are ~6px.
        # Adjust these specific values if your font1.png alignment is slightly off.
        self.default_width = 6

        widths = {
            # Uppercase
            "I": 4, "M": 8, "W": 8, "L": 5,
            # Lowercase
            "i": 3, "l": 3, "j": 4, "t": 4, "f": 4, "m": 8, "w": 8,
            # Numbers
            "1": 4,
            # Symbols
            "`": 3, "!": 3, "(": 4, ")": 4, ".": 3, ",": 3,
            ":": 3, "'": 3, "\"": 5, "-": 5
        }

        self.glyphs = {}
        x = 0
        source_padding = 1  # Gap between letters in the .png file

        for ch in self.chars:
            w = widths.get(ch, self.default_width)

            # Safety check: don't slice past image end
            if x + w <= self.image.get_width():
                rect = pygame.Rect(x, 0, w, height)
                self.glyphs[ch] = self.image.subsurface(rect).copy()

            x += w + source_padding

    def render(self, text, letter_spacing=1, word_spacing=4):
        height = self.image.get_height()

        width = 0
        for ch in text:
            if ch == " ":
                width += word_spacing
            elif ch in self.glyphs:
                width += self.glyphs[ch].get_width() + letter_spacing
        width -= letter_spacing
        if width < 0: width = 0

        surf = pygame.Surface((width, height), pygame.SRCALPHA)
        x = 0
        for ch in text:
            if ch == " ":
                x += word_spacing
            elif ch in self.glyphs:
                glyph = self.glyphs[ch]
                surf.blit(glyph, (x, 0))
                x += glyph.get_width() + letter_spacing

        return surf

==============================
PATH: MummyMaze\api\io\Lightning\manager\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\maze\LevelSelector.py
==============================

class LevelSelector:
    def __init__(self):
        pass

==============================
PATH: MummyMaze\api\io\Lightning\maze\MazeGenerator.py
==============================

import random
from collections import deque
from api.io.Lightning.entities.Enemy import EnemyAI
import api.io.Lightning.utils.ConfigFile as cf


# --- Helper Class for Simulation ---
class SimGate:
    """Mimics the visual Gate object for AI collision checks during generation"""

    def __init__(self, x, y, is_open):
        self.grid_x = x
        self.grid_y = y
        self.open = is_open

    def is_blocking(self):
        return not self.open


class MazeGenerator:
    def __init__(self):
        self.min_loops = 0

    def generate_level(self, difficulty, maze_size=None):
        config = self._get_config(difficulty)

        # --- NEW: allow UI to override size (6/8/10) ---
        if maze_size is not None:
            try:
                ms = int(maze_size)
            except Exception:
                ms = None
            if ms in (6, 8, 10):
                config['size'] = ms
        # ---------------------------------------------

        size = config['size']

        attempts = 0
        max_attempts = getattr(cf, "GEN_MAX_ATTEMPTS", 1000)
        print_every = getattr(cf, "GEN_PRINT_EVERY", 50)

        while attempts < max_attempts:
            attempts += 1
            if attempts % 50 == 0:
                print(f"Gen: Attempt {attempts}...")

            # 1. Structure
            walls_layout = self._generate_layout(size)
            self._braid_maze(walls_layout, size, config['braid_factor'])
            raw_walls = self._get_raw_walls(walls_layout, size)
            pruned_walls = self._smart_prune_walls(raw_walls, size, config['wall_density'])

            # 2. Place Entities
            level_data = self._place_entities(size, pruned_walls, config)
            if not level_data:
                continue

            # 3. Finalize Walls
            level_data['walls'] = self._merge_walls(level_data['walls'])

            # 4. Verify Solvability & Print Debug Solution
            solution_path = self._is_level_solvable(level_data, size)

            if solution_path:
                if getattr(cf, "DEBUG_GEN", False):
                    print(f"Generated clean level in {attempts} attempts.")
                    print(f"\n DEBUG: Solution Path ({len(solution_path)} steps):")
                    print(solution_path)
                    print("-" * 40 + "\n")
                return level_data

        print("Generation failed. Creating Fallback Level.")
        return self._generate_fallback_level(size, difficulty)

    def _get_config(self, difficulty):
        if difficulty == 'easy':
            return {
                'size': 6,
                'min_enemies': 1,
                'max_enemies': 2,
                'enemy_pool': ['white_mummy', 'red_mummy', 'scorpion'],
                'traps': 0,
                'use_key_gate': False,
                'braid_factor': 0.5,
                'wall_density': 0.5,
                'difficulty_str': 'easy'
            }
        elif difficulty == 'hard':
            return {
                'size': 10,
                'min_enemies': 2,
                'max_enemies': 3,
                'enemy_pool': ['white_mummy', 'red_mummy', 'scorpion', 'red_scorpion'],
                'traps': 2,
                'use_key_gate': True,
                'braid_factor': 1.0,
                'wall_density': 0.5,
                'difficulty_str': 'hard'
            }
        else:
            return {
                'size': 8,
                'min_enemies': 2,
                'max_enemies': 3,
                'enemy_pool': ['white_mummy', 'red_mummy', 'scorpion'],
                'traps': 1,
                'use_key_gate': True,
                'braid_factor': 0.7,
                'wall_density': 0.5,
                'difficulty_str': 'medium'
            }

    def _generate_fallback_level(self, size, difficulty):
        walls_layout = self._generate_layout(size)
        self._braid_maze(walls_layout, size, 1.0)
        raw_walls = self._get_raw_walls(walls_layout, size)
        pruned = self._smart_prune_walls(raw_walls, size, 0.2)
        walls = self._merge_walls(pruned)
        player = {'x': 0, 'y': 0, 'direction': 'down'}
        exit_pos = {'x': size - 1, 'y': size - 1}
        walls = [w for w in walls if not (w['x'] == exit_pos['x'] and w['y'] == exit_pos['y'])]
        enemies = []
        if difficulty != 'easy':
            enemies.append({'type': 'white_mummy', 'x': size - 1, 'y': 0})
        return {
            "difficulty": "fallback",
            "mazeType": str(size),
            "maze_size": size,
            "player": player,
            "exit": exit_pos,
            "enemies": enemies,
            "traps": [],
            "walls": walls,
            "key": None,
            "gate": None
        }

    def _place_entities(self, size, walls, config):
        occupied = set()

        # --- EXIT: allow outside-grid for nicer render ---
        side = random.randint(0, 3)
        if side == 0:   # up
            exit_pos = {'x': random.randint(0, size - 1), 'y': -1}
        elif side == 1:  # down
            exit_pos = {'x': random.randint(0, size - 1), 'y': size}
        elif side == 2:  # left
            exit_pos = {'x': -1, 'y': random.randint(0, size - 1)}
        else:           # right
            exit_pos = {'x': size, 'y': random.randint(0, size - 1)}

        win_x, win_y = self._exit_to_win_cell(exit_pos, size)
        occupied.add((win_x, win_y))

        # --- PLAYER ---
        player_pos = None
        for _ in range(50):
            px, py = random.randint(0, size - 1), random.randint(0, size - 1)
            if (px, py) in occupied:
                continue
            dist = self._get_path_distance((px, py), (win_x, win_y), walls, size)
            if dist > size // 2:
                player_pos = {'x': px, 'y': py, 'direction': 'down'}
                occupied.add((px, py))
                break
        if not player_pos:
            return None

        # --- ENEMIES ---
        enemies = []
        min_e = config.get('min_enemies', 1)
        max_e = config.get('max_enemies', 1)
        count = random.randint(min_e, max_e)
        pool = config.get('enemy_pool', ['white_mummy'])

        if pool:
            for _ in range(count):
                e_type = random.choice(pool)
                for _ in range(50):
                    ex, ey = random.randint(0, size - 1), random.randint(0, size - 1)
                    if (ex, ey) in occupied:
                        continue
                    dist = self._get_path_distance((ex, ey), (player_pos['x'], player_pos['y']), walls, size)
                    safe_dist = 6 if config['difficulty_str'] == 'hard' else 4
                    if dist > safe_dist:
                        enemies.append({'type': e_type, 'x': ex, 'y': ey})
                        occupied.add((ex, ey))
                        break

        # --- KEY/GATE (CHOKE-POINT) ---
        key_data = None
        gate_data = None

        if config.get('use_key_gate'):
            start = (player_pos['x'], player_pos['y'])
            target = (win_x, win_y)

            base_path = self._find_path_cells(start, target, walls, size)

            candidates = []
            if base_path and len(base_path) >= 6:
                for i in range(2, len(base_path) - 2):
                    ax, ay = base_path[i - 1]
                    bx, by = base_path[i]
                    if ax == bx and abs(ay - by) == 1:
                        gx = ax
                        gy = max(ay, by)  # boundary between gy-1 <-> gy
                        if 1 <= gy <= size - 1:
                            # Must be an OPEN corridor originally (no wall), otherwise gate is meaningless.
                            if not self._check_wall(ax, ay, bx, by, walls):
                                candidates.append((gx, gy))

            random.shuffle(candidates)

            # Pick a gate that actually disconnects start -> target when CLOSED
            chosen_gate = None
            for gx, gy in candidates:
                reachable_closed = self._reachable_set(start, walls, size, gate_info=(gx, gy), gate_open=False)
                if target not in reachable_closed:
                    chosen_gate = (gx, gy)
                    break

            # Fallback search (still tries to make it a true choke)
            if chosen_gate is None:
                for _ in range(200):
                    gx = random.randint(0, size - 1)
                    gy = random.randint(1, size - 1)
                    # corridor open?
                    if self._check_wall(gx, gy - 1, gx, gy, walls):
                        continue
                    reachable_closed = self._reachable_set(start, walls, size, gate_info=(gx, gy), gate_open=False)
                    if target not in reachable_closed:
                        chosen_gate = (gx, gy)
                        break

            # If we found a valid choke gate: place key in the reachable-before-gate region
            if chosen_gate is not None:
                gx, gy = chosen_gate
                gate_data = {'x': gx, 'y': gy}

                reachable_closed = self._reachable_set(start, walls, size, gate_info=chosen_gate, gate_open=False)

                # Rank key candidates: far from player, not occupied
                dist_map = {}
                queue = deque([(start[0], start[1], 0)])
                visited = {start}
                while queue:
                    cx, cy, d = queue.popleft()
                    dist_map[(cx, cy)] = d
                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nx, ny = cx + dx, cy + dy
                        if not (0 <= nx < size and 0 <= ny < size):
                            continue
                        if (nx, ny) in visited:
                            continue
                        if (nx, ny) not in reachable_closed:
                            continue
                        if self._gate_blocks(cx, cy, nx, ny, chosen_gate, gate_open=False):
                            continue
                        if self._check_wall(cx, cy, nx, ny, walls):
                            continue
                        visited.add((nx, ny))
                        queue.append((nx, ny, d + 1))

                candidates_key = []
                min_key_dist = 3 if config['difficulty_str'] == 'easy' else max(4, size // 2)
                for (kx, ky) in reachable_closed:
                    if (kx, ky) in occupied:
                        continue
                    if (kx, ky) == start or (kx, ky) == target:
                        continue
                    if dist_map.get((kx, ky), 0) >= min_key_dist:
                        candidates_key.append((kx, ky))

                if not candidates_key:
                    candidates_key = [(kx, ky) for (kx, ky) in reachable_closed if (kx, ky) not in occupied]

                if candidates_key:
                    kx, ky = random.choice(candidates_key)
                    key_data = {'x': kx, 'y': ky}
                    occupied.add((kx, ky))
                else:
                    gate_data = None
                    key_data = None

        # --- TRAPS ---
        traps = []
        for _ in range(config.get('traps', 0)):
            for _ in range(20):
                tx, ty = random.randint(0, size - 1), random.randint(0, size - 1)
                if (tx, ty) not in occupied:
                    traps.append({'x': tx, 'y': ty})
                    occupied.add((tx, ty))
                    break

        return {
            "difficulty": config['difficulty_str'],
            "mazeType": str(size),
            "maze_size": size,
            "player": player_pos,
            "exit": exit_pos,
            "enemies": enemies,
            "traps": traps,
            "walls": walls,
            "key": key_data,
            "gate": gate_data
        }

    # =========================
    # Helper methods (in-class)
    # =========================
    def _exit_to_win_cell(self, exit_pos, size):
        """Clamp any exit position (even outside-grid) into the in-grid win cell."""
        if not exit_pos or 'x' not in exit_pos or 'y' not in exit_pos:
            return None, None
        try:
            ex = int(exit_pos['x'])
            ey = int(exit_pos['y'])
        except Exception:
            return None, None
        wx = max(0, min(size - 1, ex))
        wy = max(0, min(size - 1, ey))
        return wx, wy

    def _gate_blocks(self, fx, fy, tx, ty, gate_info, gate_open):
        """Gate blocks ONLY the vertical boundary between (gx, gy-1) <-> (gx, gy) when closed."""
        if not gate_info or gate_open:
            return False
        gx, gy = gate_info
        return (
            (fx == gx and fy == gy - 1 and tx == gx and ty == gy) or
            (fx == gx and fy == gy and tx == gx and ty == gy - 1)
        )

    def _reachable_set(self, start, walls, size, gate_info=None, gate_open=True):
        """Return all grid cells reachable from start with given gate state."""
        sx, sy = start
        visited = {(sx, sy)}
        q = deque([(sx, sy)])
        while q:
            cx, cy = q.popleft()
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = cx + dx, cy + dy
                if not (0 <= nx < size and 0 <= ny < size):
                    continue
                if (nx, ny) in visited:
                    continue
                if self._check_wall(cx, cy, nx, ny, walls):
                    continue
                if self._gate_blocks(cx, cy, nx, ny, gate_info, gate_open):
                    continue
                visited.add((nx, ny))
                q.append((nx, ny))
        return visited

    def _find_path_cells(self, start, end, walls, size):
        """BFS path in grid (ignores gate). Returns list of (x,y) or None."""
        if start == end:
            return [start]
        sx, sy = start
        ex, ey = end
        q = deque([(sx, sy)])
        parent = {start: None}
        while q:
            cx, cy = q.popleft()
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = cx + dx, cy + dy
                if not (0 <= nx < size and 0 <= ny < size):
                    continue
                if (nx, ny) in parent:
                    continue
                if self._check_wall(cx, cy, nx, ny, walls):
                    continue
                parent[(nx, ny)] = (cx, cy)
                if (nx, ny) == (ex, ey):
                    path = []
                    cur = (ex, ey)
                    while cur is not None:
                        path.append(cur)
                        cur = parent[cur]
                    return path[::-1]
                q.append((nx, ny))
        return None

    # =========================
    # Core generation helpers
    # =========================
    def _generate_layout(self, size):
        grid = [[set() for _ in range(size)] for _ in range(size)]
        visited = set()
        stack = [(0, 0)]
        visited.add((0, 0))
        while stack:
            cx, cy = stack[-1]
            neighbors = []
            for dx, dy, d in [(0, -1, 'N'), (0, 1, 'S'), (-1, 0, 'W'), (1, 0, 'E')]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size and (nx, ny) not in visited:
                    neighbors.append((nx, ny, dx, dy, d))
            if neighbors:
                nx, ny, dx, dy, d = random.choice(neighbors)
                if d == 'N':
                    grid[cx][cy].add('N')
                    grid[nx][ny].add('S')
                elif d == 'S':
                    grid[cx][cy].add('S')
                    grid[nx][ny].add('N')
                elif d == 'W':
                    grid[cx][cy].add('W')
                    grid[nx][ny].add('E')
                elif d == 'E':
                    grid[cx][cy].add('E')
                    grid[nx][ny].add('W')
                visited.add((nx, ny))
                stack.append((nx, ny))
            else:
                stack.pop()
        return grid

    def _braid_maze(self, grid, size, factor):
        dead_ends = []
        for x in range(size):
            for y in range(size):
                if len(grid[x][y]) == 1:
                    dead_ends.append((x, y))
        random.shuffle(dead_ends)
        count = int(len(dead_ends) * factor)
        for i in range(count):
            cx, cy = dead_ends[i]
            neighbors = []
            for dx, dy, d, opp in [(0, -1, 'N', 'S'), (0, 1, 'S', 'N'), (-1, 0, 'W', 'E'), (1, 0, 'E', 'W')]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size and d not in grid[cx][cy]:
                    neighbors.append((nx, ny, d, opp))
            if neighbors:
                nx, ny, d, opp = random.choice(neighbors)
                grid[cx][cy].add(d)
                grid[nx][ny].add(opp)

    def _get_raw_walls(self, grid, size):
        walls = []
        for x in range(size):
            for y in range(size):
                if 'N' not in grid[x][y]:
                    walls.append({'x': x, 'y': y, 'dir': 'horizontal'})
                if 'W' not in grid[x][y]:
                    walls.append({'x': x, 'y': y, 'dir': 'vertical'})
        return walls

    def _smart_prune_walls(self, walls, size, target_density):
        max_walls = int((size * size) * target_density)
        if len(walls) <= max_walls:
            return walls
        walls_copy = walls.copy()
        random.shuffle(walls_copy)
        removed = 0
        target = len(walls) - max_walls
        for wall in walls_copy:
            if removed >= target:
                break
            test = [w for w in walls if w != wall]
            if self._is_maze_connected(test, size):
                walls.remove(wall)
                removed += 1
        return walls

    def _is_maze_connected(self, walls, size):
        visited = set()
        queue = deque([(0, 0)])
        visited.add((0, 0))
        while queue:
            x, y = queue.popleft()
            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
                nx, ny = x + dx, y + dy
                if not (0 <= nx < size and 0 <= ny < size):
                    continue
                if (nx, ny) in visited:
                    continue
                if self._check_wall(x, y, nx, ny, walls):
                    continue
                visited.add((nx, ny))
                queue.append((nx, ny))
        return len(visited) == size * size

    def _merge_walls(self, walls):
        merged = {}
        for w in walls:
            key = (w['x'], w['y'])
            if key not in merged:
                merged[key] = w['dir']
            else:
                merged[key] = 'both'
        return [{'x': x, 'y': y, 'dir': d} for (x, y), d in merged.items()]

    def _get_path_distance(self, start, end, walls, size):
        queue = deque([(start[0], start[1], 0)])
        visited = set([(start[0], start[1])])
        while queue:
            cx, cy, dist = queue.popleft()
            if cx == end[0] and cy == end[1]:
                return dist
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size:
                    if (nx, ny) not in visited:
                        if not self._check_wall(cx, cy, nx, ny, walls):
                            visited.add((nx, ny))
                            queue.append((nx, ny, dist + 1))
        return -1

    def _check_wall(self, x1, y1, x2, y2, walls):
        if x2 > x1:
            for w in walls:
                if w['x'] == x2 and w['y'] == y2 and w['dir'] in ['vertical', 'both']:
                    return True
        elif x2 < x1:
            for w in walls:
                if w['x'] == x1 and w['y'] == y1 and w['dir'] in ['vertical', 'both']:
                    return True
        elif y2 > y1:
            for w in walls:
                if w['x'] == x2 and w['y'] == y2 and w['dir'] in ['horizontal', 'both']:
                    return True
        elif y2 < y1:
            for w in walls:
                if w['x'] == x1 and w['y'] == y1 and w['dir'] in ['horizontal', 'both']:
                    return True
        return False

    def _is_level_solvable(self, level_data, size):
        # Normalize target to win-cell (exit may be outside grid)
        try:
            start = (int(level_data['player']['x']), int(level_data['player']['y']))
        except Exception:
            return None

        wx, wy = self._exit_to_win_cell(level_data.get('exit'), size)
        if wx is None:
            return None
        target = (wx, wy)

        # Handle missing key/gate safely
        key_pos = None
        if level_data.get('key') and 'x' in level_data['key'] and 'y' in level_data['key']:
            try:
                key_pos = (int(level_data['key']['x']), int(level_data['key']['y']))
            except Exception:
                key_pos = None

        gate_info = None
        if level_data.get('gate') and 'x' in level_data['gate'] and 'y' in level_data['gate']:
            try:
                gate_info = (int(level_data['gate']['x']), int(level_data['gate']['y']))
            except Exception:
                gate_info = None
        
        trap_cells = set()
        for t in (level_data.get('traps') or []):
            try:
                trap_cells.add((int(t['x']), int(t['y'])))
            except Exception:
                pass

        if start in trap_cells or target in trap_cells:
            return None

        ai = EnemyAI(size, level_data['walls'], gate=None)
        init_enemies = tuple((e['x'], e['y']) for e in level_data['enemies'])

        # One-way semantics: if no gate -> treat as open. If gate exists -> starts closed until key collected.
        gate_open_init = (gate_info is None)

        start_state = (start[0], start[1], gate_open_init, init_enemies)
        queue = deque([start_state])
        visited = {start_state}

        parent_map = {start_state: None}

        steps = 0
        max_steps = 5000

        while queue:
            steps += 1
            if steps > max_steps:
                return None

            current_state = queue.popleft()
            px, py, gate_open, e_positions = current_state

            # Target reached: reconstruct path
            if (px, py) == target:
                path = []
                trace = current_state
                while trace is not None:
                    path.append((trace[0], trace[1]))
                    trace = parent_map[trace]
                return path[::-1]

            for dx, dy in [(0, 0), (0, -1), (0, 1), (-1, 0), (1, 0)]:
                nx, ny = px + dx, py + dy
                if not (0 <= nx < size and 0 <= ny < size):
                    continue
                    # Skip trap tiles ‚Äî player cannot step on traps
                if (nx, ny) in trap_cells:
                    continue
                if self._check_wall(px, py, nx, ny, level_data['walls']):
                    continue
                if (nx, ny) in e_positions:
                    continue

                # Gate blocks only when present AND closed
                if gate_info and not gate_open:
                    gx, gy = gate_info
                    if px == gx and py == gy - 1 and nx == gx and ny == gy:
                        continue
                    if px == gx and py == gy and nx == gx and ny == gy - 1:
                        continue

                # One-way open: once True, always True
                next_gate_open = gate_open
                if (not gate_open) and key_pos and (nx, ny) == key_pos:
                    next_gate_open = True

                ai.gate = SimGate(gate_info[0], gate_info[1], next_gate_open) if gate_info else None

                next_e_positions = []
                player_died = False
                for i, pos in enumerate(e_positions):
                    enemy = {'type': level_data['enemies'][i]['type'], 'pos': [pos[0], pos[1]]}
                    path = ai.get_move_path(enemy, [nx, ny], difficulty=level_data['difficulty'])
                    new_pos = path[-1] if path else enemy['pos']

                    if path:
                        for step in path:
                            if step[0] == nx and step[1] == ny:
                                player_died = True
                    if new_pos[0] == nx and new_pos[1] == ny:
                        player_died = True

                    next_e_positions.append(tuple(new_pos))

                if player_died:
                    continue

                new_state = (nx, ny, next_gate_open, tuple(next_e_positions))
                if new_state not in visited:
                    visited.add(new_state)
                    parent_map[new_state] = current_state
                    queue.append(new_state)

        return None


==============================
PATH: MummyMaze\api\io\Lightning\maze\MazeLoader.py
==============================

import os
import json
import pygame
import random
import math
from collections import deque

from api.io.Lightning.manager.SoundReader import sfx_manager
from api.io.Lightning.manager.Spritesheet import Spritesheet
from api.io.Lightning.maze.MazeGenerator import MazeGenerator
from api.io.Lightning.utils.ConfigFile import LEVELS_PATH, UI_PATH, OBJECTS_PATH, maze_coord_x, maze_coord_y
from api.io.Lightning.objects.Key import Key
from api.io.Lightning.objects.Gate import Gate
from api.io.Lightning.objects.Trap import Trap
from api.io.Lightning.entities.Enemy import Enemy


class FightEffect:
    def __init__(self, x, y, dust_frames, star_img, cell_size):
        self.x = x
        self.y = y
        self.cell_size = cell_size
        self.dust_frames = dust_frames
        self.frame_index = 0
        self.anim_speed = 0.45
        self.star_img = star_img
        self.stars = []
        if self.star_img:
            center = cell_size // 2
            for i in range(5):
                angle = random.uniform(0, 2 * math.pi)
                speed = random.uniform(1.5, 3.5)
                vx = math.cos(angle) * speed
                vy = math.sin(angle) * speed - 1
                self.stars.append({
                    'x': center, 'y': center, 'vx': vx, 'vy': vy,
                    'visible': False, 'spawn_frame': random.randint(1, 3)
                })
        self.finished = False

    def update(self):
        self.frame_index += self.anim_speed
        current_frame = int(self.frame_index)
        for star in self.stars:
            if current_frame >= star['spawn_frame']:
                star['visible'] = True
                star['x'] += star['vx']
                star['y'] += star['vy']
                star['vx'] *= 0.95
                star['vy'] *= 0.95
        if self.frame_index >= len(self.dust_frames) + 3:
            self.finished = True

    def draw(self, surface):
        if self.finished:
            return
        idx = int(self.frame_index)
        if idx < len(self.dust_frames):
            img = self.dust_frames[idx]
            draw_x = maze_coord_x + self.x * self.cell_size + (self.cell_size - img.get_width()) // 2
            draw_y = maze_coord_y + self.y * self.cell_size + (self.cell_size - img.get_height()) // 2
            surface.blit(img, (draw_x, draw_y))
        if self.star_img:
            base_x = maze_coord_x + self.x * self.cell_size
            base_y = maze_coord_y + self.y * self.cell_size
            for star in self.stars:
                if star['visible']:
                    draw_sx = base_x + int(star['x']) - (self.star_img.get_width() // 2)
                    draw_sy = base_y + int(star['y']) - (self.star_img.get_height() // 2)
                    surface.blit(self.star_img, (draw_sx, draw_sy))


class MazeLoader:
    def __init__(self, level_id=None, difficulty='medium', generate_infinite=False, maze_size=None):
        self.level_id = level_id

        if generate_infinite:
            print(f"üé≤ Generating procedural level... (size={maze_size}, diff={difficulty})")
            generator = MazeGenerator()
            self.data = generator.generate_level(difficulty, maze_size)
            self.parsed = self._parse_level_data(self.data)
        else:
            self.data = self._load_level()
            self.parsed = self._parse_level_from_json()

        self.maze_pixel_size = 360
        # Sau khi parsed xong:
        self.difficulty = difficulty or self.parsed.get("difficulty", "medium")
        self.parsed["difficulty"] = self.difficulty
        self.maze_size = self.parsed["maze_size"]
        self.stair_pos = self.parsed["exit"]
        self.cell_size = self.maze_pixel_size // self.maze_size

        self.backdrop_img = None
        self.floor_img = None
        self.wall_sprites = {}
        self.stair_sprites = {}
        self.arrow_sprites = []
        self.circle_img = None

        self.dust_frames = []
        self.star_img = None
        self.active_effects = []

        self.traps = []
        self.key_obj = None
        self.gate_obj = None
        self.enemies_list = []
        self.enemies_on_key = set()

        # --- NEW: Turn Timing Variables ---
        self.last_turn_time = 0
        # ----------------------------------

        self.history_stack = []
        self.pending_deaths = []
        self.turn_queue = deque()

        self.ankh_frames = []
        self.is_current_state_solvable = True
        self.generator_instance = MazeGenerator()
        self.ankh_timer = 0

        # --- NEW: Solvability caching/throttling (avoid heavy sim every time) ---
        # Key: (player_x, player_y, gate_open, enemies_tuple)
        # Value: bool solvable
        self._solv_cache = {}
        self._solv_last_key = None
        self._solv_last_check_ms = 0
        self._solv_cache_max = 256
        self._solv_throttle_ms = 120
        # ----------------------------------------------------------------------

        self._load_assets()
        self._create_objects()

    def _load_level(self):
        filepath = os.path.join(LEVELS_PATH, f'level_{self.level_id}.json')
        if not os.path.exists(filepath):
            return None
        with open(filepath, 'r') as f:
            data = json.load(f)
        return data

    def _parse_level_from_json(self):
        return self._parse_level_data(self.data)

    def _parse_level_data(self, data):
        if not data:
            return None
        key_data = data.get('key')
        key = {'x': key_data['x'], 'y': key_data['y']} if key_data and 'x' in key_data else None
        gate_data = data.get('gate')
        gate = {'x': gate_data['x'], 'y': gate_data['y']} if gate_data and 'x' in gate_data else None
        return {
            'difficulty': data.get('difficulty', 'medium'),
            'maze_size': int(data['mazeType']),
            'player': data['player'],
            'exit': data['exit'],
            'enemies': data.get('enemies', []),
            'key': key,
            'gate': gate,
            'traps': data.get('traps', []),
            'walls': data.get('walls', [])
        }

    def reset(self):
        self._create_objects()
        self.active_effects = []
        self.pending_deaths = []
        self.turn_queue.clear()

        # --- FIX: Reset Ankh state to Solvable (Gold) ---
        self.is_current_state_solvable = True
        self.history_stack.clear()
        # ------------------------------------------------

    # --- NEW: Save State (Snapshot) ---
    def save_state(self, player):
        state = {
            'player': {'x': player.x, 'y': player.y, 'dir': player.direction},
            # We only save if the Gate is Open (True) or Closed (False)
            'gate_open': not self.gate_obj.is_blocking() if self.gate_obj else True,
            # 'key_active' removed because Key is stateless
            'solvable': self.is_current_state_solvable,
            'enemies': [{'type': e.type, 'x': e.x, 'y': e.y, 'dir': e.direction} for e in self.enemies_list if
                        not e.is_dead]
        }
        self.history_stack.append(state)

    # --- NEW: Undo Logic ---
    def undo_last_move(self, player):
        if not self.history_stack:
            return False
        state = self.history_stack.pop()

        # Restore Player
        player.x = state['player']['x']
        player.y = state['player']['y']
        player.direction = state['player']['dir']
        player.target_x = player.x * player.tile_size
        player.target_y = player.y * player.tile_size
        player.pixel_x = player.target_x
        player.pixel_y = player.target_y
        player.is_moving = False

        # Restore Objects
        if self.gate_obj:
            # Directly set the state constant, bypassing animation
            if state['gate_open']:
                self.gate_obj.state = self.gate_obj.STATE_OPEN
            else:
                self.gate_obj.state = self.gate_obj.STATE_CLOSED

        # Key restoration removed (stateless)

        self.is_current_state_solvable = state['solvable']

        # Restore Enemies (Recreate to ensure clean state)
        self.enemies_list.clear()
        self.enemies_on_key.clear()
        for e_data in state['enemies']:
            new_enemy = Enemy(e_data['x'], e_data['y'], e_data['type'], self.maze_size, self.cell_size, self.parsed['walls'], self.gate_obj)
            new_enemy.direction = e_data['dir']
            new_enemy.pixel_x = new_enemy.x * self.cell_size
            new_enemy.pixel_y = new_enemy.y * self.cell_size
            new_enemy.target_x = new_enemy.pixel_x
            new_enemy.target_y = new_enemy.pixel_y
            self.enemies_list.append(new_enemy)

        # Clear queues/effects
        self.turn_queue.clear()
        self.pending_deaths.clear()
        self.active_effects.clear()
        return True

    def _create_objects(self):
        self.key_obj = None
        self.gate_obj = None
        self.enemies_on_key.clear()
        if self.parsed['key']:
            k = self.parsed['key']
            self.key_obj = Key(k['x'], k['y'], self.cell_size, self.maze_size)
        if self.parsed['gate']:
            g = self.parsed['gate']
            self.gate_obj = Gate(g['x'], g['y'], self.cell_size, self.maze_size)
        self.traps = []
        for t in self.parsed['traps']:
            self.traps.append(Trap(t['x'], t['y'], self.cell_size, self.maze_size))

        self.enemies_list = []
        for e_data in self.parsed['enemies']:
            new_enemy = Enemy(
                x=e_data['x'],
                y=e_data['y'],
                enemy_type=e_data['type'],
                maze_size=self.maze_size,
                tile_size=self.cell_size,
                walls=self.parsed['walls'],
                gate=self.gate_obj
            )
            self.enemies_list.append(new_enemy)

    def _load_assets(self):
        self.backdrop_img = pygame.image.load(os.path.join(UI_PATH, 'backdrop.jpg'))
        self.floor_img = pygame.image.load(os.path.join(OBJECTS_PATH, f'floor{self.maze_size}.jpg'))
        wall_sheet = Spritesheet(os.path.join(OBJECTS_PATH, f'walls{self.maze_size}.gif'))
        match self.maze_size:
            case 6:
                self.wall_sprites['horizontal'] = wall_sheet.get_image(12, 0, 72, 18)
                self.wall_sprites['vertical'] = wall_sheet.get_image(0, 0, 12, 78)
            case 8:
                self.wall_sprites['horizontal'] = wall_sheet.get_image(12, 0, 57, 18)
                self.wall_sprites['vertical'] = wall_sheet.get_image(0, 0, 12, 63)
            case 10:
                self.wall_sprites['horizontal'] = wall_sheet.get_image(8, 0, 44, 12)
                self.wall_sprites['vertical'] = wall_sheet.get_image(0, 0, 8, 48)
        stair_sheet = Spritesheet(os.path.join(OBJECTS_PATH, f"stairs{self.maze_size}.gif"))
        sw = stair_sheet.sheet.get_width() // 4
        sh = stair_sheet.sheet.get_height()
        self.stair_sprites['up'] = stair_sheet.get_image(0, 0, sw, sh)
        self.stair_sprites['right'] = stair_sheet.get_image(sw, 0, sw, sh)
        self.stair_sprites['down'] = stair_sheet.get_image(2 * sw, 0, sw, sh)
        self.stair_sprites['left'] = stair_sheet.get_image(3 * sw, 0, sw, sh)
        try:
            self.circle_img = pygame.image.load(os.path.join(UI_PATH, f'circle{self.maze_size}.png')).convert_alpha()
            arrow_sheet = pygame.image.load(os.path.join(UI_PATH, f'arrows{self.maze_size}.png')).convert_alpha()
            aw = arrow_sheet.get_width()
            ah = arrow_sheet.get_height() // 4
            self.arrow_sprites = [
                arrow_sheet.subsurface((0, 0, aw, ah)),
                arrow_sheet.subsurface((0, 2 * ah, aw, ah)),
                arrow_sheet.subsurface((0, ah, aw, ah)),
                arrow_sheet.subsurface((0, 3 * ah, aw, ah))
            ]
        except Exception:
            pass
        try:
            ankh_sheet = pygame.image.load(os.path.join(UI_PATH, 'ankh.png')).convert_alpha()
            sheet_w, sheet_h = ankh_sheet.get_size()
            frame_h = sheet_h // 4
            for i in range(4):
                self.ankh_frames.append(ankh_sheet.subsurface((0, i * frame_h, sheet_w, frame_h)))
        except Exception as e:
            print(f"Ankh load error: {e}")
        try:
            self.star_img = pygame.image.load(os.path.join(UI_PATH, 'star.png')).convert_alpha()
            dust_filename = f'dust{self.maze_size}.png'
            dust_path = os.path.join(UI_PATH, dust_filename)
            if not os.path.exists(dust_path):
                dust_path = os.path.join(UI_PATH, 'dust6.png')
            if os.path.exists(dust_path):
                dust_sheet = pygame.image.load(dust_path).convert_alpha()
                sheet_w, sheet_h = dust_sheet.get_size()
                frame_size = sheet_h
                cols = sheet_w // frame_size
                for i in range(cols):
                    frame = dust_sheet.subsurface((i * frame_size, 0, frame_size, frame_size))
                    self.dust_frames.append(frame)
        except Exception as e:
            print(f"Effect Load Error: {e}")

    def check_solvability(self, player):
        if not player:
            return

        # --- NEW: Throttle repeated calls ---
        now_ms = pygame.time.get_ticks()
        if now_ms - self._solv_last_check_ms < self._solv_throttle_ms:
            return
        self._solv_last_check_ms = now_ms
        # -----------------------------------

        # Detect state change for Ankh Sound
        was_solvable = self.is_current_state_solvable

        current_enemies = []
        for e in self.enemies_list:
            if not e.is_dead:
                current_enemies.append({'type': e.type, 'x': e.x, 'y': e.y})

        gate_open = True
        if self.gate_obj:
            gate_open = (not self.gate_obj.is_blocking())

        enemies_sig = tuple((e['type'], int(e['x']), int(e['y'])) for e in current_enemies)
        cache_key = (int(player.x), int(player.y), bool(gate_open), enemies_sig)

        cached = self._solv_cache.get(cache_key)
        if cached is None:
            gate_snapshot = None
            key_snapshot = None
            if self.gate_obj and self.gate_obj.is_blocking():
                gate_snapshot = {'x': self.gate_obj.grid_x, 'y': self.gate_obj.grid_y}
                if self.key_obj:
                    key_snapshot = {'x': self.key_obj.grid_x, 'y': self.key_obj.grid_y}

            win = self.get_win_cell()
            exit_snapshot = {'x': win[0], 'y': win[1]} if win else self.parsed['exit']

            snapshot_data = {
                'player': {'x': player.x, 'y': player.y},
                'exit': exit_snapshot,
                'enemies': current_enemies,
                'walls': self.parsed['walls'],
                'traps': [{'x': t.grid_x, 'y': t.grid_y} for t in self.traps],
                'gate': gate_snapshot,
                'key': key_snapshot,
                'difficulty': self.difficulty
            }

            result = self.generator_instance._is_level_solvable(snapshot_data, self.maze_size)
            cached = (result is not None)

            if len(self._solv_cache) >= self._solv_cache_max:
                self._solv_cache.pop(next(iter(self._solv_cache)))
            self._solv_cache[cache_key] = cached

        self.is_current_state_solvable = bool(cached)
        self._solv_last_key = cache_key

        if was_solvable and not self.is_current_state_solvable:
            sfx_manager.play('badankh')

    def draw_ankh(self, surface):
        if not self.ankh_frames:
            return
        base_idx = 0 if self.is_current_state_solvable else 2
        glow_idx = base_idx + 1

        # --- FIX: Position hardcoded as requested ---
        x, y = 90, 320
        # --------------------------------------------

        if base_idx < len(self.ankh_frames):
            surface.blit(self.ankh_frames[base_idx], (x, y))
        self.ankh_timer += 0.08
        pulse = (math.sin(self.ankh_timer) + 1) / 2
        alpha = int(pulse * 255)
        if glow_idx < len(self.ankh_frames):
            glow_surf = self.ankh_frames[glow_idx].copy()
            glow_surf.set_alpha(alpha)
            surface.blit(glow_surf, (x, y))

    def spawn_fight_cloud(self, x, y):
        if self.dust_frames:
            effect = FightEffect(x, y, self.dust_frames, self.star_img, self.cell_size)
            self.active_effects.append(effect)

    def init_enemy_turn_sequence(self):
        order = {'scorpion': 0, 'red_scorpion': 1, 'white_mummy': 2, 'red_mummy': 3}
        active = [e for e in self.enemies_list if not e.is_dead]
        active.sort(key=lambda e: order.get(e.type, 99))
        self.turn_queue = deque(active)
        self.last_turn_time = 0  # Reset timer

    def update_turn_sequence(self, player_pos):
        if any(e.paused for e in self.enemies_list):
            return False

        # --- NEW: Non-Blocking Delay Logic ---
        if self.are_enemies_moving():
            self.last_turn_time = pygame.time.get_ticks()  # Reset timer while any enemy is moving
            return False

        if self.pending_deaths:
            return False

        # Wait 150ms after the last move finished before starting next
        if pygame.time.get_ticks() - self.last_turn_time < 50:
            return False
        # -------------------------------------

        if not self.turn_queue:
            return True

        next_enemy = self.turn_queue[0]
        if next_enemy.is_dead or next_enemy not in self.enemies_list:
            self.turn_queue.popleft()
            return self.update_turn_sequence(player_pos)

        self.turn_queue.popleft()
        next_enemy.move_logic([player_pos[0], player_pos[1]], self.difficulty)

        if not next_enemy.move_queue:
            return self.update_turn_sequence(player_pos)
        return False

    def trigger_enemy_afk(self):
        for enemy in self.enemies_list:
            enemy.trigger_afk()

    def are_enemies_moving(self):
        for enemy in self.enemies_list:
            if enemy.is_moving or len(enemy.move_queue) > 0:
                return True
        return False

    def pause_enemies(self):
        for enemy in self.enemies_list:
            enemy.paused = True

    def resume_enemies(self):
        for enemy in self.enemies_list:
            enemy.paused = False

    def resolve_enemy_collisions(self):
        pos_map = {}
        for enemy in self.enemies_list:
            if enemy.state.name == "DIE":
                continue
            pos = (enemy.x, enemy.y)
            if pos not in pos_map:
                pos_map[pos] = []
            pos_map[pos].append(enemy)

        collision_occurred = False

        for pos, enemies in pos_map.items():
            if len(enemies) > 1:
                sfx_manager.play('pummel')
                self.spawn_fight_cloud(pos[0], pos[1])
                enemies.sort(key=lambda e: e.strength, reverse=True)
                victims = enemies[1:]
                self.pending_deaths.extend(victims)
                collision_occurred = True

        return collision_occurred

    def process_pending_deaths(self):
        for v in self.pending_deaths:
            v.trigger_die(instant=True)
        self.pending_deaths.clear()

    def update(self):
        if self.key_obj:
            self.key_obj.update()
        if self.gate_obj:
            self.gate_obj.update()
        for trap in self.traps:
            trap.update()
        for enemy in self.enemies_list:
            enemy.update()

        self.enemies_list = [e for e in self.enemies_list if not e.is_dead]

        for eff in self.active_effects:
            eff.update()
        self.active_effects = [e for e in self.active_effects if not e.finished]

        if self.key_obj and self.gate_obj:
            kx, ky = self.key_obj.grid_x, self.key_obj.grid_y
            for enemy in self.enemies_list:
                if enemy.x == kx and enemy.y == ky:
                    if enemy not in self.enemies_on_key:
                        # ‚úÖ PopCap-style: ch·∫°m key/switch -> m·ªü gate v√† gi·ªØ m·ªü
                        if self.gate_obj.is_blocking():
                            self.gate_obj.open()
                            sfx_manager.play('gate')
                        self.key_obj.activate()
                        self.enemies_on_key.add(enemy)
                else:
                    if enemy in self.enemies_on_key:
                        self.enemies_on_key.remove(enemy)

    def draw_background(self, surface):
        surface.blit(self.backdrop_img, (0, 0))
        surface.blit(self.floor_img, (maze_coord_x, maze_coord_y))

    def _get_active_indicator(self, mouse_pos, player):
        if not player or not self.circle_img or not mouse_pos:
            return None
        if not player.is_ready():
            return None
        mx, my = mouse_pos
        grid_x = (mx - maze_coord_x) // self.cell_size
        grid_y = (my - maze_coord_y) // self.cell_size
        if not (0 <= grid_x < self.maze_size and 0 <= grid_y < self.maze_size):
            return None
        if grid_x == player.x and grid_y == player.y:
            return {'type': 'circle', 'img': self.circle_img, 'x': grid_x, 'y': grid_y}
        dx, dy = grid_x - player.x, grid_y - player.y
        if abs(dx) + abs(dy) == 1:
            for enemy in self.enemies_list:
                if enemy.x == grid_x and enemy.y == grid_y:
                    return None
            if player.check_eligible_move(grid_x, grid_y, self.maze_size, self.parsed['walls'], self.gate_obj):
                arrow_idx = 0
                if dx == 1:
                    arrow_idx = 2
                elif dx == -1:
                    arrow_idx = 1
                elif dy == 1:
                    arrow_idx = 0
                elif dy == -1:
                    arrow_idx = 3
                if 0 <= arrow_idx < len(self.arrow_sprites):
                    return {'type': 'arrow', 'img': self.arrow_sprites[arrow_idx], 'x': grid_x, 'y': grid_y}
        return None

    def draw(self, surface, player=None, enemies=None, mouse_pos=None):
        indicator = self._get_active_indicator(mouse_pos, player)
        self.draw_stairs(surface)
        for trap in self.traps:
            trap.draw(surface)
        walls = self.parsed['walls']
        current_enemies = enemies if enemies is not None else self.enemies_list
        draw_priority = {'scorpion': 0, 'red_scorpion': 1, 'player': 2, 'white_mummy': 3, 'red_mummy': 4}
        for row in range(self.maze_size + 1):
            if self.gate_obj and self.gate_obj.grid_y == row:
                self.gate_obj.draw(surface)
            self._draw_walls_for_row(surface, walls, row)
            if self.key_obj and self.key_obj.grid_y == row:
                self.key_obj.draw(surface)
            if indicator and indicator['y'] == row:
                img = indicator['img']
                draw_x = maze_coord_x + indicator['x'] * self.cell_size + (self.cell_size - img.get_width()) // 2
                draw_y = maze_coord_y + indicator['y'] * self.cell_size + (self.cell_size - img.get_height()) // 2
                surface.blit(img, (draw_x, draw_y))
            row_entities = []
            if player and player.y == row:
                row_entities.append({'type': 'player', 'obj': player})
            for enemy in current_enemies:
                if enemy.y == row:
                    row_entities.append({'type': enemy.type, 'obj': enemy})
            row_entities.sort(key=lambda item: draw_priority.get(item['type'], 0))
            for item in row_entities:
                item['obj'].draw(surface)
            for eff in self.active_effects:
                if eff.y == row:
                    eff.draw(surface)

    def _draw_walls_for_row(self, surface, walls, row):
        for data in walls:
            if data['y'] != row:
                continue
            wall_x, direction = data['x'], data['dir']
            if wall_x < 0 or wall_x > self.maze_size - 1:
                continue
            if row < 0 or row > self.maze_size - 1:
                continue
            base_x = maze_coord_x + wall_x * self.cell_size
            base_y = maze_coord_y + row * self.cell_size
            offset_x = int(self.cell_size * 0.08)
            offset_y = int(self.cell_size * 0.27)
            draw_x = base_x - offset_x
            draw_y = base_y - offset_y
            if direction == 'both':
                if row > 0:
                    surface.blit(self.wall_sprites['horizontal'], (draw_x, draw_y))
                if wall_x > 0:
                    surface.blit(self.wall_sprites['vertical'], (draw_x, draw_y))
            elif direction == 'horizontal':
                if row > 0:
                    surface.blit(self.wall_sprites['horizontal'], (draw_x, draw_y))
            elif direction == 'vertical':
                if wall_x > 0:
                    surface.blit(self.wall_sprites['vertical'], (draw_x, draw_y))

    def _get_exit_draw_mode(self):
        """
        Quy·∫øt ƒë·ªãnh c√°ch v·∫Ω stairs:
        - N·∫øu exit ·ªü bi√™n (ho·∫∑c n·∫±m ngo√†i grid): v·∫Ω stairs ·ªü NGO√ÄI bi√™n theo h∆∞·ªõng.
        - N·∫øu exit n·∫±m trong grid nh∆∞ng KH√îNG ·ªü bi√™n: v·∫Ω stairs NGAY TRONG √¥ ƒë√≥
        (tr√°nh t√¨nh tr·∫°ng hi·ªÉn th·ªã sai g√¢y hi·ªÉu nh·∫ßm ‚Äúwin nh·∫ßm‚Äù).
        """
        ex = self.stair_pos
        if not ex or 'x' not in ex or 'y' not in ex:
            return None

        try:
            gx = int(ex['x'])
            gy = int(ex['y'])
        except Exception:
            return None

        ms = self.maze_size
        win = self.get_win_cell()
        if not win:
            return None
        wx, wy = win

        # Exit n·∫±m ngo√†i grid: x√°c ƒë·ªãnh h∆∞·ªõng theo ph·∫ßn b·ªã out-of-bound
        if gx < 0:
            return ("left_out", wx, wy)
        if gx >= ms:
            return ("right_out", wx, wy)
        if gy < 0:
            return ("up_out", wx, wy)
        if gy >= ms:
            return ("down_out", wx, wy)

        # Exit n·∫±m trong grid:
        # N·∫øu ·ªü bi√™n th√¨ v·∫Ω OUT ƒë√∫ng h∆∞·ªõng bi√™n
        if gx == 0:
            return ("left_out", wx, wy)
        if gx == ms - 1:
            return ("right_out", wx, wy)
        if gy == 0:
            return ("up_out", wx, wy)
        if gy == ms - 1:
            return ("down_out", wx, wy)

        # N·∫øu n·∫±m ‚Äúgi·ªØa map‚Äù -> v·∫Ω ngay trong √¥ (ƒë·ªÉ hi·ªÉn th·ªã kh·ªõp logic win)
        return ("cell_in", wx, wy)

    def get_win_cell(self):
        """
        Tr·∫£ v·ªÅ √¥ trong grid m√† player ph·∫£i ƒë·ª©ng l√™n ƒë·ªÉ win.
        H·ªó tr·ª£ 2 ki·ªÉu exit:
        - exit n·∫±m ngo√†i grid (x=-1/x=maze_size/y=-1/y=maze_size): win ·ªü √¥ bi√™n g·∫ßn nh·∫•t.
        - exit n·∫±m trong grid: win ƒë√∫ng √¥ ƒë√≥.
        """
        ex = self.stair_pos
        if not ex or 'x' not in ex or 'y' not in ex:
            return None
        try:
            gx = int(ex['x'])
            gy = int(ex['y'])
        except Exception:
            return None

        ms = self.maze_size
        win_x = 0 if gx < 0 else (ms - 1 if gx >= ms else gx)
        win_y = 0 if gy < 0 else (ms - 1 if gy >= ms else gy)
        return (win_x, win_y)

    def draw_stairs(self, surface):
        if not self.stair_pos:
            return

        spec = self._get_exit_draw_mode()
        if not spec:
            return

        mode, gx, gy = spec

        # Ch·ªçn sprite theo h∆∞·ªõng (d√πng l·∫°i ƒë√∫ng sprite b·∫°n ƒë√£ load)
        if mode == "left_out":
            stair_img = self.stair_sprites.get('left')
            if not stair_img:
                return
            draw_x = maze_coord_x - stair_img.get_width()
            draw_y = maze_coord_y + gy * self.cell_size + (self.cell_size - stair_img.get_height()) // 2
            surface.blit(stair_img, (draw_x, draw_y))
            return

        if mode == "right_out":
            stair_img = self.stair_sprites.get('right')
            if not stair_img:
                return
            draw_x = maze_coord_x + self.maze_size * self.cell_size
            draw_y = maze_coord_y + gy * self.cell_size + (self.cell_size - stair_img.get_height()) // 2
            surface.blit(stair_img, (draw_x, draw_y))
            return

        if mode == "up_out":
            stair_img = self.stair_sprites.get('up')
            if not stair_img:
                return
            draw_x = maze_coord_x + gx * self.cell_size + (self.cell_size - stair_img.get_width()) // 2
            draw_y = maze_coord_y - stair_img.get_height()
            surface.blit(stair_img, (draw_x, draw_y))
            return

        if mode == "down_out":
            stair_img = self.stair_sprites.get('down')
            if not stair_img:
                return
            draw_x = maze_coord_x + gx * self.cell_size + (self.cell_size - stair_img.get_width()) // 2
            draw_y = maze_coord_y + self.maze_size * self.cell_size
            surface.blit(stair_img, (draw_x, draw_y))
            return

        # mode == "cell_in": v·∫Ω stairs n·∫±m TRONG √¥ exit (fix hi·ªÉn th·ªã sai)
        stair_img = self.stair_sprites.get('down')  # ch·ªçn 1 sprite ·ªïn ƒë·ªãnh ƒë·ªÉ ƒë·∫∑t trong √¥
        if not stair_img:
            return
        draw_x = maze_coord_x + gx * self.cell_size + (self.cell_size - stair_img.get_width()) // 2
        draw_y = maze_coord_y + gy * self.cell_size + (self.cell_size - stair_img.get_height()) // 2
        surface.blit(stair_img, (draw_x, draw_y))

    def check_trap_collision(self, x, y):
        for t in self.traps:
            if t.check_collision(x, y):
                if not t.is_triggered:
                    t.trigger()
                return True
        return False

    def check_key_collision(self, x, y):
        if self.key_obj and self.key_obj.check_collision(x, y):
            self.key_obj.activate()
            if self.gate_obj and self.gate_obj.is_blocking():
                self.gate_obj.open()
                sfx_manager.play('gate')
            return True
        return False

    def is_gate_blocking(self, fx, fy, tx, ty):
        if not self.gate_obj or not self.gate_obj.is_blocking():
            return False
        gx, gy = self.gate_obj.grid_x, self.gate_obj.grid_y
        if fx == gx and fy == gy - 1 and tx == gx and ty == gy:
            return True
        if fx == gx and fy == gy and tx == gx and ty == gy - 1:
            return True
        return False

    def face_enemies_to_player(self, player):
        for enemy in self.enemies_list:
            if not enemy.is_moving and not enemy.is_dead and enemy.state.name != 'DIE':
                enemy.face_target(player.x, player.y)


==============================
PATH: MummyMaze\api\io\Lightning\maze\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\objects\Gate.py
==============================

import os
import pygame

from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH, maze_coord_x, maze_coord_y

class Gate:
    STATE_OPEN = 'open'
    STATE_CLOSED = 'closed'

    STATE_OPENING = 'opening'
    STATE_CLOSING = 'closing'

    def __init__(self, x, y, cell_size, maze_size):
        self.grid_x = x
        self.grid_y = y
        self.cell_size = cell_size
        self.maze_size = maze_size

        self.frames = []
        self.current_frame = 0
        self.state = self.STATE_CLOSED
        self.animation_speed = 0.2  # Speed of opening/closing animation
        self.animation_counter = 0

        self._load_frames()

    def _load_frames(self):
        """Load gate animation frames"""
        try:
            gate_strip = pygame.image.load(os.path.join(OBJECTS_PATH, f'gate{self.maze_size}.gif')).convert_alpha()

            # Get sheet dimensions
            sheet_width = gate_strip.get_width() // 8
            sheet_height = gate_strip.get_height()

            # Extract frames
            for i in range(8):
                frame = pygame.Surface((sheet_width, sheet_height), pygame.SRCALPHA)
                frame.blit(gate_strip, (0, 0), (i * sheet_width, 0, sheet_width, sheet_height))
                self.frames.append(frame)

            print(f"‚úÖ Loaded {len(self.frames)} gate animation frames")

        except Exception as e:
            print(f"‚ùå Error loading gate frames: {e}")
            # Create dummy frames (closed -> open)
            for i in range(8):
                dummy = pygame.Surface((self.cell_size, 10), pygame.SRCALPHA)
                alpha = 255 - (i * 32)  # Fade out
                dummy.fill((100, 100, 100))
                dummy.set_alpha(alpha)
                self.frames.append(dummy)

    def update(self):
        """Update gate animation"""
        if self.state == self.STATE_CLOSED or self.state == self.STATE_OPEN:
            return

        self.animation_counter += self.animation_speed

        if self.animation_counter >= 1.0:
            self.animation_counter = 0

            if self.state == self.STATE_OPENING:
                self.current_frame += 1
                if self.current_frame >= len(self.frames) - 1:
                    self.current_frame = len(self.frames) - 1
                    self.state = self.STATE_OPEN

            elif self.state == self.STATE_CLOSING:
                self.current_frame -= 1
                if self.current_frame <= 0:
                    self.current_frame = 0
                    self.state = self.STATE_CLOSED

    def draw(self, surface):
        """Draw gate at its position (horizontal - top edge of cell)"""
        # FIXED: Removed the check that hid the gate when STATE_OPEN
        if not self.frames:
            return

        frame = self.frames[self.current_frame]

        # Position gate exactly like a horizontal wall
        # This matches the wall positioning logic in MazeLoader.draw_walls
        base_x = maze_coord_x + self.grid_x * self.cell_size
        base_y = maze_coord_y + self.grid_y * self.cell_size

        # Use same offsets as horizontal walls (scaled by cell size)
        offset_x = int(self.cell_size * 0.08)  # ~5 pixels for size 60
        offset_y = int(self.cell_size * 0.27)  # ~16 pixels for size 60

        gate_x = base_x - offset_x
        gate_y = base_y - offset_y

        surface.blit(frame, (gate_x, gate_y))

    def toggle(self):
        """Toggle gate state (open <-> close)"""
        if self.state == self.STATE_CLOSED:
            self.state = self.STATE_OPENING
        elif self.state == self.STATE_OPEN:
            self.state = self.STATE_CLOSING

    def open(self):
        """Open the gate"""
        if self.state == self.STATE_CLOSED:
            self.state = self.STATE_OPENING

    def close(self):
        """Close the gate"""
        if self.state == self.STATE_OPEN:
            self.state = self.STATE_CLOSING

    def is_blocking(self):
        """Check if gate is blocking movement"""
        # It blocks if it is closed OR currently closing
        return self.state == self.STATE_CLOSED or self.state == self.STATE_CLOSING

    def is_open(self):
        """Check if gate is fully open"""
        return self.state == self.STATE_OPEN

==============================
PATH: MummyMaze\api\io\Lightning\objects\Key.py
==============================

import os
import pygame

from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH, maze_coord_x, maze_coord_y

class Key:
    def __init__(self, x, y, cell_size, maze_size):
        self.grid_x = x
        self.grid_y = y
        self.cell_size = cell_size
        self.maze_size = maze_size

        self.frames = []
        self.frame_index = 0
        self.animation_speed = 0.25
        self.animation_counter = 0
        self.collected = False

        self._load_frames()

    def _load_frames(self):
        """Load key animation frames from sprite strip"""
        try:
            key_strip = pygame.image.load(os.path.join(OBJECTS_PATH, f'key.png')).convert_alpha()

            # Get sheet dimensions
            sheet_width = key_strip.get_width()
            sheet_height = key_strip.get_height()

            # Calculate frame dimensions (assuming square frames in horizontal strip)
            frame_height = sheet_height
            frame_width = frame_height  # Square frames
            total_frames = sheet_width // frame_width

            # Extract frames
            for i in range(total_frames):
                frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
                frame.blit(key_strip, (0, 0), (i * frame_width, 0, frame_width, frame_height))
                self.frames.append(frame)

            print(f"‚úÖ Loaded {len(self.frames)} key animation frames")

        except Exception as e:
            print(f"‚ùå C√≥ l·ªói x·∫£y ra khi kh·ªüi ch·∫°y Key: {e}")
            # Create dummy frame
            dummy = pygame.Surface((self.cell_size // 2, self.cell_size // 2), pygame.SRCALPHA)
            dummy.fill((255, 215, 0))  # Gold color
            self.frames = [dummy]

    def update(self):
        """Update animation"""
        self.animation_counter += self.animation_speed

        if self.animation_counter >= 1.0:
            self.animation_counter = 0
            self.frame_index = (self.frame_index + 1) % len(self.frames)

    def draw(self, surface):
        """Draw key at its position"""
        if not self.frames:
            return

        frame = self.frames[self.frame_index]

        # Calculate screen position (centered in cell)
        draw_x = maze_coord_x + self.grid_x * self.cell_size + (self.cell_size - frame.get_width()) // 2
        draw_y = maze_coord_y + self.grid_y * self.cell_size + (self.cell_size - frame.get_height()) // 2 - 6

        surface.blit(frame, (draw_x, draw_y))

    def activate(self):
        """Activate key (for toggling gate) - key stays on map"""
        pass  # Key doesn't get collected, just triggers gate

    def check_collision(self, entity_x, entity_y):
        """Check if entity is at key position"""
        return entity_x == self.grid_x and entity_y == self.grid_y

==============================
PATH: MummyMaze\api\io\Lightning\objects\Trap.py
==============================

import os
import pygame

from api.io.Lightning.manager.Spritesheet import Spritesheet
from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH, maze_coord_x, maze_coord_y

class Trap:
    def __init__(self, x, y, cell_size, maze_size):
        self.grid_x = x
        self.grid_y = y
        self.cell_size = cell_size
        self.maze_size = maze_size

        # Animation state
        self.is_triggered = False
        self.frames = []
        self.animation_frame = 0
        self.animation_speed = 0.15  # Speed of eye sparkle animation
        self.animation_timer = 0

        # Load sprites
        self._load_sprites()

    def _load_sprites(self):
        """Load trap base and sparkle animation"""
        # Load base trap image
        self.trap_base = pygame.image.load(
            os.path.join(OBJECTS_PATH, f'trap{self.maze_size}.png')
        )

        # Load sparkle animation spritesheet
        sparkle_sheet = Spritesheet(
            os.path.join(OBJECTS_PATH, f'trapsparkle{self.maze_size}.png')
        )

        sheet_width = sparkle_sheet.sheet.get_width() // 14
        sheet_height = sparkle_sheet.sheet.get_height()

        for i in range(14):
            frame = sparkle_sheet.get_image(
                i * sheet_width, 0, sheet_width, sheet_height
            )
            self.frames.append(frame)

    def update(self):
        if not self.is_triggered:
            # Animate eye sparkle continuously
            self.animation_timer += self.animation_speed
            if self.animation_timer >= 1:
                self.animation_timer = 0
                self.animation_frame = (self.animation_frame + 1) % len(self.frames)

    def trigger(self):
        """Trigger the trap (called when player steps on it)"""
        self.is_triggered = True
        # You can add sound effects or other trigger logic here
        print(f"üíÄ Trap triggered at ({self.grid_x}, {self.grid_y})!")

    def check_collision(self, entity_x, entity_y):
        """Check if entity is on trap position"""
        return entity_x == self.grid_x and entity_y == self.grid_y

    def draw(self, surface):
        # Calculate pixel coordinates of the grid cell
        pixel_x = maze_coord_x + self.grid_x * self.cell_size
        pixel_y = maze_coord_y + self.grid_y * self.cell_size

        # 1. Draw base trap (centered in the cell)
        trap_x = pixel_x + (self.cell_size - self.trap_base.get_width()) // 2
        trap_y = pixel_y + (self.cell_size - self.trap_base.get_height()) // 2
        surface.blit(self.trap_base, (trap_x, trap_y))

        # 2. Draw glowing eyes if not triggered
        if not self.is_triggered and len(self.frames) > 0:
            sparkle = self.frames[self.animation_frame]
            s_w = sparkle.get_width()
            s_h = sparkle.get_height()

            # Calculate the absolute center of the tile
            center_x = pixel_x + self.cell_size // 2
            center_y = pixel_y + self.cell_size // 2

            # --- OFFSET SETTINGS ---
            # Adjust these numbers if the eyes are too far apart or too low
            eye_offset_x = int(self.cell_size * 0.13)  # Distance from center to eye
            eye_offset_y = int(self.cell_size * 0.04)  # Height adjustment (upwards)

            # Left Eye Position
            left_x = center_x - eye_offset_x - (s_w // 2)
            left_y = center_y - eye_offset_y - (s_h // 2)

            # Right Eye Position
            right_x = center_x + eye_offset_x - (s_w // 2)
            right_y = center_y - eye_offset_y - (s_h // 2)

            # Draw the sparkles
            # (Optional: Use special_flags=pygame.BLEND_ADD for a glowing light effect)
            surface.blit(sparkle, (left_x, left_y))
            surface.blit(sparkle, (right_x, right_y))

==============================
PATH: MummyMaze\api\io\Lightning\objects\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\stat\PlayerStat.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\stat\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\utils\ConfigFile.py
==============================

import pygame
import os

# Thi·∫øt l·∫≠p v·ªã tr√≠ th∆∞ m·ª•c ch√≠nh
PROJECT_PATH = os.path.abspath(os.path.join(
    os.path.dirname(__file__), "../../../..")
)

# Thi·∫øt l·∫≠p v·ªã tr√≠ th∆∞ m·ª•c api, dist, resources
API_PATH = os.path.join(PROJECT_PATH, "api")
DIST_PATH = os.path.join(PROJECT_PATH, "dist")
RESOURCE_PATH = os.path.join(PROJECT_PATH, "resources")

# Thi·∫øt l·∫≠p v·ªã tr√≠ d·ªØ li·ªáu
LEVELS_PATH = os.path.join(DIST_PATH, "levels")

# Thi·∫øt l·∫≠p v·ªã tr√≠ c√°c t√†i nguy√™n
ENTITIES_PATH = os.path.join(RESOURCE_PATH, "entities")
OBJECTS_PATH = os.path.join(RESOURCE_PATH, "objects")
UI_PATH = os.path.join(RESOURCE_PATH, "ui")
SOUNDS_PATH = os.path.join(RESOURCE_PATH, "sounds")
MUSIC_PATH = os.path.join(RESOURCE_PATH, "music")

# Thi·∫øt l·∫≠p cho tr√≤ ch∆°i
maze_coord_x = 213
maze_coord_y = 80
fps = 60

==============================
PATH: MummyMaze\api\io\Lightning\utils\GameType.py
==============================

from enum import Enum

class EnemyType(Enum):
    WHITE_MUMMY = "white_mummy"      # Horizontal priority, 2 moves
    RED_MUMMY = "red_mummy"          # Vertical priority, 2 moves
    SCORPION = "scorpion"            # Random/patrol, 1 move
    RED_SCORPION = "red_scorpion"    # Smart, 1 move

class Difficulty(Enum):
    EASY = "easy"
    NORMAL = "normal"
    HARD = "hard"

class GameMode(Enum):
    CLASSIC = "classic"
    ADVENTURE = "adventure"
    TUTORIAL = "tutorial"


==============================
PATH: MummyMaze\api\io\Lightning\utils\__init__.py
==============================



==============================
PATH: MummyMaze\dist\main.py
==============================

import os
import sys
import pygame
import json
from pathlib import Path
import MummyMaze.api.io.Lightning.utils.ConfigFile as cf
# d√πng: cf.UI_PATH, cf.PROJECT_PATH, cf.LEVELS_PATH...

# === Th√™m project root (MummyMaze) v√†o sys.path ƒë·ªÉ import ƒë∆∞·ª£c 'api' ===
ROOT_DIR = Path(__file__).resolve().parent.parent  # .../MummyMaze
if str(ROOT_DIR) not in sys.path:
    sys.path.insert(0, str(ROOT_DIR))

from MummyMaze.api.io.Lightning.gui.GameUI import (
    initialize_ui,
    draw_screen,
    handle_game_input,
    get_hover_state,
    get_clicked_state,
)

STATE_MENU = "MENU"
STATE_RANDOM_CFG   = "RANDOM_CFG"
STATE_CAMPAIGN_SEL = "CAMPAIGN_SEL"
STATE_GAME = "GAME"
STATE_WIN  = "WIN"
STATE_LOSE = "LOSE"

ctx = {
    "mode": "random",     # "random" | "campaign"
    "level_id": 1,        # cho campaign (placeholder)
    "size": 8,            # cho random size (placeholder)
    "difficulty": "medium"
}

def _scan_campaign_levels():
    """Tr·∫£ v·ªÅ list level_id c√≥ file level_X.json trong cf.LEVELS_PATH"""
    ids = []
    try:
        for name in os.listdir(cf.LEVELS_PATH):
            if name.startswith("level_") and name.endswith(".json"):
                mid = name[len("level_"):-len(".json")]
                if mid.isdigit():
                    ids.append(int(mid))
    except Exception:
        return [1]
    ids.sort()
    return ids if ids else [1]

def _level_exists(level_id: int) -> bool:
    return os.path.exists(os.path.join(cf.LEVELS_PATH, f"level_{level_id}.json"))

def _draw_text(screen, text, x, y, font, color=(255,255,255)):
    surf = font.render(text, True, color)
    rect = surf.get_rect(topleft=(x, y))
    screen.blit(surf, rect)
    return rect

def _button(screen, rect: pygame.Rect, label: str, font, mouse_pos, clicked):
    # hover effect nh·∫π
    hovered = rect.collidepoint(mouse_pos)
    border = (220, 220, 220) if hovered else (140, 140, 140)
    fill   = (60, 60, 60) if hovered else (40, 40, 40)

    pygame.draw.rect(screen, fill, rect, border_radius=10)
    pygame.draw.rect(screen, border, rect, width=2, border_radius=10)

    # center text
    text_surf = font.render(label, True, (255,255,255))
    text_rect = text_surf.get_rect(center=rect.center)
    screen.blit(text_surf, text_rect)

    return hovered and clicked

def build_game_session(ctx):
    # truy·ªÅn l·ª±a ch·ªçn t·ª´ menu v√†o gameplay
    initialize_ui(
        mode=ctx["mode"],
        level_id=ctx["level_id"],
        size=ctx["size"],
        difficulty=ctx["difficulty"],
    )

def random_config_screen(screen, font, mouse_pos, clicked):
    screen.fill((15, 15, 20))
    _draw_text(screen, "RANDOM - CONFIG", 40, 30, font)

    # Size buttons
    _draw_text(screen, "Choose size:", 40, 90, font)
    btn_6  = pygame.Rect(40, 130, 120, 50)
    btn_8  = pygame.Rect(170, 130, 120, 50)
    btn_10 = pygame.Rect(300, 130, 120, 50)

    # Difficulty buttons
    _draw_text(screen, "Difficulty:", 40, 200, font)
    btn_e = pygame.Rect(40, 240, 120, 50)
    btn_m = pygame.Rect(170, 240, 120, 50)
    btn_h = pygame.Rect(300, 240, 120, 50)

    # Start / Back
    btn_start = pygame.Rect(40, 330, 260, 55)
    btn_back  = pygame.Rect(320, 330, 160, 55)

    # --- size select ---
    if _button(screen, btn_6,  "6x6",  font, mouse_pos, clicked):
        ctx["size"] = 6
    if _button(screen, btn_8,  "8x8",  font, mouse_pos, clicked):
        ctx["size"] = 8
    if _button(screen, btn_10, "10x10", font, mouse_pos, clicked):
        ctx["size"] = 10

    # --- diff select ---
    if _button(screen, btn_e, "easy", font, mouse_pos, clicked):
        ctx["difficulty"] = "easy"
    if _button(screen, btn_m, "medium", font, mouse_pos, clicked):
        ctx["difficulty"] = "medium"
    if _button(screen, btn_h, "hard", font, mouse_pos, clicked):
        ctx["difficulty"] = "hard"

    # show current selection
    _draw_text(screen, f"Selected: size={ctx['size']}  diff={ctx['difficulty']}", 40, 410, font)

    if _button(screen, btn_start, "START", font, mouse_pos, clicked):
        ctx["mode"] = "random"
        build_game_session(ctx)
        return STATE_GAME

    if _button(screen, btn_back, "BACK", font, mouse_pos, clicked):
        return STATE_MENU

    return STATE_RANDOM_CFG

def campaign_select_screen(screen, font, mouse_pos, clicked):
    screen.fill((15, 15, 20))
    _draw_text(screen, "CAMPAIGN - SELECT LEVEL", 40, 30, font)

    levels = _scan_campaign_levels()
    _draw_text(screen, "Choose level:", 40, 90, font)

    # V·∫Ω t·ªëi ƒëa 6 level buttons (ƒë·ªß cho demo)
    start_x, start_y = 40, 130
    bw, bh, gap = 120, 50, 15

    chosen = ctx.get("level_id", levels[0])

    for i, lid in enumerate(levels[:6]):
        r = pygame.Rect(start_x + (i % 3) * (bw + gap), start_y + (i // 3) * (bh + gap), bw, bh)
        label = f"Lv {lid}"
        if lid == chosen:
            label = f"> {label} <"
        if _button(screen, r, label, font, mouse_pos, clicked):
            ctx["level_id"] = lid

    _draw_text(screen, "Difficulty:", 40, 260, font)
    btn_e = pygame.Rect(40, 300, 120, 50)
    btn_m = pygame.Rect(170, 300, 120, 50)
    btn_h = pygame.Rect(300, 300, 120, 50)

    if _button(screen, btn_e, "easy", font, mouse_pos, clicked):
        ctx["difficulty"] = "easy"
    if _button(screen, btn_m, "medium", font, mouse_pos, clicked):
        ctx["difficulty"] = "medium"
    if _button(screen, btn_h, "hard", font, mouse_pos, clicked):
        ctx["difficulty"] = "hard"

    btn_start = pygame.Rect(40, 380, 260, 55)
    btn_back  = pygame.Rect(320, 380, 160, 55)

    _draw_text(screen, f"Selected: level={ctx['level_id']}  diff={ctx['difficulty']}", 40, 440, font)

    if _button(screen, btn_start, "START", font, mouse_pos, clicked):
        ctx["mode"] = "campaign"
        build_game_session(ctx)
        return STATE_GAME

    if _button(screen, btn_back, "BACK", font, mouse_pos, clicked):
        return STATE_MENU

    return STATE_CAMPAIGN_SEL


def menu_screen(screen, font, mouse_pos, clicked):
    screen.fill((15, 15, 20))
    _draw_text(screen, "MUMMY MAZE - MENU", 40, 30, font)

    btn_random = pygame.Rect(40, 120, 260, 55)
    btn_campaign = pygame.Rect(40, 190, 260, 55)
    btn_quit = pygame.Rect(40, 260, 260, 55)

    if _button(screen, btn_random, "Play Random", font, mouse_pos, clicked):
        ctx["mode"] = "random"
        return STATE_RANDOM_CFG


    if _button(screen, btn_campaign, "Campaign", font, mouse_pos, clicked):
        ctx["mode"] = "campaign"
        return STATE_CAMPAIGN_SEL

    if _button(screen, btn_quit, "Quit", font, mouse_pos, clicked):
        return "__QUIT__"

    return STATE_MENU


def lose_screen(screen, font, mouse_pos, clicked):
    screen.fill((25, 10, 10))
    _draw_text(screen, "YOU LOSE!", 40, 30, font)

    btn_retry = pygame.Rect(40, 120, 260, 55)
    btn_menu  = pygame.Rect(40, 190, 260, 55)
    btn_quit  = pygame.Rect(40, 260, 260, 55)

    if _button(screen, btn_retry, "Retry", font, mouse_pos, clicked):
        build_game_session(ctx)
        return STATE_GAME

    if _button(screen, btn_menu, "Back to Menu", font, mouse_pos, clicked):
        return STATE_MENU

    if _button(screen, btn_quit, "Quit", font, mouse_pos, clicked):
        return "__QUIT__"

    return STATE_LOSE


def win_screen(screen, font, mouse_pos, clicked):
    screen.fill((10, 25, 10))
    _draw_text(screen, "YOU WIN!", 40, 30, font)

    btn_primary = pygame.Rect(40, 120, 260, 55)
    btn_menu    = pygame.Rect(40, 190, 260, 55)
    btn_quit    = pygame.Rect(40, 260, 260, 55)

    if ctx.get("mode") == "campaign":
        primary_label = "Next Level"
        if _button(screen, btn_primary, primary_label, font, mouse_pos, clicked):
            nxt = ctx.get("level_id", 1) + 1
            if _level_exists(nxt):
                ctx["level_id"] = nxt
                build_game_session(ctx)
                return STATE_GAME
            else:
                # h·∫øt level -> v·ªÅ menu
                return STATE_MENU
    else:
        primary_label = "Play Again"
        if _button(screen, btn_primary, primary_label, font, mouse_pos, clicked):
            build_game_session(ctx)
            return STATE_GAME

    if _button(screen, btn_menu, "Back to Menu", font, mouse_pos, clicked):
        return STATE_MENU

    if _button(screen, btn_quit, "Quit", font, mouse_pos, clicked):
        return "__QUIT__"

    return STATE_WIN

def main():
    pygame.init()

    # QUAN TR·ªåNG: set_mode tr∆∞·ªõc r·ªìi m·ªõi initialize_ui()
    screen = pygame.display.set_mode((640, 480))
    clock = pygame.time.Clock()

    pygame.display.set_caption("Mummy Maze Ultimate 1.0")
    icon = pygame.image.load(os.path.join(cf.UI_PATH, "game.ico"))
    pygame.display.set_icon(icon)

    font = pygame.font.SysFont(None, 36)
    state = STATE_MENU

    running = True
    while running:
        mouse_pos = pygame.mouse.get_pos()

        # click "1 l·∫ßn trong frame" ƒë·ªÉ b·∫•m n√∫t menu/win/lose cho d·ªÖ
        clicked_frame = False

        # --- Event loop ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                break

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                clicked_frame = True

            # Ch·ªâ g·ª≠i input v√†o gameplay khi ƒëang ·ªü GAME
            if state == STATE_GAME:
                result = handle_game_input(event, mouse_pos)
                if result == "lose":
                    state = STATE_LOSE
                elif result == "win":
                    state = STATE_WIN
                elif result == "menu":
                    state = STATE_MENU

        if not running:
            break

        # --- Render theo state ---
        if state == STATE_MENU:
            nxt = menu_screen(screen, font, mouse_pos, clicked_frame)
            if nxt == "__QUIT__":
                running = False
            else:
                state = nxt
                
        elif state == STATE_RANDOM_CFG:
            nxt = random_config_screen(screen, font, mouse_pos, clicked_frame)
            state = nxt

        elif state == STATE_CAMPAIGN_SEL:
            nxt = campaign_select_screen(screen, font, mouse_pos, clicked_frame)
            state = nxt

        elif state == STATE_GAME:
            hovered = get_hover_state(mouse_pos)
            clicked = get_clicked_state()
            result = draw_screen(screen, hovered, clicked)

            if result == "lose":
                state = STATE_LOSE
            elif result == "win":
                state = STATE_WIN

        elif state == STATE_LOSE:
            nxt = lose_screen(screen, font, mouse_pos, clicked_frame)
            if nxt == "__QUIT__":
                running = False
            else:
                state = nxt

        elif state == STATE_WIN:
            nxt = win_screen(screen, font, mouse_pos, clicked_frame)
            if nxt == "__QUIT__":
                running = False
            else:
                state = nxt

        pygame.display.flip()
        clock.tick(cf.fps)

    pygame.quit()
    
if __name__ == "__main__":
    main()


==============================
PATH: MummyMaze\dist\__init__.py
==============================



==============================
PATH: MummyMaze\dist\levels\level_1.json
==============================

{
  "difficulty": "easy",
  "mazeType": "6",
  "player": {"x": 0, "y": 0, "direction": "right"},
  "exit": {"x": 5, "y": 2},
  "enemies": [
    {"type": "white_mummy", "x": 2, "y": 4}
  ],
  "key": {},
  "gate": {},
  "traps": [],
  "walls": [
    {"x": 1, "y": 2, "dir": "vertical"},
    {"x": 1, "y": 4, "dir": "horizontal"},
    {"x": 2, "y": 1, "dir": "horizontal"},
    {"x": 2, "y": 4, "dir": "vertical"},
    {"x": 3, "y": 1, "dir": "vertical"},
    {"x": 4, "y": 2, "dir": "both"},
    {"x": 5, "y": 4, "dir": "both"}
  ]
}

==============================
PATH: MummyMaze\dist\levels\level_2.json
==============================

{
  "difficulty": "normal",
  "mazeType": "8",
  "player": {"x": 7, "y": 0, "direction": "down"},
  "exit": {"x": 0, "y": 7},
  "enemies": [
    {"type": "white_mummy", "x": 4, "y": 0},
    {"type": "white_mummy", "x": 0, "y": 5},
    {"type": "scorpion", "x": 1, "y": 7}
  ],
  "key": {"x": 0, "y": 2},
  "gate": {"x": 6, "y": 1},
  "traps": [
    {"x": 6, "y": 4}
  ],
  "walls": [
    {"x": 0, "y": 3, "dir": "horizontal"},
    {"x": 1, "y": 2, "dir": "horizontal"},
    {"x": 1, "y": 3, "dir": "horizontal"},
    {"x": 1, "y": 4, "dir": "horizontal"},
    {"x": 1, "y": 5, "dir": "both"},
    {"x": 1, "y": 6, "dir": "vertical"},
    {"x": 2, "y": 3, "dir": "both"},
    {"x": 2, "y": 4, "dir": "vertical"},
    {"x": 2, "y": 5, "dir": "vertical"},
    {"x": 3, "y": 4, "dir": "vertical"},
    {"x": 3, "y": 7, "dir": "horizontal"},
    {"x": 4, "y": 1, "dir": "both"},
    {"x": 4, "y": 2, "dir": "horizontal"},
    {"x": 4, "y": 4, "dir": "horizontal"},
    {"x": 4, "y": 7, "dir": "vertical"},
    {"x": 5, "y": 1, "dir": "horizontal"},
    {"x": 5, "y": 3, "dir": "horizontal"},
    {"x": 5, "y": 7, "dir": "horizontal"},
    {"x": 6, "y": 2, "dir": "vertical"},
    {"x": 6, "y": 3, "dir": "horizontal"},
    {"x": 6, "y": 4, "dir": "both"},
    {"x": 6, "y": 6, "dir": "horizontal"},
    {"x": 7, "y": 2, "dir": "horizontal"},
    {"x": 7, "y": 4, "dir": "vertical"}
  ]
}

==============================
PATH: MummyMaze\dist\levels\level_3.json
==============================

{
"difficulty": "hard",
"mazeType": "8",
"maze_size": 8,
"player": {
    "x": 6,
    "y": 5,
    "direction": "down"
},
"exit": {
    "x": 4,
    "y": 0
},
"enemies": [
    {
    "type": "scorpion",
    "x": 5,
    "y": 4
    },
    {
    "type": "red_scorpion",
    "x": 0,
    "y": 6
    }
],
"traps": [
    {
    "x": 0,
    "y": 0
    },
    {
    "x": 7,
    "y": 0
    }
],
"walls": [
    { "x": 0, "y": 0, "dir": "horizontal" },
    { "x": 2, "y": 0, "dir": "horizontal" },
    { "x": 4, "y": 0, "dir": "horizontal" },
    { "x": 5, "y": 0, "dir": "horizontal" },
    { "x": 6, "y": 0, "dir": "horizontal" },
    { "x": 7, "y": 0, "dir": "horizontal" },

    { "x": 1, "y": 1, "dir": "horizontal" },
    { "x": 2, "y": 1, "dir": "horizontal" },
    { "x": 3, "y": 1, "dir": "horizontal" },
    { "x": 4, "y": 1, "dir": "horizontal" },
    { "x": 6, "y": 1, "dir": "horizontal" },
    { "x": 7, "y": 1, "dir": "horizontal" },

    { "x": 0, "y": 2, "dir": "horizontal" },
    { "x": 1, "y": 2, "dir": "horizontal" },
    { "x": 2, "y": 2, "dir": "horizontal" },
    { "x": 3, "y": 2, "dir": "horizontal" },
    { "x": 4, "y": 2, "dir": "horizontal" },
    { "x": 5, "y": 2, "dir": "horizontal" },
    { "x": 7, "y": 2, "dir": "horizontal" },

    { "x": 0, "y": 3, "dir": "horizontal" },
    { "x": 1, "y": 3, "dir": "horizontal" },
    { "x": 4, "y": 3, "dir": "horizontal" },
    { "x": 5, "y": 3, "dir": "horizontal" },
    { "x": 6, "y": 3, "dir": "horizontal" },

    { "x": 0, "y": 4, "dir": "horizontal" },
    { "x": 1, "y": 4, "dir": "horizontal" },
    { "x": 3, "y": 4, "dir": "horizontal" },
    { "x": 4, "y": 4, "dir": "horizontal" },
    { "x": 6, "y": 4, "dir": "horizontal" },
    { "x": 7, "y": 4, "dir": "horizontal" },

    { "x": 0, "y": 5, "dir": "horizontal" },
    { "x": 2, "y": 5, "dir": "horizontal" },
    { "x": 4, "y": 5, "dir": "horizontal" },
    { "x": 5, "y": 5, "dir": "horizontal" },
    { "x": 6, "y": 5, "dir": "horizontal" },
    { "x": 7, "y": 5, "dir": "horizontal" },

    { "x": 0, "y": 6, "dir": "horizontal" },
    { "x": 1, "y": 6, "dir": "horizontal" },
    { "x": 2, "y": 6, "dir": "horizontal" },
    { "x": 4, "y": 6, "dir": "horizontal" },
    { "x": 5, "y": 6, "dir": "horizontal" },
    { "x": 7, "y": 6, "dir": "horizontal" },

    { "x": 0, "y": 7, "dir": "horizontal" },
    { "x": 1, "y": 7, "dir": "horizontal" },
    { "x": 2, "y": 7, "dir": "horizontal" },
    { "x": 3, "y": 7, "dir": "horizontal" },
    { "x": 4, "y": 7, "dir": "horizontal" },
    { "x": 5, "y": 7, "dir": "horizontal" },
    { "x": 6, "y": 7, "dir": "horizontal" },
    { "x": 7, "y": 7, "dir": "horizontal" },

    { "x": 0, "y": 0, "dir": "vertical" },
    { "x": 1, "y": 0, "dir": "vertical" },
    { "x": 2, "y": 0, "dir": "vertical" },
    { "x": 3, "y": 0, "dir": "vertical" },
    { "x": 4, "y": 0, "dir": "vertical" },
    { "x": 5, "y": 0, "dir": "vertical" },
    { "x": 6, "y": 0, "dir": "vertical" },
    { "x": 7, "y": 0, "dir": "vertical" },

    { "x": 2, "y": 1, "dir": "vertical" },
    { "x": 3, "y": 1, "dir": "vertical" },
    { "x": 5, "y": 1, "dir": "vertical" },
    { "x": 6, "y": 1, "dir": "vertical" },
    { "x": 7, "y": 1, "dir": "vertical" },

    { "x": 1, "y": 2, "dir": "vertical" },
    { "x": 2, "y": 2, "dir": "vertical" },
    { "x": 3, "y": 2, "dir": "vertical" },
    { "x": 4, "y": 2, "dir": "vertical" },
    { "x": 5, "y": 2, "dir": "vertical" },
    { "x": 7, "y": 2, "dir": "vertical" },

    { "x": 1, "y": 3, "dir": "vertical" },
    { "x": 2, "y": 3, "dir": "vertical" },
    { "x": 3, "y": 3, "dir": "vertical" },
    { "x": 4, "y": 3, "dir": "vertical" },
    { "x": 6, "y": 3, "dir": "vertical" },
    { "x": 7, "y": 3, "dir": "vertical" },

    { "x": 2, "y": 4, "dir": "vertical" },
    { "x": 3, "y": 4, "dir": "vertical" },
    { "x": 5, "y": 4, "dir": "vertical" },

    { "x": 1, "y": 5, "dir": "vertical" },
    { "x": 2, "y": 5, "dir": "vertical" },
    { "x": 3, "y": 5, "dir": "vertical" },
    { "x": 4, "y": 5, "dir": "vertical" },
    { "x": 5, "y": 5, "dir": "vertical" },
    { "x": 6, "y": 5, "dir": "vertical" },
    { "x": 7, "y": 5, "dir": "vertical" },

    { "x": 1, "y": 6, "dir": "vertical" },
    { "x": 2, "y": 6, "dir": "vertical" },
    { "x": 4, "y": 6, "dir": "vertical" },
    { "x": 5, "y": 6, "dir": "vertical" },
    { "x": 6, "y": 6, "dir": "vertical" },
    { "x": 7, "y": 6, "dir": "vertical" },

    { "x": 1, "y": 7, "dir": "vertical" },
    { "x": 2, "y": 7, "dir": "vertical" },
    { "x": 3, "y": 7, "dir": "vertical" },
    { "x": 4, "y": 7, "dir": "vertical" },
    { "x": 6, "y": 7, "dir": "vertical" },
    { "x": 7, "y": 7, "dir": "vertical" }
],
"key": { "x": 4, "y": 3 },
"gate": { "x": 5, "y": 1 }
}


==============================
PATH: MummyMaze\tools\test_generator_harness.py
==============================

import os
import sys
import random
from statistics import mean

# Ensure project root is on sys.path (so `api.io...` imports work)
THIS_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(THIS_DIR, ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from api.io.Lightning.maze.MazeGenerator import MazeGenerator


def win_cell(gen: MazeGenerator, exit_pos: dict, size: int):
    wx, wy = gen._exit_to_win_cell(exit_pos, size)
    if wx is None:
        return None
    return (int(wx), int(wy))


def validate_gate_key(gen: MazeGenerator, level: dict, size: int):
    """
    Returns:
      - None if no gate in level (not applicable)
      - True/False if gate exists (validity)
    Valid means:
      - key exists
      - when gate closed, target(win-cell) NOT reachable from start
      - key is reachable from start when gate closed
    """
    gate = level.get("gate")
    key = level.get("key")

    if not gate:
        return None  # N/A

    # Gate exists => key must exist for your intended puzzle
    if not key:
        return False

    try:
        start = (int(level["player"]["x"]), int(level["player"]["y"]))
        target = win_cell(gen, level.get("exit"), size)
        if target is None:
            return False

        gate_info = (int(gate["x"]), int(gate["y"]))
        key_pos = (int(key["x"]), int(key["y"]))
        walls = level.get("walls", [])

        reachable_closed = gen._reachable_set(start, walls, size, gate_info=gate_info, gate_open=False)

        choke_ok = (target not in reachable_closed)      # gate ƒë√≥ng => kh√¥ng t·ªõi win
        key_ok = (key_pos in reachable_closed)           # key n·∫±m ph√≠a tr∆∞·ªõc gate

        return bool(choke_ok and key_ok)

    except Exception:
        return False


def run_suite(N=50, sizes=(6, 8, 10), diffs=("easy", "medium", "hard"), seed=1337):
    random.seed(seed)

    gen = MazeGenerator()

    # stats[(diff, size)] = dict(...)
    stats = {}
    for d in diffs:
        for s in sizes:
            stats[(d, s)] = {
                "n": 0,
                "generated": 0,
                "solved": 0,
                "steps": [],
                "gate_present": 0,
                "gate_valid": 0,
                "gate_invalid": 0,
            }

    for d in diffs:
        for s in sizes:
            bucket = stats[(d, s)]
            for i in range(N):
                bucket["n"] += 1

                level = gen.generate_level(difficulty=d, maze_size=s)
                if not level:
                    continue
                bucket["generated"] += 1

                # Re-check solvability and compute steps
                path = gen._is_level_solvable(level, s)
                if path:
                    bucket["solved"] += 1
                    bucket["steps"].append(max(0, len(path) - 1))

                # Gate/key validity check
                gv = validate_gate_key(gen, level, s)
                if gv is None:
                    # no gate: do nothing
                    pass
                else:
                    bucket["gate_present"] += 1
                    if gv:
                        bucket["gate_valid"] += 1
                    else:
                        bucket["gate_invalid"] += 1

    # Print report
    print("=" * 72)
    print(f"GENERATOR HARNESS REPORT | N={N} per (diff,size) | seed={seed}")
    print("=" * 72)

    for d in diffs:
        print(f"\n--- Difficulty: {d} ---")
        for s in sizes:
            b = stats[(d, s)]
            gen_ok = b["generated"]
            solved = b["solved"]
            avg_steps = mean(b["steps"]) if b["steps"] else 0.0

            gate_p = b["gate_present"]
            gate_v = b["gate_valid"]
            gate_i = b["gate_invalid"]

            solved_rate = (solved / gen_ok * 100.0) if gen_ok else 0.0
            gate_valid_rate = (gate_v / gate_p * 100.0) if gate_p else 0.0

            print(f"Size {s}x{s}:")
            print(f"  Generated: {gen_ok}/{b['n']}")
            print(f"  Solved:    {solved}/{gen_ok}  ({solved_rate:.1f}%)")
            print(f"  Avg steps: {avg_steps:.2f}")
            print(f"  Gate present: {gate_p}/{gen_ok}")
            if gate_p:
                print(f"  Gate valid:   {gate_v}/{gate_p}  ({gate_valid_rate:.1f}%)")
                print(f"  Gate invalid: {gate_i}/{gate_p}")

    print("\nDone.")


if __name__ == "__main__":
    run_suite(
        N=50,                 # ƒë·ªïi s·ªë n√†y n·∫øu mu·ªën nhanh/ch·∫≠m
        sizes=(6, 8, 10),
        diffs=("easy", "medium", "hard"),
        seed=1337
    )


==============================
PATH: MummyMaze\tools\__init__.py
==============================

