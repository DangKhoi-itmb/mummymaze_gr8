

==============================
PATH: MummyMaze\pyproject.toml
==============================

[project]
name = "core"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.14"
dependencies = [
    "pygame-ce>=2.5.6",
]


==============================
PATH: MummyMaze\README.md
==============================

Hướng dẫn hệ thống đăng nhập và lưu game – Mummy Maze. 


I.	Màn hình đăng nhập (Login Screen).


Khi khởi động game, giao diện đầu tiên xuất hiện sẽ là màn hình đăng nhập, khi đó bạn có 3 lựa chọn : 


A.	Đăng ký tài khoản mới (Register).


Nếu bạn chưa có tài khoản, hãy làm theo các bước sau:


1.	 Nhập tên đăng nhập vào ô username.	 
2.	Nhập mật khẩu vào ô password.
3.	 Nhấn nút Register.


Khi đó nếu thành công thì game sẽ tự động đăng nhập và chuyển sang menu chính, còn nếu thất bại thì sẽ xuất hiện dòng chữ “Tai khoan da ton tai” màu đỏ bên dưới. Khi đó hãy chọn tên khác. 


B.	 Đăng nhập (Login). 


Dành cho người chơi đã có tài khoản:


1.	Nhập username và password đã đăng ký.
2.	Nhấn nút Login.


Nếu thành công thì màn hình sẽ chuyển vào menu chính với tên hiển thị của bạn, nếu thất bại thì hệ thống báo “Sai ten dang nhap hoac mat khau”.


C.	Chơi thử (Guest).


Nếu muốn chơi nhanh chóng mà không cần tạo tài khoản:


•	Nhấn nút chơi thử. 


•	Lưu ý: Tài khoản khách dùng chung một file lưu dữ liệu có thể bị ghi đè bởi người chơi khách khác.


II.	Menu chính. 


Sau khi đăng nhập thành công, bạn sẽ thấy các lựa chọn sau:


•	Phím Enter – Chơi mới (New game) : Bắt đầu lại từ level 1 với đầy đủ máu và chỉ số mặc định.


•	Phím L – Tiếp tục (Load game) : Tải lại màn chơi từ lần lưu gần nhất của tài khoản này.


•	Nếu chưa có file save, hệ thống sẽ báo lỗi trong Terminal (Console).


•	Phím Q – Thoát (Quit) : Đóng game. 


III.	Trong màn chơi & cách lưu game.


Khi đang trong mê cung, bạn sử dụng các phím sau để điều khiển và hệ thống:


•	Lưu game (Save) : Nhấn phím S thì trạng thái hiện tại (vị trí nhân vật, quái vật, số bước đi, level hiện tại) sẽ được lưu vào hệ thống và dòng chữ saved sẽ xuất hiện ở cửa sổ terminal/console.


•	Quay về Menu : Nhấn phím ESC thì game sẽ thoát ra màn hình Menu chính. 



==============================
PATH: MummyMaze\__init__.py
==============================



==============================
PATH: MummyMaze\api\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\entities\Enemy.py
==============================

import pygame
import os
import random
from collections import deque
from enum import Enum
from api.io.Lightning.entities.EntityLoader import Entity
from api.io.Lightning.manager.SoundReader import sfx_manager
from api.io.Lightning.utils.ConfigFile import ENTITIES_PATH, maze_coord_x, maze_coord_y, UI_PATH, OBJECTS_PATH
from api.io.Lightning.utils.Pathfinder import Pathfinder

class EnemyAI:
    def __init__(self, maze_size, walls, gate=None):
        self.maze_size = maze_size
        self.walls = walls
        self.gate = gate

    def _is_valid_move_callback(self, curr, nxt):
        return Entity.validate_move(curr[0], curr[1], nxt[0], nxt[1], self.maze_size, self.walls, self.gate)

    def _is_valid_move(self, from_pos, to_pos):
        return Entity.validate_move(from_pos[0], from_pos[1], to_pos[0], to_pos[1], self.maze_size, self.walls, self.gate)

    def _get_classic_path(self, start_pos, target_pos, steps, priority="horizontal"):
        path = []
        cur_x, cur_y = start_pos
        target_x, target_y = target_pos
        for _ in range(steps):
            dist_x = target_x - cur_x
            dist_y = target_y - cur_y
            moved = False
            check = [('x', dist_x), ('y', dist_y)] if priority == "horizontal" else [('y', dist_y), ('x', dist_x)]
            
            for axis, dist in check:
                if axis == 'x' and dist != 0:
                    nx = cur_x + (1 if dist > 0 else -1)
                    if self._is_valid_move([cur_x, cur_y], [nx, cur_y]):
                        cur_x = nx; path.append([cur_x, cur_y]); moved = True; break
                elif axis == 'y' and dist != 0:
                    ny = cur_y + (1 if dist > 0 else -1)
                    if self._is_valid_move([cur_x, cur_y], [cur_x, ny]):
                        cur_y = ny; path.append([cur_x, cur_y]); moved = True; break
            if not moved: break
        return path

    def get_move_path(self, enemy, player_pos, difficulty='medium'):
        etype = enemy['type']
        curr = enemy['pos']
        # Hard Mode: Red Scorpion dùng A*
        if difficulty == 'hard' and 'red_scorpion' in etype:
            path = Pathfinder.astar_search(curr, player_pos, self.maze_size, self._is_valid_move_callback)
            if path: return path[:1]
            return []

        steps = 2 if 'mummy' in etype else 1
        if etype == 'white_mummy': return self._get_classic_path(curr, player_pos, steps, "horizontal")
        elif etype == 'red_mummy': return self._get_classic_path(curr, player_pos, steps, "vertical")
        else: return self._get_classic_path(curr, player_pos, 1, "horizontal")
        return []

class EnemyState(Enum):
    IDLE = "idle"; WALK = "walk"; DIE = "die"
    AFK_LISTEN = "listen"; AFK_DANCE = "dance"; AFK_SPIN = "spin"

class Enemy(Entity):
    def __init__(self, x, y, enemy_type, maze_size, tile_size, walls, gate=None):
        super().__init__(x, y)
        self.type = enemy_type; self.maze_size = maze_size; self.tile_size = tile_size
        self.ai = EnemyAI(maze_size, walls, gate)
        self.state = EnemyState.IDLE; self.direction = 'down'
        self.is_dead = False; self.strength = 0; self._set_stats()
        self.pixel_x = x * tile_size; self.pixel_y = y * tile_size
        self.target_x = self.pixel_x; self.target_y = self.pixel_y
        self.move_queue = deque(); self.move_speed = 3; self.is_moving = False
        self.paused = False; self.is_retreating = False; self.locked_direction = None
        self.is_turning = False; self.turn_timer = 0; self.current_walk_variant = None
        self.last_afk_time = 0; self.frame_index = 0; self.animation_speed = 0.05
        self.last_update_time = pygame.time.get_ticks(); self.animations = {}; self._load_assets()

    def _set_stats(self):
        if self.type == 'scorpion': self.strength = 1
        elif self.type == 'red_scorpion': self.strength = 2
        elif self.type == 'white_mummy': self.strength = 3
        elif self.type == 'red_mummy': self.strength = 4

    def _load_assets(self):
        def load_img(name):
            for folder in [ENTITIES_PATH, UI_PATH, OBJECTS_PATH]:
                for sz in [self.maze_size, 6, ""]:
                    for ext in [".png", ".gif"]:
                        path = os.path.join(folder, f"{name}{sz}{ext}")
                        if os.path.exists(path): return pygame.image.load(path).convert_alpha()
            return None
        def load_grid(sheet):
            if not sheet: return {'up': [], 'right': [], 'down': [], 'left': []}
            w, h = sheet.get_size(); fw, fh = w // 5, h // 4
            anims = {'up': [], 'right': [], 'down': [], 'left': []}
            for row, d in enumerate(['up', 'right', 'down', 'left']):
                for col in range(5): anims[d].append(sheet.subsurface((col * fw, row * fh, fw, fh)))
            return anims
        def load_strip(sheet):
            if not sheet: return []
            h = sheet.get_height(); count = sheet.get_width() // h
            return [sheet.subsurface((i * h, 0, h, h)) for i in range(count)]

        base_name = {'scorpion': 'scorpion', 'red_scorpion': 'redscorpion', 'white_mummy': 'mummy', 'red_mummy': 'redmummy'}.get(self.type, 'mummy')
        sheet = load_img(base_name)
        if not sheet and self.type == 'red_mummy':
            sheet = load_img('mummy')
            if sheet:
                tint = pygame.Surface(sheet.get_size(), pygame.SRCALPHA); tint.fill((255, 100, 100))
                sheet.blit(tint, (0, 0), special_flags=pygame.BLEND_MULT)
        if sheet:
            walks = load_grid(sheet)
            self.animations['walk_up'] = walks['up']; self.animations['walk_right'] = walks['right']
            self.animations['walk_down'] = walks['down']; self.animations['walk_left'] = walks['left']
        if 'mummy' in self.type:
            pre = "white" if self.type == 'white_mummy' else "red"
            self.animations[EnemyState.AFK_LISTEN] = load_strip(load_img(f"{pre}listen")) or load_strip(load_img("whitelisten"))
            self.animations[EnemyState.AFK_DANCE] = load_strip(load_img(f"{pre}dance")) or load_strip(load_img("whitedance"))
            self.animations[EnemyState.AFK_SPIN] = load_strip(load_img(f"{pre}spin")) or load_strip(load_img("whitespin"))
        self.animations[EnemyState.DIE] = load_strip(load_img("dust"))

    def move_logic(self, player_pos, difficulty='medium'):
        if self.state == EnemyState.DIE: return
        path = self.ai.get_move_path({'type': self.type, 'pos': [self.x, self.y]}, player_pos, difficulty)
        for step in path:
            if step != [self.x, self.y]: self.move_queue.append(step)

    def face_target(self, target_x, target_y):
        if self.is_dead: return
        dx = target_x - self.x; dy = target_y - self.y
        new_dir = self.direction
        if abs(dx) > abs(dy): new_dir = 'right' if dx > 0 else 'left'
        elif abs(dy) > abs(dx): new_dir = 'down' if dy > 0 else 'up'
        if new_dir != self.direction:
            self.direction = new_dir
            if not self.is_moving:
                self.is_turning = True; self.turn_timer = pygame.time.get_ticks(); self.state = EnemyState.WALK

    def retreat_to(self, target_x, target_y):
        self.is_retreating = True; self.locked_direction = self.direction
        self.move_queue.clear(); self.move_queue.append([target_x, target_y])

    def trigger_afk(self):
        if pygame.time.get_ticks() - self.last_afk_time < 14000: return
        if 'mummy' in self.type and not self.is_moving and not self.move_queue and self.state != EnemyState.DIE:
            self.state = random.choice([EnemyState.AFK_LISTEN, EnemyState.AFK_DANCE, EnemyState.AFK_SPIN]); self.frame_index = 0

    def trigger_die(self, instant=False):
        if instant: self.is_dead = True
        else: self.state = EnemyState.DIE; self.frame_index = 0; self.is_moving = False; self.move_queue.clear()

    def update(self):
        if self.is_turning:
            if pygame.time.get_ticks() - self.turn_timer > 50:
                self.is_turning = False
                if not self.is_moving and self.state == EnemyState.WALK: self.state = EnemyState.IDLE; self.frame_index = 0

        can_start = (not self.is_moving and self.move_queue and not self.paused)
        if can_start:
            next_pos = self.move_queue.popleft()
            dx, dy = next_pos[0] - self.x, next_pos[1] - self.y
            self.current_walk_variant = sfx_manager.play_walk_start(self.type)
            if not self.is_retreating:
                if dx > 0: self.direction = 'right'
                elif dx < 0: self.direction = 'left'
                elif dy > 0: self.direction = 'down'
                elif dy < 0: self.direction = 'up'
            elif self.locked_direction: self.direction = self.locked_direction
            self.x, self.y = next_pos
            self.target_x = self.x * self.tile_size; self.target_y = self.y * self.tile_size
            self.is_moving = True; self.state = EnemyState.WALK; self.is_turning = False

        if self.is_moving:
            if self.pixel_x < self.target_x: self.pixel_x = min(self.pixel_x + self.move_speed, self.target_x)
            elif self.pixel_x > self.target_x: self.pixel_x = max(self.pixel_x - self.move_speed, self.target_x)
            if self.pixel_y < self.target_y: self.pixel_y = min(self.pixel_y + self.move_speed, self.target_y)
            elif self.pixel_y > self.target_y: self.pixel_y = max(self.pixel_y - self.move_speed, self.target_y)

            if self.pixel_x == self.target_x and self.pixel_y == self.target_y:
                self.is_moving = False
                if self.current_walk_variant: sfx_manager.play_walk_end(self.type, self.current_walk_variant); self.current_walk_variant = None
                if not self.move_queue and not self.is_turning:
                    if self.state == EnemyState.WALK: self.state = EnemyState.IDLE
                if self.is_retreating: self.is_retreating = False; self.locked_direction = None

        current_time = pygame.time.get_ticks()
        if current_time - self.last_update_time > (self.animation_speed * 1000):
            self.last_update_time = current_time
            if self.state == EnemyState.WALK:
                anim = self.animations.get(f'walk_{self.direction}', [])
                if anim: self.frame_index = (self.frame_index + 1) % len(anim)
            elif self.state == EnemyState.IDLE:
                anim = self.animations.get(f'walk_{self.direction}', [])
                if anim: self.frame_index = 0
            elif "AFK" in self.state.name:
                anim = self.animations.get(self.state, [])
                if anim:
                    if self.frame_index < len(anim) - 1: self.frame_index += 1
                    else: self.state = EnemyState.IDLE; self.direction = 'down'; self.frame_index = 0
            elif self.state == EnemyState.DIE:
                anim = self.animations.get(self.state, [])
                if anim:
                    if self.frame_index < len(anim) - 1: self.frame_index += 1
                    else: self.is_dead = True

    def draw(self, surface):
        if self.is_dead: return
        key = f'walk_{self.direction}' if self.state in [EnemyState.WALK, EnemyState.IDLE] else self.state
        anim = self.animations.get(key, [])
        if anim:
            idx = int(self.frame_index) if self.frame_index < len(anim) else 0
            img = anim[idx]
            dx = maze_coord_x + self.pixel_x + (self.tile_size - img.get_width()) // 2
            dy = maze_coord_y + self.pixel_y + (self.tile_size - img.get_height()) // 2
            surface.blit(img, (dx, dy))

==============================
PATH: MummyMaze\api\io\Lightning\entities\EntityLoader.py
==============================

import pygame


class Entity:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.direction = 'down'
        self.pixel_x = 0
        self.pixel_y = 0

    def check_position(self, entity):
        return (entity.x == self.x) and (entity.y == self.y)

    def set_position(self, x, y):
        self.x = x
        self.y = y

    def get_pos(self):
        return self.x, self.y

    def set_direction(self, new_x, new_y):
        if new_x > self.x:
            self.direction = 'right'
        elif new_x < self.x:
            self.direction = 'left'
        elif new_y > self.y:
            self.direction = 'down'
        elif new_y < self.y:
            self.direction = 'up'

    def set_x(self, x):
        self.x = x

    def set_y(self, y):
        self.y = y

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    @staticmethod
    def validate_move(start_x, start_y, end_x, end_y, maze_size, walls, gate=None):
        """
        Static method to check if a move from (start_x, start_y) to (end_x, end_y) is valid.
        """
        # 1. Check Map Boundaries
        if not (0 <= end_x < maze_size and 0 <= end_y < maze_size):
            return False

        # 2. Check Gate Collision
        if gate and gate.is_blocking():
            gx, gy = gate.grid_x, gate.grid_y

            # The gate is visually at the TOP of cell (gx, gy).
            # It acts as a wall between (gx, gy) and (gx, gy-1).

            # Case A: Moving DOWN into the gate cell from above
            # From (gx, gy-1) -> To (gx, gy)
            if start_x == gx and start_y == gy - 1 and end_x == gx and end_y == gy:
                return False

            # Case B: Moving UP out of the gate cell
            # From (gx, gy) -> To (gx, gy-1)
            if start_x == gx and start_y == gy and end_x == gx and end_y == gy - 1:
                return False

        # 3. Check Wall Collision
        # Moving RIGHT
        if end_x > start_x:
            for w in walls:
                if w['x'] == end_x and w['y'] == end_y and w['dir'] in ['vertical', 'both']: return False
        # Moving LEFT
        elif end_x < start_x:
            for w in walls:
                if w['x'] == start_x and w['y'] == start_y and w['dir'] in ['vertical', 'both']: return False
        # Moving DOWN
        elif end_y > start_y:
            for w in walls:
                if w['x'] == end_x and w['y'] == end_y and w['dir'] in ['horizontal', 'both']: return False
        # Moving UP
        elif end_y < start_y:
            for w in walls:
                if w['x'] == start_x and w['y'] == start_y and w['dir'] in ['horizontal', 'both']: return False

        return True

    def check_eligible_move(self, new_x, new_y, maze_size, walls, gate=None):
        """Wrapper for instance-based check"""
        return Entity.validate_move(self.x, self.y, new_x, new_y, maze_size, walls, gate)

==============================
PATH: MummyMaze\api\io\Lightning\entities\Player.py
==============================

import pygame
import os
import random
from enum import Enum
from api.io.Lightning.entities.EntityLoader import Entity
from api.io.Lightning.manager.SoundReader import sfx_manager
from api.io.Lightning.utils.ConfigFile import ENTITIES_PATH, maze_coord_x, maze_coord_y

class PlayerState(Enum):
    IDLE = "idle"
    WALK = "walk"
    AFK_READMAP = "readmap"
    AFK_LIGHT = "light"
    AFK_SEARCH = "search"
    AFK_SHRUG = "shrug"
    DIE_WHITE_MUMMY = 'whitefight'
    DIE_RED_MUMMY = 'redfight'
    DIE_STUNG = "stung"
    DIE_TRAP = "freakout"

class Player(Entity):
    def __init__(self, x, y, maze_size, tile_size):
        super().__init__(x, y)
        self.maze_size = maze_size
        self.tile_size = tile_size
        self.target_x = x; self.target_y = y
        self.pixel_x = x * tile_size; self.pixel_y = y * tile_size
        self.move_speed = 2
        self.is_moving = False
        self.next_move_time = 0
        self.move_cooldown = 50
        self.state = PlayerState.IDLE
        self.direction = 'down'
        self.frame_index = 0
        self.animation_speed = 0.20
        self.animation_counter = 0
        self.last_input_time = pygame.time.get_ticks()
        self.afk_delay = 7000
        self.current_walk_variant = None
        self.animations = {}
        self._load_assets()

    def _load_assets(self):
        def load_img(name):
            for ext in [".png", ".gif"]:
                path = os.path.join(ENTITIES_PATH, f"{name}{self.maze_size}{ext}")
                if os.path.exists(path):
                    try: return pygame.image.load(path).convert_alpha()
                    except: pass
            return None

        def load_strip_square(sheet):
            if not sheet: return []
            w, h = sheet.get_size()
            fw = h
            count = w // fw
            return [sheet.subsurface((i * fw, 0, fw, h)) for i in range(count)]

        def load_grid_explorer(sheet):
            if not sheet: return {}
            w, h = sheet.get_size()
            cols, rows = 5, 4
            fw, fh = w // cols, h // rows
            anims = {'up': [], 'right': [], 'down': [], 'left': []}
            dirs = ['up', 'right', 'down', 'left']
            for row, d in enumerate(dirs):
                for col in range(cols):
                    anims[d].append(sheet.subsurface((col * fw, row * fh, fw, fh)))
            return anims

        sheet = load_img("explorer")
        if sheet:
            walks = load_grid_explorer(sheet)
            for d in ['up', 'right', 'down', 'left']:
                self.animations[f'walk_{d}'] = walks.get(d, [])

        # Load AFK & Death strips
        for state, name in [
            (PlayerState.AFK_READMAP, "readmap"), (PlayerState.AFK_LIGHT, "light"),
            (PlayerState.AFK_SEARCH, "search"), (PlayerState.AFK_SHRUG, "shrug"),
            (PlayerState.DIE_TRAP, "freakout"), (PlayerState.DIE_STUNG, "stung"),
            (PlayerState.DIE_RED_MUMMY, "redfight"), (PlayerState.DIE_WHITE_MUMMY, "whitefight")
        ]:
            self.animations[state] = load_strip_square(load_img(name))

    def is_ready(self):
        return (not self.is_moving and "DIE" not in self.state.name and 
                pygame.time.get_ticks() >= self.next_move_time)

    def is_anim_finished(self):
        anim = self.animations.get(self.state, [])
        return self.frame_index >= len(anim) - 1

    def handle_input(self):
        if not self.is_ready() and "AFK" not in self.state.name: return None
        keys = pygame.key.get_pressed()
        dx, dy = 0, 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]: dx = -1
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]: dx = 1
        elif keys[pygame.K_UP] or keys[pygame.K_w]: dy = -1
        elif keys[pygame.K_DOWN] or keys[pygame.K_s]: dy = 1
        elif keys[pygame.K_SPACE]: 
            self._reset_afk(); return (0, 0) # Wait
        
        if dx != 0 or dy != 0:
            self._reset_afk()
            return (dx, dy)
        return None

    def _reset_afk(self):
        self.last_input_time = pygame.time.get_ticks()
        if "AFK" in self.state.name:
            self.state = PlayerState.IDLE
            self.frame_index = 0

    def move_player(self, dx, dy):
        self.next_move_time = pygame.time.get_ticks() + self.move_cooldown
        if dx == 0 and dy == 0:
            self.state = PlayerState.IDLE
            self._reset_afk()
            return

        self.x += dx
        self.y += dy
        self.target_x = self.x * self.tile_size
        self.target_y = self.y * self.tile_size
        self.is_moving = True
        self.state = PlayerState.WALK
        self._reset_afk()
        self.current_walk_variant = sfx_manager.play_walk_start('player')
        
        if dx > 0: self.direction = 'right'
        if dx < 0: self.direction = 'left'
        if dy > 0: self.direction = 'down'
        if dy < 0: self.direction = 'up'

    def update(self):
        current_time = pygame.time.get_ticks()
        
        # Logic di chuyển
        if self.is_moving:
            if self.pixel_x < self.target_x: self.pixel_x = min(self.pixel_x + self.move_speed, self.target_x)
            elif self.pixel_x > self.target_x: self.pixel_x = max(self.pixel_x - self.move_speed, self.target_x)
            if self.pixel_y < self.target_y: self.pixel_y = min(self.pixel_y + self.move_speed, self.target_y)
            elif self.pixel_y > self.target_y: self.pixel_y = max(self.pixel_y - self.move_speed, self.target_y)

            if self.pixel_x == self.target_x and self.pixel_y == self.target_y:
                self.is_moving = False
                if self.current_walk_variant:
                    sfx_manager.play_walk_end('player', self.current_walk_variant)
                    self.current_walk_variant = None
                self.state = PlayerState.IDLE
                self.frame_index = 0
                self.last_input_time = current_time
        
        # Logic AFK
        elif self.state == PlayerState.IDLE:
            if current_time >= self.next_move_time:
                if current_time - self.last_input_time > self.afk_delay:
                    self._trigger_random_afk()

        # Update Animation
        key = f'walk_{self.direction}' if self.state in [PlayerState.WALK, PlayerState.IDLE] else self.state
        anim = self.animations.get(key, [])
        if not anim: return

        self.animation_counter += self.animation_speed
        if self.animation_counter >= 1.0:
            self.animation_counter = 0
            if self.state == PlayerState.WALK:
                self.frame_index = (self.frame_index + 1) % len(anim)
            elif "AFK" in self.state.name:
                if self.frame_index < len(anim) - 1: self.frame_index += 1
                else: 
                    self.state = PlayerState.IDLE
                    self.direction = 'down'
                    self.last_input_time = current_time
                    self.frame_index = 0
            elif "DIE" in self.state.name:
                if self.frame_index < len(anim) - 1: self.frame_index += 1

    def _trigger_random_afk(self):
        self.state = random.choice([PlayerState.AFK_READMAP, PlayerState.AFK_LIGHT, PlayerState.AFK_SEARCH, PlayerState.AFK_SHRUG])
        self.frame_index = 0

    def draw(self, surface):
        key = f'walk_{self.direction}' if self.state in [PlayerState.WALK, PlayerState.IDLE] else self.state
        anim = self.animations.get(key, [])
        if anim:
            idx = int(self.frame_index) if self.frame_index < len(anim) else 0
            img = anim[idx]
            dx = maze_coord_x + self.pixel_x + (self.tile_size - img.get_width()) // 2
            dy = maze_coord_y + self.pixel_y + (self.tile_size - img.get_height()) // 2
            surface.blit(img, (dx, dy))

==============================
PATH: MummyMaze\api\io\Lightning\gui\GameUI.py
==============================

import pygame
import os
from enum import Enum
from api.io.Lightning.gui.MapTracker import WorldMapPanel
from api.io.Lightning.manager.SoundReader import sfx_manager, music_manager
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.maze.MazeLoader import MazeLoader
from api.io.Lightning.listener.AnimatedListener import initialize_torch_animation
from api.io.Lightning.utils.ConfigFile import *
from api.io.Lightning.manager.ButtonManager import ButtonManager
from api.io.Lightning.entities.Player import Player, PlayerState
from api.io.Lightning.manager.StorageManager import storage_manager

class TurnState(Enum):
    PLAYER_INPUT = 0
    PLAYER_MOVING = 1
    ENEMY_TURN = 2
    ENEMY_MOVING = 3
    PLAYER_DYING = 4
    FIGHT_PAUSE = 5

_button_manager = None
_torch_animation = None
_maze_loader = None
_maze_size = None
_player = None
_world_map = None
_turn_state = TurnState.PLAYER_INPUT
_death_timer = 0
_killer_ref = None
_death_step = 0
_death_step_timer = 0
_fight_pause_timer = 0
_show_options = False
_level_start_time = 0
_steps_taken = 0
_snake_img = None
_mumlogo_img = None
_msg_timer = 0
_status_msg = "" 

def _get_ui_images():
    global _snake_img, _mumlogo_img
    if _snake_img is None:
        _snake_img = pygame.image.load(os.path.join(UI_PATH, "snake.png")).convert_alpha()
    if _mumlogo_img is None:
        _mumlogo_img = pygame.image.load(os.path.join(UI_PATH, "mumlogo.png")).convert_alpha()
    return _snake_img, _mumlogo_img

def _reset_runtime_state(full_reset=True):
    global _turn_state, _death_timer, _killer_ref, _death_step, _death_step_timer, _fight_pause_timer, _show_options, _steps_taken, _level_start_time
    _turn_state = TurnState.PLAYER_INPUT
    _death_timer = 0
    _killer_ref = None
    _death_step = 0
    _death_step_timer = 0
    _fight_pause_timer = 0
    _show_options = False
    if full_reset:
        _steps_taken = 0
        _level_start_time = pygame.time.get_ticks()

def initialize_ui(mode="random", level_id=1, size=8, difficulty="medium", saved_state=None):
    global _button_manager, _torch_animation, _maze_loader, _player, _turn_state, _world_map, _snake_img, _mumlogo_img, _maze_size
    _snake_img = None
    _mumlogo_img = None
    
    if saved_state:
        size = saved_state.get('maze_size', 8)
    
    _maze_size = size
    _reset_runtime_state(full_reset=True)
    _button_manager = ButtonManager()
    _torch_animation = initialize_torch_animation()
    sfx_manager.initialize()
    music_manager.initialize()
    _world_map = WorldMapPanel(x=8, y=320)

    if saved_state:
        _maze_loader = MazeLoader(generate_infinite=False, saved_state=saved_state)
    elif mode == "campaign":
        print(f"Loading Campaign Level {level_id}...")
        _maze_loader = MazeLoader(level_id=level_id, difficulty=None, generate_infinite=False)
    else:
        print(f"Generating Random Level ({size}x{size})...")
        _maze_loader = MazeLoader(level_id=None, difficulty=difficulty, generate_infinite=True, maze_size=size)

    if _maze_loader and _maze_loader.parsed:
        p = _maze_loader.parsed["player"]
        _player = Player(p["x"], p["y"], _maze_loader.maze_size, _maze_loader.cell_size)
        if saved_state:
            _player.direction = p['direction']
    else:
        print("❌ CRITICAL ERROR: Could not load level data!")
    
    _turn_state = TurnState.PLAYER_INPUT

def handle_game_input(event, mouse_pos):
    global _button_manager, _player, _maze_loader, _turn_state, _show_options, _status_msg, _msg_timer
    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE:
            _show_options = not _show_options
            return "option"
    
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        if _show_options:
            action = _check_options_click(mouse_pos)
            if action == "resume":
                _show_options = False
            elif action == "quit":
                return "quit"
            elif action == "save":
                if _maze_loader and _player:
                    state_data = _maze_loader.serialize_state(_player)
                    if storage_manager.save_game_state(state_data):
                        _status_msg = "GAME SAVED!"
                        _msg_timer = pygame.time.get_ticks()
            return None
        
        clicked_btn = None
        for name, rect in _button_manager.button_rects.items():
            if rect.collidepoint(mouse_pos):
                clicked_btn = name
                _button_manager.set_clicked(name)
                break
        
        if clicked_btn == "option":
            _show_options = True
            return "option"
        if clicked_btn == "quit":
            return "quit"
        if clicked_btn == "reset":
            restart_level()
            return "reset"
        if clicked_btn == "undo":
            undo_move()
            return "undo"
        
    if _show_options: return None
    
    if _turn_state == TurnState.PLAYER_INPUT:
        if _player and _maze_loader:
            move = _player.handle_input()
            if move:
                _execute_player_move(move[0], move[1])
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if _player and _maze_loader:
                mx, my = mouse_pos
                gx = (mx - maze_coord_x) // _maze_loader.cell_size
                gy = (my - maze_coord_y) // _maze_loader.cell_size
                if 0 <= gx < _maze_loader.maze_size and 0 <= gy < _maze_loader.maze_size:
                    dx = gx - _player.x
                    dy = gy - _player.y
                    if (abs(dx) + abs(dy) == 1) or (dx == 0 and dy == 0):
                        _execute_player_move(dx, dy)
    
    if event.type == pygame.MOUSEBUTTONUP:
        _button_manager.clear_clicked()
    return None

def _draw_options_menu(screen):
    overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 180))
    screen.blit(overlay, (0, 0))
    
    cx, cy = screen.get_width() // 2, screen.get_height() // 2
    rect = pygame.Rect(cx - 160, cy - 150, 320, 300)
    pygame.draw.rect(screen, (40, 30, 10), rect)
    pygame.draw.rect(screen, (150, 100, 50), rect, 4)
    
    designer = TextDesigner(size=32, color=(255, 215, 0))
    designer.render_header("OPTIONS", screen, cx, rect.y + 30)
    
    btn_designer = TextDesigner(size=24)
    mouse_pos = pygame.mouse.get_pos()
    
    btn_designer.draw_button(screen, "RESUME", cx, rect.y + 70, mouse_pos)
    btn_designer.draw_button(screen, "SAVE GAME", cx, rect.y + 110, mouse_pos)
    
    y_mus = rect.y + 160
    designer.render_default("MUSIC", screen, cx - 80, y_mus)
    btn_designer.draw_button(screen, "[-]", cx - 10, y_mus, mouse_pos)
    vol_mus = int(music_manager.get_volume() * 100)
    designer.render_default(f"{vol_mus}%", screen, cx + 40, y_mus, color=(200, 200, 200))
    btn_designer.draw_button(screen, "[+]", cx + 90, y_mus, mouse_pos)

    y_sfx = rect.y + 200
    designer.render_default("SFX", screen, cx - 80, y_sfx)
    btn_designer.draw_button(screen, "[-]", cx - 10, y_sfx, mouse_pos)
    vol_sfx = int(sfx_manager.get_volume() * 100)
    designer.render_default(f"{vol_sfx}%", screen, cx + 40, y_sfx, color=(200, 200, 200))
    btn_designer.draw_button(screen, "[+]", cx + 90, y_sfx, mouse_pos)

    btn_designer.draw_button(screen, "QUIT TO MENU", cx, rect.y + 260, mouse_pos)
    
    global _status_msg, _msg_timer
    if _status_msg:
        if pygame.time.get_ticks() - _msg_timer < 2000:
            succ_designer = TextDesigner(size=20, color=(0, 255, 0))
            succ_designer.render_default(_status_msg, screen, cx, rect.y + 285)
        else:
            _status_msg = ""

def _check_options_click(mouse_pos):
    cx, cy = 320, 240
    top_y = cy - 150 
    
    def is_center_btn(y):
        return (cx - 100 < mouse_pos[0] < cx + 100) and (y - 15 < mouse_pos[1] < y + 15)
    
    def is_small_btn(x, y):
        return (x - 20 < mouse_pos[0] < x + 20) and (y - 15 < mouse_pos[1] < y + 15)

    if is_center_btn(top_y + 70): return "resume"
    if is_center_btn(top_y + 110): return "save"
    
    y_mus = top_y + 160
    if is_small_btn(cx - 10, y_mus):
        v = music_manager.get_volume()
        music_manager.set_volume(max(0.0, v - 0.1))
        return "vol_change"
    if is_small_btn(cx + 90, y_mus): 
        v = music_manager.get_volume()
        music_manager.set_volume(min(1.0, v + 0.1))
        return "vol_change"

    y_sfx = top_y + 200
    if is_small_btn(cx - 10, y_sfx):
        v = sfx_manager.get_volume()
        sfx_manager.set_volume(max(0.0, v - 0.1))
        return "vol_change"
    if is_small_btn(cx + 90, y_sfx):
        v = sfx_manager.get_volume()
        sfx_manager.set_volume(min(1.0, v + 0.1))
        return "vol_change"

    if is_center_btn(top_y + 260): return "quit"
    return None

def _execute_player_move(dx, dy):
    global _player, _maze_loader, _turn_state, _steps_taken
    if not _player.is_ready(): return
    if dx == 0 and dy == 0:
        _maze_loader.save_state(_player); _player.move_player(0, 0); _turn_state = TurnState.ENEMY_TURN; _maze_loader.init_enemy_turn_sequence(); return
    tx = _player.x + dx; ty = _player.y + dy
    for e in _maze_loader.enemies_list:
        if e.x == tx and e.y == ty: return
    if _player.check_eligible_move(tx, ty, _maze_loader.maze_size, _maze_loader.parsed["walls"], _maze_loader.gate_obj):
        _maze_loader.save_state(_player); _player.move_player(dx, dy); _steps_taken += 1; _turn_state = TurnState.PLAYER_MOVING

def restart_level():
    global _player, _maze_loader, _turn_state; _reset_runtime_state(full_reset=True)
    if _maze_loader:
        _maze_loader.reset()
        if _maze_loader.parsed: p = _maze_loader.parsed["player"]; _player = Player(p["x"], p["y"], _maze_loader.maze_size, _maze_loader.cell_size)
    _turn_state = TurnState.PLAYER_INPUT; reset_input()

def undo_move():
    global _player, _maze_loader, _turn_state, _death_timer, _killer_ref, _steps_taken
    if _maze_loader and _player:
        if _maze_loader.undo_last_move(_player):
            _turn_state = TurnState.PLAYER_INPUT; _death_timer = 0; _killer_ref = None; _player.state = PlayerState.IDLE; _player.frame_index = 0; _steps_taken = max(0, _steps_taken - 1)

def reset_input():
    if _button_manager: _button_manager.clear_clicked()

def _is_win():
    global _maze_loader, _player
    if not _maze_loader or not _player: return False
    win = _maze_loader.get_win_cell()
    if not win: return False
    return (_player.x == win[0] and _player.y == win[1])

def draw_screen(screen, hovered=None, clicked=None, draw_mumlogo=True, mumlogo_y=None):
    global _torch_animation, _maze_loader, _player, _turn_state, _death_step, _death_step_timer, _fight_pause_timer, _killer_ref
    snake, mumlogo = _get_ui_images()
    if not _show_options and _player and _maze_loader:
        _player.update(); _maze_loader.update()
        if _turn_state == TurnState.PLAYER_MOVING:
            if not _player.is_moving:
                _maze_loader.check_key_collision(_player.x, _player.y)
                if _maze_loader.check_trap_collision(_player.x, _player.y): _maze_loader.pause_enemies(); _player.state = PlayerState.DIE_TRAP; _player.frame_index = 0; _turn_state = TurnState.PLAYER_DYING; _death_step = 3; _death_step_timer = 0; _killer_ref = None; return None
                if _is_win():
                    elapsed_ms = pygame.time.get_ticks() - _level_start_time
                    # --- CÔNG THỨC TÍNH ĐIỂM CHUẨN ---
                    score = max(0, 10000 - (elapsed_ms // 100) - (_steps_taken * 50))
                    return ("win", score, elapsed_ms)
                _turn_state = TurnState.ENEMY_TURN; _maze_loader.init_enemy_turn_sequence()
        elif _turn_state == TurnState.ENEMY_TURN:
            for e in _maze_loader.enemies_list: e.prev_x = e.x; e.prev_y = e.y
            _maze_loader.init_enemy_turn_sequence(); _turn_state = TurnState.ENEMY_MOVING
        elif _turn_state == TurnState.ENEMY_MOVING:
            kill = False
            for e in _maze_loader.enemies_list:
                if e.x == _player.x and e.y == _player.y: sfx_manager.play("pummel"); e.move_queue.clear(); _killer_ref = e; _maze_loader.spawn_fight_cloud(_player.x, _player.y); _killer_ref.face_target(_player.x, _player.y); _turn_state = TurnState.PLAYER_DYING; _death_step = 1; _death_step_timer = pygame.time.get_ticks(); kill = True; break
            if not kill:
                if _maze_loader.resolve_enemy_collisions(): _maze_loader.pause_enemies(); _turn_state = TurnState.FIGHT_PAUSE; _fight_pause_timer = pygame.time.get_ticks()
                else:
                    if _maze_loader.update_turn_sequence(_player.get_pos()): _maze_loader.face_enemies_to_player(_player); _turn_state = TurnState.PLAYER_INPUT; _player.last_input_time = pygame.time.get_ticks(); _maze_loader.check_solvability(_player)
        elif _turn_state == TurnState.FIGHT_PAUSE:
            if pygame.time.get_ticks() - _fight_pause_timer > 500: _maze_loader.process_pending_deaths(); _maze_loader.resume_enemies(); _turn_state = TurnState.ENEMY_MOVING
        elif _turn_state == TurnState.PLAYER_DYING:
            now = pygame.time.get_ticks()
            if _death_step == 1:
                if now - _death_step_timer > 550:
                    if _killer_ref and "scorpion" in _killer_ref.type: _killer_ref.retreat_to(_killer_ref.prev_x, _killer_ref.prev_y); _death_step = 2
                    else:
                        if _killer_ref and "mummy" in _killer_ref.type: _player.state = (PlayerState.DIE_RED_MUMMY if _killer_ref.type == "red_mummy" else PlayerState.DIE_WHITE_MUMMY); 
                        if _killer_ref in _maze_loader.enemies_list: _maze_loader.enemies_list.remove(_killer_ref)
                        _player.frame_index = 0; _death_step = 3
            elif _death_step == 2:
                if _killer_ref and not _killer_ref.is_moving: _player.state = PlayerState.DIE_STUNG; sfx_manager.play("poison"); _player.frame_index = 0; _death_step = 3; _death_step_timer = now
            elif _death_step == 3:
                anim = _player.animations.get(_player.state, [])
                if anim and _player.frame_index >= len(anim) - 1:
                    if _death_step_timer == 0: _death_step_timer = now
                    if now - _death_step_timer > 1000: return "lose"
        elif _turn_state == TurnState.PLAYER_INPUT:
            if "AFK" in _player.state.name: _maze_loader.trigger_enemy_afk()

    if _maze_loader: _maze_loader.draw_background(screen)
    if _torch_animation and _torch_animation.loaded and _maze_loader:
        _torch_animation.update(); ms = _maze_loader.maze_size
        if ms == 6: _torch_animation.draw(screen, 300, 40); _torch_animation.draw(screen, 475, 40)
        elif ms == 8: _torch_animation.draw(screen, 320, 40); _torch_animation.draw(screen, 455, 40)
        elif ms == 10: _torch_animation.draw(screen, 295, 40); _torch_animation.draw(screen, 475, 40)
    if _maze_loader:
        m = pygame.mouse.get_pos() if _turn_state == TurnState.PLAYER_INPUT else None
        _maze_loader.draw(screen, _player, None, m)
    screen.blit(snake, (8, 80))
    if draw_mumlogo: screen.blit(mumlogo, (14, mumlogo_y if mumlogo_y else 14))
    if _world_map and _maze_loader: current_lvl = int(_maze_loader.level_id) if _maze_loader.level_id else 15; _world_map.draw(screen, current_lvl)
    if _maze_loader: _maze_loader.draw_ankh(screen)
    if _button_manager: _button_manager.draw_buttons(screen, hovered, clicked)
    if _show_options: _draw_options_menu(screen)
    return None

def get_hover_state(mouse_pos):
    if not _button_manager: return None
    for name, rect in _button_manager.button_rects.items():
        if rect.collidepoint(mouse_pos): return name
    return None

def get_clicked_state(): return _button_manager.clicked_button if _button_manager else None

==============================
PATH: MummyMaze\api\io\Lightning\gui\Interface.py
==============================

import pygame
import os
from api.io.Lightning.gui import GameUI
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.utils.ConfigFile import UI_PATH, SOUNDS_PATH, fps
from api.io.Lightning.manager.SoundReader import music_manager
from api.io.Lightning.manager.StorageManager import storage_manager

def init():
    pygame.init()
    screen = pygame.display.set_mode((640, 480))
    pygame.display.set_caption("Mummy Maze Ultimate 1.0")
    GameUI.initialize_ui()
    return screen

def main_menu(screen, clock):
    bg_path = os.path.join(UI_PATH, 'menuback.jpg')
    bg = pygame.image.load(bg_path) if os.path.exists(bg_path) else pygame.Surface((640, 480))

    logo_path = os.path.join(UI_PATH, 'menulogo.png')
    logo = pygame.image.load(logo_path) if os.path.exists(logo_path) else None

    try: pygame.mixer.Sound(os.path.join(SOUNDS_PATH, 'tombslide.wav')).play()
    except: pass

    designer = TextDesigner(size=36)
    anim_progress = 0.0
    
    running = True
    while running:
        mouse_pos = pygame.mouse.get_pos()
        clicked = False
        for event in pygame.event.get():
            if event.type == pygame.QUIT: return "__QUIT__"
            music_manager.handle_event(event)
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: clicked = True

        screen.blit(bg, (0, 0))
        if anim_progress < 1.0: anim_progress += 0.03
        
        if logo:
            logo_y = -100 + (130 * anim_progress) if anim_progress < 1.0 else 30
            screen.blit(logo, (92, int(logo_y)))
        
        # Render Menu
        if anim_progress > 0.8:
            cx = 320; start_y = 200; gap = 55
            
            # 1. CONTINUE
            if storage_manager.has_saved_game():
                if designer.draw_button(screen, "CONTINUE", cx, start_y, mouse_pos, clicked):
                    return "continue_game"
                start_y += gap

            # 2. PLAY RANDOM
            if designer.draw_button(screen, "PLAY RANDOM", cx, start_y, mouse_pos, clicked):
                return "classic_mode"
            
            # 3. CAMPAIGN
            if designer.draw_button(screen, "CAMPAIGN", cx, start_y + gap, mouse_pos, clicked):
                return "campaign_mode"
            
            # 4. LEADERBOARD
            if designer.draw_button(screen, "LEADERBOARD", cx, start_y + gap*2, mouse_pos, clicked):
                return "leaderboard"
            
            # 5. QUIT
            if designer.draw_button(screen, "QUIT", cx, start_y + gap*3, mouse_pos, clicked):
                return "__QUIT__"

        pygame.display.flip()
        clock.tick(fps)
    return "__QUIT__"

==============================
PATH: MummyMaze\api\io\Lightning\gui\Leaderboard.py
==============================

import pygame
import os
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.manager.StorageManager import storage_manager
from api.io.Lightning.utils.ConfigFile import UI_PATH

# Biến lưu trạng thái nội bộ của màn hình Leaderboard (đang xem Level mấy)
_current_view_level = 1

def leaderboard_screen(screen, clock, mouse_pos, clicked):
    global _current_view_level
    
    # 1. Vẽ hình nền
    bg_path = os.path.join(UI_PATH, 'menuback.jpg')
    if os.path.exists(bg_path):
        bg = pygame.image.load(bg_path)
        screen.blit(bg, (0,0))
    else:
        screen.fill((20, 20, 20))
    
    gd = TextDesigner(color=(255, 215, 0)) # Màu vàng kim
    wd = TextDesigner() # Màu trắng mặc định
    
    # 2. Tiêu đề
    gd.render_header("LEADERBOARD", screen, 320, 50)
    
    # 3. Các nút chọn Level (Tab)
    # Vẽ 3 nút LV 1, LV 2, LV 3
    start_x = 160
    for i in range(1, 4):
        x = start_x + (i-1) * 160
        y = 120
        label = f"LV {i}"
        
        # Highlight nút đang chọn
        if _current_view_level == i:
            color = (255, 215, 0)
        else:
            color = (150, 150, 150)
            
        td = TextDesigner(color=color, size=28)
        
        if td.draw_button(screen, label, x, y, mouse_pos, clicked):
            _current_view_level = i

    # 4. Vẽ bảng danh sách điểm (Lấy từ StorageManager)
    data = storage_manager.get_leaderboard_data(_current_view_level)
    
    list_start_y = 180
    
    # Vẽ Header cột
    header_font = TextDesigner(size=24, color=(255, 100, 100))
    # Vẽ tiêu đề cột thủ công để căn chỉnh
    header_font.render_default("RANK", screen, 180, list_start_y)
    header_font.render_default("NAME", screen, 320, list_start_y)
    header_font.render_default("SCORE", screen, 460, list_start_y)
    
    if not data:
        wd.render_default("NO RECORDS YET", screen, 320, 250, color=(200,200,200))
    else:
        # Vẽ từng dòng
        row_font = TextDesigner(size=24)
        for idx, entry in enumerate(data):
            y = list_start_y + 40 + (idx * 35)
            
            rank_str = f"{idx+1}."
            name_str = entry['name'][:10] # Cắt tên nếu quá dài
            score_str = str(entry['score'])
            
            # Tô màu cho Top 3
            row_color = (255, 255, 255)
            if idx == 0: row_color = (255, 215, 0) # Vàng
            elif idx == 1: row_color = (192, 192, 192) # Bạc
            elif idx == 2: row_color = (205, 127, 50) # Đồng
            
            rf = TextDesigner(size=24, color=row_color)
            
            # Vẽ từng cột
            rf.render_default(rank_str, screen, 180, y)
            rf.render_default(name_str, screen, 320, y)
            rf.render_default(score_str, screen, 460, y)

    # 5. Nút Back
    if wd.draw_button(screen, "BACK", 320, 440, mouse_pos, clicked):
        return "BACK"
        
    return "STAY"

==============================
PATH: MummyMaze\api\io\Lightning\gui\LoginScreen.py
==============================

import pygame
import os
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.manager.StorageManager import storage_manager
from api.io.Lightning.utils.ConfigFile import UI_PATH, fps

class InputBox:
    def __init__(self, x, y, w, h, font, text='', is_password=False):
        self.rect = pygame.Rect(x, y, w, h)
        self.color_inactive = (100, 100, 100)
        self.color_active = (255, 215, 0)
        self.color = self.color_inactive
        self.text = text
        self.font = font
        self.is_password = is_password
        self.active = False

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            self.active = self.rect.collidepoint(event.pos)
            self.color = self.color_active if self.active else self.color_inactive
            
        if event.type == pygame.KEYDOWN and self.active:
            if event.key == pygame.K_RETURN:
                return "submit"
            elif event.key == pygame.K_BACKSPACE:
                self.text = self.text[:-1]
            else:
                # CHỈ NHẬN KÝ TỰ CHỮ VÀ SỐ (A-Z, 0-9)
                if len(self.text) < 15 and event.unicode.isalnum():
                    self.text += event.unicode
        return None

    def draw(self, screen):
        disp = "*" * len(self.text) if self.is_password else self.text
        pygame.draw.rect(screen, (30, 30, 40), self.rect)
        pygame.draw.rect(screen, self.color, self.rect, 2)
        surf = self.font.render(disp, True, (255, 255, 255))
        screen.blit(surf, (self.rect.x+5, self.rect.y+5))

def login_screen(screen, clock):
    # Load background
    bg_path = os.path.join(UI_PATH, 'menuback.jpg')
    if os.path.exists(bg_path):
        bg = pygame.image.load(bg_path)
    else:
        bg = pygame.Surface((640, 480)); bg.fill((20, 20, 20))
    
    logo_path = os.path.join(UI_PATH, 'menulogo.png')
    logo = pygame.image.load(logo_path) if os.path.exists(logo_path) else None

    # Font riêng cho Input Box (Arial)
    input_font = pygame.font.SysFont("arial", 24)
    
    # Designer cho UI Text (Style Game)
    designer = TextDesigner(size=28)
    err_designer = TextDesigner(size=24, color=(255, 50, 50))
    
    user_box = InputBox(220, 200, 200, 35, input_font)
    pass_box = InputBox(220, 260, 200, 35, input_font, is_password=True)
    
    msg = ""
    
    while True:
        mouse_pos = pygame.mouse.get_pos()
        events = pygame.event.get()
        submit_action = None

        for event in events:
            if event.type == pygame.QUIT: return "__QUIT__"
            
            if user_box.handle_event(event) == "submit" or pass_box.handle_event(event) == "submit":
                submit_action = "login"

        screen.blit(bg, (0,0))
        if logo: screen.blit(logo, (92, 20))
        
        # Labels
        designer.render_default("USER:", screen, 160, 217)
        designer.render_default("PASS:", screen, 160, 277)
        
        user_box.draw(screen)
        pass_box.draw(screen)
        
        clicked = pygame.mouse.get_pressed()[0]
        
        if designer.draw_button(screen, "LOGIN", 250, 340, mouse_pos, clicked):
            submit_action = "login"
            
        if designer.draw_button(screen, "REGISTER", 390, 340, mouse_pos, clicked):
            submit_action = "register"

        if submit_action:
            u, p = user_box.text, pass_box.text
            if not u or not p:
                msg = "MISSING INFO"
            else:
                if submit_action == "login":
                    res = storage_manager.login(u, p)
                    if res == "success": return "success"
                    msg = res
                else:
                    res = storage_manager.register(u, p, u)
                    if res == "success": return "success"
                    msg = res
            pygame.time.wait(250)

        if msg:
            err_designer.render_default(msg.upper(), screen, 320, 400)

        pygame.display.flip()
        clock.tick(fps)

==============================
PATH: MummyMaze\api\io\Lightning\gui\LoseState.py
==============================

import pygame
import os
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.utils.ConfigFile import UI_PATH, fps
from api.io.Lightning.manager.SoundReader import sfx_manager

def lose_screen(screen, clock):
    sfx_manager.play('mummyhowl')
    
    menuback = pygame.image.load(os.path.join(UI_PATH, 'menuback.jpg'))
    menufront = pygame.image.load(os.path.join(UI_PATH, 'menufront.png'))
    
    designer = TextDesigner(color=(200, 200, 200), hover_color=(255, 50, 50))
    
    # Animation
    menu_y = 480
    target_y = 0
    progress = 0.0
    
    running = True
    while running:
        mouse_pos = pygame.mouse.get_pos()
        clicked = False
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT: return "quit"
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: clicked = True

        # Update Anim
        if progress < 1.0:
            progress += 0.02
            menu_y = 480 * (1 - progress) * (1 - progress) # Ease out
        else:
            menu_y = 0

        screen.blit(menuback, (0, 0))
        screen.blit(menufront, (0, menu_y))
        
        # Chỉ vẽ nút khi bảng hiện lên gần hết
        if progress > 0.8:
            offset_y = menu_y
            
            if designer.draw_button(screen, "TRY AGAIN", 320, 360 + offset_y, mouse_pos, clicked):
                return "retry"
            
            if designer.draw_button(screen, "MAIN MENU", 320, 400 + offset_y, mouse_pos, clicked):
                return "menu"
            
            if designer.draw_button(screen, "QUIT GAME", 320, 440 + offset_y, mouse_pos, clicked):
                return "quit"

        pygame.display.flip()
        clock.tick(fps)
    return "quit"

==============================
PATH: MummyMaze\api\io\Lightning\gui\MapTracker.py
==============================

import pygame, os
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.utils.ConfigFile import UI_PATH

class WorldMapPanel:
    def __init__(self, x=8, y=320):
        # 1. Load Assets
        self.bg_map = pygame.image.load(os.path.join(UI_PATH, 'map.png')).convert_alpha()
        self.label_pyramid = pygame.image.load(os.path.join(UI_PATH, 'pyramidtext.gif')).convert_alpha()
        self.icon_head = pygame.image.load(os.path.join(UI_PATH, 'maphead.png')).convert_alpha()
        self.icon_x = pygame.image.load(os.path.join(UI_PATH, 'mapx.png')).convert_alpha()
        
        # FIX: Dùng TextDesigner thay vì PyramidFont cũ
        self.number_font = TextDesigner(size=18, color=(255, 215, 0)) # Chữ vàng

        self.rect = self.bg_map.get_rect()
        self.rect.topleft = (x, y)

        # 2. Define Pyramid Node Positions
        col_w = 20
        row_h = 15
        bottom_y = 93
        manual_x_offset = -2
        center_x = (self.rect.width // 2) + manual_x_offset
        self.nodes = []

        # Row 1 (Bottom)
        y = bottom_y
        self.nodes.extend([(center_x - col_w*2, y), (center_x - col_w, y), (center_x, y), (center_x + col_w, y), (center_x + col_w*2, y)])
        # Row 2
        y -= row_h
        self.nodes.extend([(center_x - col_w*1.5, y), (center_x - col_w*0.5, y), (center_x + col_w*0.5, y), (center_x + col_w*1.5, y)])
        # Row 3
        y -= row_h
        self.nodes.extend([(center_x - col_w, y), (center_x, y), (center_x + col_w, y)])
        # Row 4
        y -= row_h
        self.nodes.extend([(center_x - col_w*0.5, y), (center_x + col_w*0.5, y)])
        # Row 5 (Top)
        y -= row_h
        self.nodes.append((center_x, y))

    def draw(self, screen, current_level_idx):
        screen.blit(self.bg_map, self.rect.topleft)
        screen.blit(self.label_pyramid, (self.rect.x + 10, self.rect.y + 10))

        # FIX: Render số 1 bằng hàm mới
        pyramid_num_surf = self.number_font.render("1", outline=True)
        screen.blit(pyramid_num_surf, (self.rect.x + 28, self.rect.y + 25))

        for i, (node_x, node_y) in enumerate(self.nodes):
            level_num = i + 1
            draw_pos_x = self.rect.x + node_x
            draw_pos_y = self.rect.y + node_y

            if level_num < current_level_idx:
                dest = (draw_pos_x - self.icon_x.get_width() // 2, draw_pos_y - self.icon_x.get_height() // 2)
                screen.blit(self.icon_x, dest)
            elif level_num == current_level_idx:
                dest = (draw_pos_x - self.icon_head.get_width() // 2, draw_pos_y - self.icon_head.get_height() // 2 - 2)
                screen.blit(self.icon_head, dest)

==============================
PATH: MummyMaze\api\io\Lightning\gui\WinState.py
==============================

import pygame
import os
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.utils.ConfigFile import UI_PATH, fps
from api.io.Lightning.gui import GameUI

def format_time_text(ms):
    total_sec = int(ms / 1000)
    mins = total_sec // 60
    secs = total_sec % 60
    return f"{mins}m {secs}s"

def win_screen(screen, clock, score=0, time_ms=0):
    background = pygame.image.load(os.path.join(UI_PATH, 'nextlevel.jpg')).convert()
    bg_x, bg_y = 152, 5
    bg_width = background.get_width()
    bg_center_x = bg_x + (bg_width // 2)

    designer = TextDesigner()
    gold_designer = TextDesigner(color=(255, 215, 0))

    running = True
    while running:
        mouse_pos = pygame.mouse.get_pos()
        clicked = False

        for event in pygame.event.get():
            if event.type == pygame.QUIT: return "quit"
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: clicked = True
            
            action = GameUI.handle_game_input(event, mouse_pos)
            if action: return action

        hovered = GameUI.get_hover_state(mouse_pos)
        
        # Vẽ nền game
        GameUI.draw_screen(screen, hovered, None)
        # Vẽ overlay thắng
        screen.blit(background, (bg_x, bg_y))

        # Text
        gold_designer.render_header("LEVEL CLEARED!", screen, bg_center_x, bg_y + 50)
        designer.render_label(f"SCORE: {score}", screen, bg_center_x, bg_y + 120)
        designer.render_label(f"TIME: {format_time_text(time_ms)}", screen, bg_center_x, bg_y + 160)

        # Button
        if designer.draw_button(screen, "NEXT LEVEL", bg_center_x, bg_y + 320, mouse_pos, clicked):
            return "next_level"

        pygame.display.flip()
        clock.tick(fps)
    return "quit"

==============================
PATH: MummyMaze\api\io\Lightning\listener\AnimatedListener.py
==============================

import pygame
import os
from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH

class TorchAnimation:
    def __init__(self):
        self.torch_frames = []
        self.torch_glow_frames = []
        self.frame_index = 0
        self.animation_speed = 0.15  # Adjust speed (lower = slower)
        self.animation_counter = 0
        self.loaded = False

    def load(self):
        """Load torch flame and glow animation frames"""
        try:
            # Load single torch image
            torch_image = pygame.image.load(os.path.join(OBJECTS_PATH, 'torch.png')).convert_alpha()

            # Load torch glow strip (10 frames horizontally)
            torch_glow_strip = pygame.image.load(os.path.join(OBJECTS_PATH, 'glow.png')).convert_alpha()

            # Load flame animation strip (10 frames horizontally)
            flame_strip = pygame.image.load(os.path.join(OBJECTS_PATH, 'flame.png')).convert_alpha()

            # Get dimensions
            glow_frame_width = torch_glow_strip.get_width() // 10  # 10 frames
            glow_frame_height = torch_glow_strip.get_height()

            flame_frame_width = flame_strip.get_width() // 10  # 10 frames
            flame_frame_height = flame_strip.get_height()

            print(f"Torch dimensions - Glow: {glow_frame_width}x{glow_frame_height}, "
                  f"Flame:  {flame_frame_width}x{flame_frame_height}, "
                  f"Base: {torch_image.get_width()}x{torch_image.get_height()}")

            # Extract glow frames
            self.torch_glow_frames = []
            for i in range(10):
                frame = torch_glow_strip.subsurface((i * glow_frame_width, 0, glow_frame_width, glow_frame_height))
                self.torch_glow_frames.append(frame.copy())

            # Extract flame frames and combine with torch base
            self.torch_frames = []
            for i in range(10):
                # Calculate combined dimensions
                combined_width = max(torch_image.get_width(), flame_frame_width)
                combined_height = torch_image.get_height() + flame_frame_height

                # Create a surface to hold the complete torch (base + flame)
                torch_complete = pygame.Surface((combined_width, combined_height), pygame.SRCALPHA)

                # Extract flame frame
                flame_frame = flame_strip.subsurface((i * flame_frame_width, 0, flame_frame_width, flame_frame_height))

                # Center the torch base and flame
                torch_x = (combined_width - torch_image.get_width()) // 2
                flame_x = (combined_width - flame_frame_width) // 2

                # Composite:  flame on top, torch base below (with slight overlap)
                torch_complete.blit(flame_frame, (flame_x, 0))  # Flame at top
                torch_complete.blit(torch_image, (torch_x, flame_frame_height - 5))  # Torch base (slight overlap)

                self.torch_frames.append(torch_complete)

            self.loaded = True
            print(
                f"TorchAnimation:  Loaded {len(self.torch_frames)} torch frames and {len(self.torch_glow_frames)} glow frames")

        except Exception as e:
            print(f"Error loading torch animation:  {e}")
            import traceback
            traceback.print_exc()
            # Create dummy frames as fallback
            self.torch_frames = [pygame.Surface((20, 30), pygame.SRCALPHA)]
            self.torch_glow_frames = [pygame.Surface((40, 40), pygame.SRCALPHA)]
            self.loaded = False

    def update(self):
        """Update torch animation frame"""
        if not self.loaded:
            return

        self.animation_counter += self.animation_speed

        if self.animation_counter >= 1.0:
            self.animation_counter = 0
            self.frame_index = (self.frame_index + 1) % len(self.torch_frames)

    def draw(self, screen, x, y):
        """Draw an animated torch with glow at position (x, y)"""
        if not self.loaded or not self.torch_frames or not self.torch_glow_frames:
            return

        glow = self.torch_glow_frames[self.frame_index]
        torch = self.torch_frames[self.frame_index]

        # Calculate torch center point
        torch_center_x = x + (torch.get_width() // 2)
        torch_flame_y = y + 10  # Position on the flame area

        # Center glow on the torch's flame
        glow_x = torch_center_x - (glow.get_width() // 2)
        glow_y = torch_flame_y - (glow.get_height() // 2)

        # Draw glow first (behind torch)
        screen.blit(glow, (glow_x, glow_y))

        # Draw torch with flame on top
        screen.blit(torch, (x, y))

    def set_speed(self, speed):
        """Set animation speed"""
        self.animation_speed = speed

# Global torch animation instance
torch_animation = None

def initialize_torch_animation():
    """Initialize torch animation"""
    global torch_animation
    if torch_animation is None:
        torch_animation = TorchAnimation()
        torch_animation.load()
    return torch_animation

def get_torch_animation():
    """Get torch animation instance"""
    return torch_animation

==============================
PATH: MummyMaze\api\io\Lightning\listener\DirectionListener.py
==============================

import pygame
import os

from api.io.Lightning.manager.Spritesheet import Spritesheet
from api.io.Lightning.utils.ConfigFile import UI_PATH

class Direction:
    def __init__(self, maze_size):
        self.spritesheet = Spritesheet(os.path.join(UI_PATH, f"arrows{maze_size}.gif"))
        self.circle = pygame.image.load(os.path.join(UI_PATH, f"circle{maze_size}.gif")).convert_alpha()
        self.animations = []
        self.move_images = {}

    def load_move_images(self, maze_size):
        w = self.spritesheet.sheet.get_width()
        h = self.spritesheet.sheet.get_height() // 4

        self.move_images = {
            'DOWN': self.spritesheet.get_image(0, 0, w, h),
            'RIGHT': self.spritesheet.get_image(0, h, w, h),
            'LEFT': self.spritesheet.get_image(0, h * 2, w, h),
            'UP': self.spritesheet.get_image(0, h * 3, w, h),
            'STAY': self.circle
        }

==============================
PATH: MummyMaze\api\io\Lightning\listener\GameState.py
==============================

import pygame

class GameState:
    def __init__(self):
        pygame.init()


==============================
PATH: MummyMaze\api\io\Lightning\listener\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\manager\ButtonManager.py
==============================

import pygame
import os
from api.io.Lightning.utils.ConfigFile import UI_PATH
from api.io.Lightning.manager.Spritesheet import Spritesheet

class ButtonManager:
    def __init__(self):
        # Load sprite nút bấm
        buttonstrip_path = os.path.join(UI_PATH, 'buttonstrip.jpg')
        if not os.path.exists(buttonstrip_path):
            print(f"Warning: Missing buttonstrip at {buttonstrip_path}")
            self.buttons = {}
            self.button_rects = {}
            return

        spritesheet = Spritesheet(buttonstrip_path)
        button_width = 135
        button_height = 42

        # Cắt ảnh từ spritesheet
        self.buttons = {
            'undo_move_hover': spritesheet.get_image(0, 0 * button_height, button_width, button_height),
            'undo_move_clicked': spritesheet.get_image(0, 1 * button_height, button_width, button_height),
            'reset_maze_hover': spritesheet.get_image(0, 2 * button_height, button_width, button_height),
            'reset_maze_clicked':  spritesheet.get_image(0, 3 * button_height, button_width, button_height),
            'options_hover': spritesheet.get_image(0, 4 * button_height, button_width, button_height),
            'options_clicked': spritesheet.get_image(0, 5 * button_height, button_width, button_height),
            'world_map_disabled': spritesheet.get_image(0, 8 * button_height, button_width, button_height),
            'quit_to_main_hover': spritesheet.get_image(0, 9 * button_height, button_width, button_height),
            'quit_to_main_clicked': spritesheet.get_image(0, 10 * button_height, button_width, button_height),
        }

        # Định nghĩa vùng bấm (Hitbox)
        self.button_rects = {
            'undo': pygame.Rect(8, 130, button_width, button_height),
            'reset': pygame.Rect(8, 172, button_width, button_height),
            'option': pygame.Rect(8, 225, button_width, button_height),
            'quit': pygame.Rect(8, 430, button_width, button_height),
        }
        self.clicked_button = None

    def set_clicked(self, button_name):
        self.clicked_button = button_name

    def clear_clicked(self):
        self.clicked_button = None

    def draw_buttons(self, screen, hovered=None, clicked=None):
        if not self.buttons: return

        # Helper vẽ nút
        def draw(name, rect_key, y):
            if clicked == rect_key:
                screen.blit(self.buttons[f'{name}_clicked'], (8, y))
            elif hovered == rect_key:
                screen.blit(self.buttons[f'{name}_hover'], (8, y))

        draw('undo_move', 'undo', 130)
        draw('reset_maze', 'reset', 172)
        draw('options', 'option', 225)
        
        # World map luôn hiển thị disabled (do chưa làm map)
        screen.blit(self.buttons['world_map_disabled'], (8, 267))
        
        draw('quit_to_main', 'quit', 430)

==============================
PATH: MummyMaze\api\io\Lightning\manager\GameManager.py
==============================

from api.io.Lightning.maze.MazeGenerator import MazeBuilder
from api.io.Lightning.utils.ConfigFile import *

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((640, 480))
        self.clock = pygame.time.Clock()

        pygame.display.set_caption("Mummy Maze Ultimate 1.0")
        icon = pygame.image.load(os.path.join(UI_PATH, 'game.ico'))
        pygame.display.set_icon(icon)

        self.maze = MazeBuilder('none')
        cell_size = self.maze.cell_size

    def run_game(self):
        while self.running:
            self.events()
            self.update()
            self.draw()

            self.clock.tick(fps)
        pygame.quit()

==============================
PATH: MummyMaze\api\io\Lightning\manager\SoundReader.py
==============================

import random
import pygame, os
from api.io.Lightning.utils.ConfigFile import MUSIC_PATH, SOUNDS_PATH

class MusicManager:
    def __init__(self):
        self.music_enabled = False
        self.current_track = 0
        self.loop_tracks = list(range(1, 13))
        self.current_loop_index = 0
        self.MUSIC_END = pygame.USEREVENT + 1
        self.initialized = False
        self.current_mode = "menu"
        self.volume = 0.5

    def initialize(self):
        if self.initialized: return
        try:
            if not pygame.mixer.get_init(): pygame.mixer.init()
            pygame.mixer.music.set_volume(self.volume)
            # Nhạc khởi đầu
            self._play_track("00.mp3")
            pygame.mixer.music.set_endevent(self.MUSIC_END)
            self.music_enabled = True
            self.initialized = True
        except Exception as e:
            print(f'Music Init Error: {e}')

    def set_volume(self, vol):
        self.volume = max(0.0, min(1.0, vol))
        if self.initialized:
            pygame.mixer.music.set_volume(self.volume)

    def get_volume(self):
        return self.volume

    def handle_event(self, event):
        """Tự động chuyển bài khi hết nhạc"""
        if event.type == self.MUSIC_END and self.music_enabled:
            try:
                if self.current_mode == "menu":
                    if self.current_track == 0:
                        self.current_track = self.loop_tracks[self.current_loop_index]
                    else:
                        self.current_loop_index = (self.current_loop_index + 1) % len(self.loop_tracks)
                        self.current_track = self.loop_tracks[self.current_loop_index]
                    self._play_track(f'{self.current_track:02d}.mp3')

                elif self.current_mode == "classic":
                    self.current_loop_index = (self.current_loop_index + 1) % len(self.loop_tracks)
                    self.current_track = self.loop_tracks[self.current_loop_index]
                    self._play_track(f'{self.current_track:02d}.mp3')

                elif self.current_mode == "hard":
                    self._play_track("hard_mode.mp3")

            except Exception as e:
                print(f'Music Loop Error: {e}')

    def _play_track(self, filename):
        path = os.path.join(MUSIC_PATH, filename)
        if os.path.exists(path):
            pygame.mixer.music.load(path)
            pygame.mixer.music.play()

    def start_classic_mode_music(self):
        self.current_mode = "classic"
        self.loop_tracks = list(range(23, 39))
        self.current_loop_index = 0
        self.current_track = self.loop_tracks[0]
        self._play_track(f'{self.current_track:02d}.mp3')

    def start_menu_music(self):
        self.current_mode = "menu"
        self.loop_tracks = list(range(1, 13))
        self.current_loop_index = 0
        self.current_track = self.loop_tracks[0]
        self._play_track(f'{self.current_track:02d}.mp3')

    def start_hard_mode_music(self):
        self.current_mode = "hard"
        self._play_track("hard_mode.mp3")

class SoundEffectManager:
    def __init__(self):
        self.sounds = {}
        self.initialized = False
        self.volume = 0.5

    def initialize(self):
        if self.initialized: return
        if not pygame.mixer.get_init(): pygame.mixer.init()

        def load(name):
            path = os.path.join(SOUNDS_PATH, name)
            if os.path.exists(path):
                snd = pygame.mixer.Sound(path)
                snd.set_volume(self.volume)
                return snd
            return None

        # Load âm thanh bước chân
        for variant in ['15', '30', '60']:
            self.sounds[f'exp_start_{variant}'] = load(f'expwalk{variant}a.wav')
            self.sounds[f'exp_end_{variant}'] = load(f'expwalk{variant}b.wav')
            self.sounds[f'mum_start_{variant}'] = load(f'mumwalk{variant}a.wav')
            self.sounds[f'mum_end_{variant}'] = load(f'mumwalk{variant}b.wav')

        self.sounds['scorp_1'] = load('scorpwalk1.wav')
        self.sounds['scorp_2'] = load('scorpwalk2.wav')

        # Load hiệu ứng hành động
        self.sounds['pummel'] = load('pummel.wav')
        self.sounds['tombslide'] = load('tombslide.wav')
        self.sounds['gate'] = load('gate.wav')
        self.sounds['block'] = load('block.wav') # Tiếng bẫy rơi
        self.sounds['badankh'] = load('badankh.wav')
        self.sounds['mummyhowl'] = load('mummyhowl.wav')
        self.sounds['poison'] = load('poison.wav')

        self.initialized = True

    def set_volume(self, vol):
        self.volume = max(0.0, min(1.0, vol))
        if self.initialized:
            for sound in self.sounds.values():
                if sound: sound.set_volume(self.volume)

    def get_volume(self):
        return self.volume

    def play(self, name):
        if name in self.sounds and self.sounds[name]:
            self.sounds[name].play()

    def play_walk_start(self, entity_type):
        variant = random.choice(['15', '30', '60'])
        if entity_type == 'player':
            self.play(f'exp_start_{variant}')
        elif 'mummy' in entity_type:
            self.play(f'mum_start_{variant}')
        elif 'scorpion' in entity_type:
            scorp_var = random.choice(['1', '2'])
            self.play(f'scorp_{scorp_var}')
            return None
        return variant

    def play_walk_end(self, entity_type, variant):
        if not variant: return
        if entity_type == 'player':
            self.play(f'exp_end_{variant}')
        elif 'mummy' in entity_type:
            self.play(f'mum_end_{variant}')

music_manager = MusicManager()
sfx_manager = SoundEffectManager()

==============================
PATH: MummyMaze\api\io\Lightning\manager\Spritesheet.py
==============================

import pygame

class Spritesheet:
    def __init__(self, filepath):
        self.sheet = pygame.image.load(filepath).convert_alpha()  # alpha dùng để xử lý vùng trong suốt

    def get_image(self, x, y, width, height):  # (left, top, width, height)
        image = pygame.Surface((width, height), pygame.SRCALPHA)  # flag đảm bảo surface này hỗ trợ độ trong suốt
        image.blit(self.sheet, (0, 0), (x, y, width, height))
        return image

==============================
PATH: MummyMaze\api\io\Lightning\manager\StorageManager.py
==============================

import json
import hashlib
import os
from api.io.Lightning.utils.ConfigFile import PROJECT_PATH

class UserProfile:
    def __init__(self, username, display_name="", data=None):
        self.username = username
        self.display_name = display_name
        self.password_hash = ""
        # Default user data
        self.data = data or {
            "unlocked_levels": [1], 
            "best_scores": {},      # key: level_id (str), value: score (int)
            "options": {"music_on": True, "sfx_on": True, "language": "en"},
            "saved_game": None
        }

    def to_dict(self):
        return {
            "username": self.username,
            "display_name": self.display_name,
            "password_hash": self.password_hash,
            "data": self.data
        }

    @staticmethod
    def from_dict(d):
        # Create object from dictionary
        p = UserProfile(d.get("username", "guest"), d.get("display_name", "Guest"), d.get("data"))
        p.password_hash = d.get("password_hash", "")
        return p

class StorageManager:
    def __init__(self):
        # Set absolute paths
        self.data_dir = os.path.join(PROJECT_PATH, "data")
        self.save_dir = os.path.join(self.data_dir, "saves")
        self.profiles_path = os.path.join(self.data_dir, "profiles.json")
        
        self.current_user = None
        self._ensure_paths()

    def _ensure_paths(self):
        """Create necessary directories and files if they don't exist"""
        if not os.path.exists(self.data_dir): os.makedirs(self.data_dir)
        if not os.path.exists(self.save_dir): os.makedirs(self.save_dir)
        
        if not os.path.exists(self.profiles_path):
            with open(self.profiles_path, 'w') as f: json.dump({}, f)

    def _hash_password(self, password):
        return hashlib.sha256(password.encode()).hexdigest()

    def _load_all_profiles(self):
        try:
            with open(self.profiles_path, 'r') as f: return json.load(f)
        except: return {}

    def _save_all_profiles(self, profiles_data):
        try:
            with open(self.profiles_path, 'w') as f: json.dump(profiles_data, f, indent=4)
        except Exception as e: print(f"Save Error: {e}")

    def login(self, username, password):
        profiles = self._load_all_profiles()
        if username not in profiles: return "User not found"
        
        user_data = profiles[username]
        # Check password
        if user_data.get("password_hash") != self._hash_password(password):
            return "Wrong password"

        self.current_user = UserProfile.from_dict(user_data)
        return "success"

    def register(self, username, password, display_name):
        if not username or not password: return "Empty fields"
        profiles = self._load_all_profiles()
        if username in profiles: return "Username exists"
        
        # Create new user
        new_user = UserProfile(username, display_name)
        new_user.password_hash = self._hash_password(password)
        
        # Save to DB
        profiles[username] = new_user.to_dict()
        self._save_all_profiles(profiles)
        
        self.current_user = new_user
        return "success"

    def save_current_user_progress(self):
        """Save current user data (unlocks, scores, saves)"""
        if not self.current_user: return
        profiles = self._load_all_profiles()
        profiles[self.current_user.username] = self.current_user.to_dict()
        self._save_all_profiles(profiles)

    def unlock_level(self, level_num):
        if not self.current_user: return
        if level_num not in self.current_user.data["unlocked_levels"]:
            self.current_user.data["unlocked_levels"].append(level_num)
            self.current_user.data["unlocked_levels"].sort()
            self.save_current_user_progress()

    def update_high_score(self, level_id, score):
        if not self.current_user: return
        lid = str(level_id)
        current = self.current_user.data["best_scores"].get(lid, 0)
        if score > current:
            self.current_user.data["best_scores"][lid] = score
            self.save_current_user_progress()

    def save_game_state(self, game_state_dict):
        if not self.current_user: return False
        self.current_user.data["saved_game"] = game_state_dict
        self.save_current_user_progress()
        return True

    def load_game_state(self):
        if not self.current_user: return None
        return self.current_user.data.get("saved_game")

    def has_saved_game(self):
        if not self.current_user: return False
        return self.current_user.data.get("saved_game") is not None

    def get_leaderboard_data(self, level_id, limit=5):
        """Retrieve top high scores for a specific level"""
        profiles = self._load_all_profiles()
        lid = str(level_id)
        ranking = []
        
        for username, p_data in profiles.items():
            if not isinstance(p_data, dict): continue
            
            dname = p_data.get("display_name", username)
            user_data = p_data.get("data", {})
            if not user_data: continue

            scores = user_data.get("best_scores", {})
            if not scores: continue

            score = scores.get(lid, 0)
            
            if score > 0:
                ranking.append({"name": dname, "score": score})
        
        # Sort descending by score
        ranking.sort(key=lambda x: x["score"], reverse=True)
        return ranking[:limit]

# Global instance
storage_manager = StorageManager()

==============================
PATH: MummyMaze\api\io\Lightning\manager\TextDesigner.py
==============================

import pygame

class TextDesigner:
    def __init__(self, font_name="arial", size=28, color=(255, 255, 255), hover_color=(255, 255, 0)):
        # Sử dụng font hệ thống đậm để dễ đọc và hỗ trợ nhiều ký tự
        self.base_font = pygame.font.SysFont(font_name, size, bold=True)
        # Font cho tiêu đề lớn hơn
        self.header_font = pygame.font.SysFont(font_name, int(size * 1.5), bold=True)
        self.color = color
        self.hover_color = hover_color

    def _create_text_surface(self, text, font, color, outline=True):
        """Tạo text có viền đen (Outline) để nổi bật trên nền game"""
        txt_surf = font.render(str(text), True, color)
        if not outline:
            return txt_surf
        
        # Tạo viền đen bằng cách vẽ text đen ở 8 hướng xung quanh
        outline_surf = font.render(str(text), True, (0, 0, 0))
        w = txt_surf.get_width() + 4
        h = txt_surf.get_height() + 4
        final_surf = pygame.Surface((w, h), pygame.SRCALPHA)
        
        # Vẽ viền
        for dx in range(3):
            for dy in range(3):
                if dx == 1 and dy == 1: continue
                final_surf.blit(outline_surf, (dx, dy))
        
        # Vẽ chữ chính đè lên tâm
        final_surf.blit(txt_surf, (1, 1))
        return final_surf

    def render_header(self, text, surface, x, y):
        """Vẽ tiêu đề lớn màu vàng kim loại"""
        gold = (255, 215, 0)
        surf = self._create_text_surface(text, self.header_font, gold)
        rect = surf.get_rect(center=(x, y))
        surface.blit(surf, rect)

    def render_default(self, text, surface, x, y, color=None):
        """Vẽ nhãn thông thường"""
        c = color if color else self.color
        surf = self._create_text_surface(text, self.base_font, c)
        rect = surf.get_rect(center=(x, y))
        surface.blit(surf, rect)

    def render_label(self, text, surface, x, y, color=None):
        """Alias cho render_default"""
        self.render_default(text, surface, x, y, color)

    # Hàm render trả về surface (cho MapTracker/WinState dùng)
    def render(self, text, color=None, outline=True, hovered=False, outline_thickness=None):
        c = self.hover_color if hovered else (color if color else self.color)
        return self._create_text_surface(text, self.base_font, c, outline)

    def draw_button(self, surface, text, x, y, mouse_pos, clicked=False):
        """Vẽ nút bấm tương tác (đổi màu khi hover)"""
        # Tính toán rect dựa trên text mẫu
        temp_surf = self.base_font.render(str(text), True, self.color)
        rect = temp_surf.get_rect(center=(x, y))
        
        is_hovered = rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hovered else self.color
        
        final_surf = self._create_text_surface(text, self.base_font, color)
        # Cập nhật lại rect do surface có viền lớn hơn
        draw_rect = final_surf.get_rect(center=(x, y))
        
        surface.blit(final_surf, draw_rect)
        
        if is_hovered:
            pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
            return clicked
        return False

==============================
PATH: MummyMaze\api\io\Lightning\manager\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\maze\LevelSelector.py
==============================

import random

class LevelSystem:
    def __init__(self):
        self.max_levels = 15
        self.current_level_num = 1
        self.level_difficulties = {}
        self.generate_pyramid_structure()

    def generate_pyramid_structure(self):
        """Tính toán độ khó cho 15 tầng tháp"""
        self.level_difficulties.clear()
        options = ['easy', 'medium', 'hard']
        weights = [0.3, 0.5, 0.2]

        for level in range(1, self.max_levels + 1):
            if level <= 3:
                self.level_difficulties[level] = 'normal'
            elif level == 15:
                self.level_difficulties[level] = 'hard'
            else:
                diff = random.choices(options, weights=weights, k=1)[0]
                self.level_difficulties[level] = diff

    def get_current_difficulty(self):
        return self.level_difficulties.get(self.current_level_num, 'medium')

    def next_level(self):
        if self.current_level_num < self.max_levels:
            self.current_level_num += 1
            return True
        return False

    def get_current_level(self):
        return self.current_level_num

    def reset_progress(self):
        self.current_level_num = 1
        self.generate_pyramid_structure()

==============================
PATH: MummyMaze\api\io\Lightning\maze\MazeGenerator.py
==============================

import random
from collections import deque
from api.io.Lightning.entities.Enemy import EnemyAI
import api.io.Lightning.utils.ConfigFile as cf

class SimGate:
    def __init__(self, x, y, is_open):
        self.grid_x = x
        self.grid_y = y
        self.open = is_open
    def is_blocking(self):
        return not self.open

class MazeGenerator:
    def __init__(self):
        self.min_loops = 0

    def generate_level(self, difficulty, maze_size=None):
        config = self._get_config(difficulty)
        if maze_size:
            try:
                config['size'] = int(maze_size)
            except:
                pass
        
        size = config['size']
        attempts = 0
        max_attempts = 10 
        
        while attempts < max_attempts:
            attempts += 1
            walls_layout = self._generate_layout(size)
            self._braid_maze(walls_layout, size, config['braid_factor'])
            raw_walls = self._get_raw_walls(walls_layout, size)
            pruned = self._smart_prune_walls(raw_walls, size, config['wall_density'])
            
            level_data = self._place_entities(size, pruned, config)
            if not level_data:
                continue
            
            level_data['walls'] = self._merge_walls(level_data['walls'])
            
            if self._is_level_solvable(level_data, size):
                print(f"[Info] Map generated successfully (Size {size}, Diff {difficulty})")
                return level_data

        print(f"[Warning] Generator timed out. Using Fallback map.")
        return self._generate_fallback_level(size, difficulty)

    def _get_config(self, difficulty):
        if difficulty == 'easy':
            return {
                'size': 6,
                'min_enemies': 1,
                'max_enemies': 2,
                'enemy_pool': ['white_mummy', 'red_mummy', 'scorpion'],
                'traps': 0,
                'use_key_gate': False,
                'braid_factor': 0.1,
                'wall_density': 0.6,
                'difficulty_str': 'easy'
            }
        elif difficulty == 'hard':
            return {
                'size': 10,
                'min_enemies': 2,
                'max_enemies': 3,
                'enemy_pool': ['white_mummy', 'red_mummy', 'scorpion', 'red_scorpion'],
                'traps': 2,
                'use_key_gate': True,
                'braid_factor': 0.5,
                'wall_density': 0.55,
                'difficulty_str': 'hard'
            }
        
        # Medium config
        return {
            'size': 8,
            'min_enemies': 2,
            'max_enemies': 3,
            'enemy_pool': ['white_mummy', 'red_mummy', 'scorpion'],
            'traps': 1,
            'use_key_gate': True,
            'braid_factor': 0.3,
            'wall_density': 0.6,
            'difficulty_str': 'medium'
        }

    def _generate_fallback_level(self, size, difficulty):
        walls = []
        for i in range(size):
            walls.append({'x':i, 'y':-1, 'dir':'horizontal'})
        
        enemies = [{'type': 'white_mummy', 'x': size-1, 'y': 0}]
        
        return {
            "difficulty": "fallback", "mazeType": str(size), "maze_size": size,
            "player": {'x': 0, 'y': 0, 'direction': 'down'}, "exit": {'x': size-1, 'y': size-1},
            "enemies": enemies, "traps": [], "walls": walls, "key": None, "gate": None
        }

    def _place_entities(self, size, walls, config):
        occupied = set()
        
        # Exit placement
        side = random.randint(0, 3)
        if side == 0: exit_pos = {'x': random.randint(0, size - 1), 'y': -1} # Top
        elif side == 1: exit_pos = {'x': random.randint(0, size - 1), 'y': size} # Bottom
        elif side == 2: exit_pos = {'x': -1, 'y': random.randint(0, size - 1)} # Left
        else: exit_pos = {'x': size, 'y': random.randint(0, size - 1)} # Right

        win_x, win_y = self._exit_to_win_cell(exit_pos, size)
        occupied.add((win_x, win_y))

        # Player placement
        player_pos = None
        best_p_dist = -1
        
        start_candidates = []
        for _ in range(20):
            rx, ry = random.randint(0, size-1), random.randint(0, size-1)
            if (rx, ry) not in occupied:
                start_candidates.append((rx, ry))
        
        if not start_candidates:
            start_candidates = [(0,0)]

        for (px, py) in start_candidates:
            dist = self._get_path_distance((px, py), (win_x, win_y), walls, size)
            if dist > best_p_dist:
                best_p_dist = dist
                player_pos = {'x': px, 'y': py, 'direction': 'down'}
        
        if not player_pos: return None
        occupied.add((player_pos['x'], player_pos['y']))

        # Enemy placement
        enemies = []
        count = random.randint(config['min_enemies'], config['max_enemies'])
        
        safe_dist_base = 3 if size <= 6 else 5

        for _ in range(count):
            e_type = random.choice(config.get('enemy_pool', ['white_mummy']))
            best_e_pos = None
            max_tries = 30
            current_safe_dist = safe_dist_base

            while max_tries > 0:
                ex, ey = random.randint(0, size-1), random.randint(0, size-1)
                if (ex, ey) in occupied:
                    max_tries -= 1
                    continue
                
                dist_to_player = self._get_path_distance((ex, ey), (player_pos['x'], player_pos['y']), walls, size)
                
                if dist_to_player >= current_safe_dist:
                    best_e_pos = {'type': e_type, 'x': ex, 'y': ey}
                    break
                
                max_tries -= 1
                if max_tries % 10 == 0 and current_safe_dist > 2:
                    current_safe_dist -= 1
            
            if best_e_pos:
                enemies.append(best_e_pos)
                occupied.add((best_e_pos['x'], best_e_pos['y']))

        # Key and Gate
        key_data = None
        gate_data = None
        if config.get('use_key_gate'):
            start = (player_pos['x'], player_pos['y'])
            target = (win_x, win_y)
            base_path = self._find_path_cells(start, target, walls, size)
            candidates = []
            if base_path and len(base_path) >= 5:
                for i in range(2, len(base_path) - 2):
                    ax, ay = base_path[i - 1]
                    bx, by = base_path[i]
                    if ax == bx and abs(ay - by) == 1:
                        gx = ax
                        gy = max(ay, by)
                        if 1 <= gy <= size - 1:
                            if not self._check_wall(ax, ay, bx, by, walls):
                                candidates.append((gx, gy))
            
            if candidates:
                random.shuffle(candidates)
                gx, gy = candidates[0]
                gate_data = {'x': gx, 'y': gy}
                reachable = self._reachable_set(start, walls, size, gate_info=(gx, gy), gate_open=False)
                key_cands = [p for p in reachable if p not in occupied and p != start]
                if key_cands:
                    kx, ky = random.choice(key_cands)
                    key_data = {'x': kx, 'y': ky}
                    occupied.add((kx, ky))
                else:
                    gate_data = None

        # Traps
        traps = []
        for _ in range(config.get('traps', 0)):
            for _ in range(10):
                tx, ty = random.randint(0, size - 1), random.randint(0, size - 1)
                if (tx, ty) not in occupied:
                    traps.append({'x': tx, 'y': ty})
                    occupied.add((tx, ty))
                    break

        return {
            "difficulty": config['difficulty_str'],
            "mazeType": str(size),
            "maze_size": size,
            "player": player_pos,
            "exit": exit_pos,
            "enemies": enemies,
            "traps": traps,
            "walls": walls,
            "key": key_data,
            "gate": gate_data
        }

    # --- Pathfinding Helpers ---
    def _is_level_solvable(self, level, size):
        try:
            start = (int(level['player']['x']), int(level['player']['y']))
            wx, wy = self._exit_to_win_cell(level['exit'], size)
            target = (wx, wy)
        except: return None
        
        walls = level['walls']
        enemies = level['enemies']
        
        gate_info = (int(level['gate']['x']), int(level['gate']['y'])) if level['gate'] else None
        key_pos = (int(level['key']['x']), int(level['key']['y'])) if level['key'] else None
        
        traps = set()
        for t in level['traps']:
            traps.add((int(t['x']), int(t['y'])))
            
        if start in traps or target in traps: return None
        
        ai = EnemyAI(size, walls, gate=None)
        start_state = (start[0], start[1], (gate_info is None), tuple((e['x'], e['y']) for e in enemies))
        q = deque([start_state])
        visited = {start_state}
        
        steps = 0
        while q:
            steps += 1
            if steps > 2500: return None 
            
            curr = q.popleft()
            px, py, g_open, e_pos = curr
            if (px, py) == target: return True
            
            for dx, dy in [(0,0), (0,1), (0,-1), (1,0), (-1,0)]:
                nx, ny = px+dx, py+dy
                
                if not (0<=nx<size and 0<=ny<size): continue
                if (nx, ny) in traps: continue
                if self._check_wall(px, py, nx, ny, walls): continue
                if gate_info and not g_open and self._gate_blocks(px, py, nx, ny, gate_info, False): continue
                if (nx, ny) in e_pos: continue
                
                n_g_open = g_open
                if not g_open and key_pos and (nx, ny) == key_pos: n_g_open = True
                
                ai.gate = SimGate(gate_info[0], gate_info[1], n_g_open) if gate_info else None
                next_e_pos = []
                dead = False
                
                for i, ep in enumerate(e_pos):
                    sim_enemy = {'type': enemies[i]['type'], 'pos': [ep[0], ep[1]]}
                    path = ai.get_move_path(sim_enemy, [nx, ny], difficulty='medium')
                    
                    final_ep = path[-1] if path else list(ep)
                    if final_ep[0] == nx and final_ep[1] == ny: dead = True
                    next_e_pos.append(tuple(final_ep))
                
                if dead: continue
                
                next_state = (nx, ny, n_g_open, tuple(next_e_pos))
                if next_state not in visited:
                    visited.add(next_state)
                    q.append(next_state)
        return None

    def _generate_layout(self, size):
        grid = [[set() for _ in range(size)] for _ in range(size)]
        stack = [(0, 0)]
        visited = {(0, 0)}
        while stack:
            cx, cy = stack[-1]
            neighbors = []
            for dx, dy, d, opp in [(0, -1, 'N', 'S'), (0, 1, 'S', 'N'), (-1, 0, 'W', 'E'), (1, 0, 'E', 'W')]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size and (nx, ny) not in visited:
                    neighbors.append((nx, ny, d, opp))
            if neighbors:
                nx, ny, d, opp = random.choice(neighbors)
                grid[cx][cy].add(d); grid[nx][ny].add(opp)
                visited.add((nx, ny)); stack.append((nx, ny))
            else: stack.pop()
        return grid

    def _braid_maze(self, grid, size, factor):
        dead_ends = [(x, y) for x in range(size) for y in range(size) if len(grid[x][y]) == 1]
        random.shuffle(dead_ends)
        for i in range(int(len(dead_ends) * factor)):
            cx, cy = dead_ends[i]
            neighbors = []
            for dx, dy, d, opp in [(0, -1, 'N', 'S'), (0, 1, 'S', 'N'), (-1, 0, 'W', 'E'), (1, 0, 'E', 'W')]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size and d not in grid[cx][cy]:
                    neighbors.append((nx, ny, d, opp))
            if neighbors:
                nx, ny, d, opp = random.choice(neighbors)
                grid[cx][cy].add(d); grid[nx][ny].add(opp)

    def _get_raw_walls(self, grid, size):
        walls = []
        for x in range(size):
            for y in range(size):
                if 'N' not in grid[x][y]: walls.append({'x': x, 'y': y, 'dir': 'horizontal'})
                if 'W' not in grid[x][y]: walls.append({'x': x, 'y': y, 'dir': 'vertical'})
        return walls

    def _smart_prune_walls(self, walls, size, density):
        target = int((size * size) * density)
        if len(walls) <= target: return walls
        walls_copy = walls.copy()
        random.shuffle(walls_copy)
        removed = 0
        to_remove = len(walls) - target
        for w in walls_copy:
            if removed >= to_remove: break
            test = [x for x in walls if x != w]
            if self._is_maze_connected(test, size):
                walls.remove(w)
                removed += 1
        return walls

    def _is_maze_connected(self, walls, size):
        visited = {(0,0)}
        q = deque([(0,0)])
        while q:
            cx, cy = q.popleft()
            for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:
                nx, ny = cx+dx, cy+dy
                if 0<=nx<size and 0<=ny<size and (nx,ny) not in visited:
                    if not self._check_wall(cx, cy, nx, ny, walls):
                        visited.add((nx,ny))
                        q.append((nx,ny))
        return len(visited) == size * size

    def _merge_walls(self, walls):
        merged = {}
        for w in walls:
            key = (w['x'], w['y'])
            if key not in merged: merged[key] = w['dir']
            else: merged[key] = 'both'
        return [{'x': x, 'y': y, 'dir': d} for (x, y), d in merged.items()]

    def _exit_to_win_cell(self, exit_pos, size):
        if not exit_pos: return 0, 0
        ex, ey = int(exit_pos['x']), int(exit_pos['y'])
        return max(0, min(size - 1, ex)), max(0, min(size - 1, ey))

    def _reachable_set(self, start, walls, size, gate_info=None, gate_open=True):
        visited = {start}
        q = deque([start])
        while q:
            cx, cy = q.popleft()
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size:
                    if (nx, ny) not in visited:
                        if not self._check_wall(cx, cy, nx, ny, walls) and \
                           not self._gate_blocks(cx, cy, nx, ny, gate_info, gate_open):
                            visited.add((nx, ny))
                            q.append((nx, ny))
        return visited

    def _find_path_cells(self, start, end, walls, size):
        q = deque([start])
        parent = {start: None}
        while q:
            curr = q.popleft()
            if curr == end:
                path = []
                while curr:
                    path.append(curr)
                    curr = parent[curr]
                return path[::-1]
            cx, cy = curr
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < size and 0 <= ny < size and (nx, ny) not in parent:
                    if not self._check_wall(cx, cy, nx, ny, walls):
                        parent[(nx, ny)] = curr
                        q.append((nx, ny))
        return None

    def _check_wall(self, x1, y1, x2, y2, walls):
        if x2 > x1: check = (x2, y2, 'vertical')
        elif x2 < x1: check = (x1, y1, 'vertical')
        elif y2 > y1: check = (x2, y2, 'horizontal')
        elif y2 < y1: check = (x1, y1, 'horizontal')
        else: return False
        
        for w in walls:
            if w['x'] == check[0] and w['y'] == check[1] and w['dir'] in [check[2], 'both']:
                return True
        return False

    def _get_path_distance(self, start, end, walls, size):
        q = deque([(start[0], start[1], 0)])
        visited = {start}
        while q:
            cx, cy, d = q.popleft()
            if (cx, cy) == end: return d
            for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:
                nx, ny = cx+dx, cy+dy
                if 0<=nx<size and 0<=ny<size and (nx,ny) not in visited:
                    if not self._check_wall(cx, cy, nx, ny, walls):
                        visited.add((nx,ny))
                        q.append((nx, ny, d+1))
        return -1

    def _gate_blocks(self, fx, fy, tx, ty, gate_info, gate_open):
        if not gate_info or gate_open: return False
        gx, gy = gate_info
        return ((fx == gx and fy == gy - 1 and tx == gx and ty == gy) or
                (fx == gx and fy == gy and tx == gx and ty == gy - 1))

==============================
PATH: MummyMaze\api\io\Lightning\maze\MazeLoader.py
==============================

import os
import json
import pygame
import random
import math
from collections import deque

from api.io.Lightning.manager.SoundReader import sfx_manager
from api.io.Lightning.manager.Spritesheet import Spritesheet
from api.io.Lightning.maze.MazeGenerator import MazeGenerator
from api.io.Lightning.utils.ConfigFile import LEVELS_PATH, UI_PATH, OBJECTS_PATH, maze_coord_x, maze_coord_y
from api.io.Lightning.objects.Key import Key
from api.io.Lightning.objects.Gate import Gate
from api.io.Lightning.objects.Trap import Trap
from api.io.Lightning.entities.Enemy import Enemy

class FightEffect:
    def __init__(self, x, y, dust_frames, star_img, cell_size):
        self.x = x
        self.y = y
        self.cell_size = cell_size
        self.dust_frames = dust_frames
        self.frame_index = 0
        self.anim_speed = 0.45
        self.star_img = star_img
        self.stars = []
        if self.star_img:
            center = cell_size // 2
            for _ in range(5):
                angle = random.uniform(0, 2 * math.pi)
                speed = random.uniform(1.5, 3.5)
                self.stars.append({'x': center, 'y': center, 'vx': math.cos(angle)*speed, 'vy': math.sin(angle)*speed-1, 'visible': False, 'spawn': random.randint(1,3)})
        self.finished = False

    def update(self):
        self.frame_index += self.anim_speed
        for s in self.stars:
            if self.frame_index >= s['spawn']:
                s['visible'] = True
                s['x'] += s['vx']
                s['y'] += s['vy']
                s['vx'] *= 0.95
                s['vy'] *= 0.95
        if self.frame_index >= len(self.dust_frames) + 3:
            self.finished = True

    def draw(self, surface):
        if self.finished: return
        idx = int(self.frame_index)
        if idx < len(self.dust_frames):
            img = self.dust_frames[idx]
            dx = maze_coord_x + self.x * self.cell_size + (self.cell_size - img.get_width()) // 2
            dy = maze_coord_y + self.y * self.cell_size + (self.cell_size - img.get_height()) // 2
            surface.blit(img, (dx, dy))
        if self.star_img:
            bx = maze_coord_x + self.x * self.cell_size
            by = maze_coord_y + self.y * self.cell_size
            for s in self.stars:
                if s['visible']:
                    surface.blit(self.star_img, (bx + int(s['x']) - self.star_img.get_width()//2, by + int(s['y']) - self.star_img.get_height()//2))

class MazeLoader:
    def __init__(self, level_id=None, difficulty='medium', generate_infinite=False, maze_size=None, saved_state=None):
        self.level_id = level_id
        self.difficulty = difficulty
        self.target_size = maze_size if maze_size else 8
        self.data = None
        self.parsed = None

        if saved_state:
            print("[System] Loading game from Save File...")
            self.parsed = saved_state 
            self.level_id = saved_state.get('level_id')
            self.difficulty = saved_state.get('difficulty')
            self.target_size = saved_state.get('maze_size', 8)
        
        elif generate_infinite:
            print(f"[System] Generating procedural level (Size: {self.target_size})...")
            gen = MazeGenerator()
            self.data = gen.generate_level(difficulty, maze_size=self.target_size)
            self.parsed = self._parse_level_data(self.data)
        else:
            self.data = self._load_level()
            self.parsed = self._parse_level_from_json()

        if not self.parsed:
            print("[Error] Failed to parse level data. Creating empty dummy level.")
            self.parsed = self._create_dummy_level(self.target_size)

        self.maze_pixel_size = 360
        self.maze_size = self.parsed.get("maze_size", self.target_size)
        self.stair_pos = self.parsed.get("exit")
        self.cell_size = self.maze_pixel_size // self.maze_size
        
        self.wall_sprites = {}
        self.stair_sprites = {}
        self.arrow_sprites = []
        self.dust_frames = []
        self.active_effects = []
        self.enemies_list = []
        self.traps = []
        self.key_obj = None
        self.gate_obj = None
        
        self.enemies_on_key = set()
        self.last_turn_time = 0
        self.history_stack = []
        self.pending_deaths = []
        self.turn_queue = deque()
        self.ankh_frames = []
        self.is_current_state_solvable = True
        self.generator_instance = MazeGenerator()
        self.ankh_timer = 0
        
        self._load_assets()
        self._create_objects()
        
        # Restore Gate Open state if loading
        if saved_state and self.gate_obj and saved_state.get('gate_open'):
            self.gate_obj.state = self.gate_obj.STATE_OPEN
            self.gate_obj.current_frame = len(self.gate_obj.frames) - 1

    def serialize_state(self, player):
        return {
            "level_id": self.level_id,
            "difficulty": self.difficulty,
            "maze_size": self.maze_size,
            "player": {"x": player.x, "y": player.y, "direction": player.direction},
            "enemies": [{'type': e.type, 'x': e.x, 'y': e.y, 'dir': e.direction} for e in self.enemies_list if not e.is_dead],
            "key": {'x': self.key_obj.grid_x, 'y': self.key_obj.grid_y} if self.key_obj else None,
            "gate": {'x': self.gate_obj.grid_x, 'y': self.gate_obj.grid_y} if self.gate_obj else None,
            "gate_open": not self.gate_obj.is_blocking() if self.gate_obj else True,
            "traps": [{'x': t.grid_x, 'y': t.grid_y} for t in self.traps],
            "walls": self.parsed['walls'],
            "exit": self.parsed['exit'],
            "is_custom": (self.level_id is None)
        }

    def _create_dummy_level(self, size):
        return {
            'difficulty': 'medium',
            'maze_size': size,
            'player': {'x': 0, 'y': 0, 'direction': 'down'},
            'exit': {'x': size-1, 'y': size-1},
            'enemies': [],
            'key': None,
            'gate': None,
            'traps': [],
            'walls': []
        }

    def _load_level(self):
        try:
            path = os.path.join(LEVELS_PATH, f'level_{self.level_id}.json')
            if os.path.exists(path):
                with open(path, 'r') as f:
                    return json.load(f)
            else:
                print(f"[Error] File not found: {path}")
        except Exception as e:
            print(f"[Error] Error loading level file: {e}")
        return None

    def _parse_level_from_json(self):
        return self._parse_level_data(self.data)

    @staticmethod
    def _parse_level_data(data):
        if not data: return None
        mz_type = data.get('mazeType', 8)
        try:
            mz_size = int(mz_type)
        except:
            mz_size = 8
        return {
            'difficulty': data.get('difficulty', 'medium'),
            'maze_size': mz_size,
            'player': data.get('player'),
            'exit': data.get('exit'),
            'enemies': data.get('enemies', []),
            'key': data.get('key'),
            'gate': data.get('gate'),
            'traps': data.get('traps', []),
            'walls': data.get('walls', [])
        }

    def reset(self):
        self._create_objects()
        self.active_effects = []
        self.pending_deaths = []
        self.turn_queue.clear()
        self.is_current_state_solvable = True
        self.history_stack.clear()

    def save_state(self, player):
        state = {
            'player': {'x': player.x, 'y': player.y, 'dir': player.direction},
            'gate_open': not self.gate_obj.is_blocking() if self.gate_obj else True,
            'solvable': self.is_current_state_solvable,
            'enemies': [{'type': e.type, 'x': e.x, 'y': e.y, 'dir': e.direction} for e in self.enemies_list if not e.is_dead],
            'traps': [t.is_triggered for t in self.traps]
        }
        self.history_stack.append(state)

    def undo_last_move(self, player):
        if not self.history_stack: return False
        state = self.history_stack.pop()
        player.x = state['player']['x']
        player.y = state['player']['y']
        player.direction = state['player']['dir']
        player.target_x = player.x * player.tile_size
        player.target_y = player.y * player.tile_size
        player.pixel_x = player.target_x
        player.pixel_y = player.target_y
        player.is_moving = False
        
        if self.gate_obj:
            self.gate_obj.state = self.gate_obj.STATE_OPEN if state['gate_open'] else self.gate_obj.STATE_CLOSED
        
        self.is_current_state_solvable = state['solvable']
        self.enemies_list.clear()
        self.enemies_on_key.clear()
        
        for e in state['enemies']:
            en = Enemy(e['x'], e['y'], e['type'], self.maze_size, self.cell_size, self.parsed['walls'], self.gate_obj)
            en.direction = e['dir']
            self.enemies_list.append(en)
            
        for i, triggered in enumerate(state.get('traps', [])):
            if i < len(self.traps) and self.traps[i].is_triggered and not triggered:
                self.traps[i].reset()
        
        self.turn_queue.clear()
        self.pending_deaths.clear()
        self.active_effects.clear()
        return True

    def _create_objects(self):
        if self.parsed['key']:
            self.key_obj = Key(self.parsed['key']['x'], self.parsed['key']['y'], self.cell_size, self.maze_size)
        if self.parsed['gate']:
            self.gate_obj = Gate(self.parsed['gate']['x'], self.parsed['gate']['y'], self.cell_size, self.maze_size)
        self.traps = [Trap(t['x'], t['y'], self.cell_size, self.maze_size) for t in self.parsed['traps']]
        self.enemies_list = [Enemy(e['x'], e['y'], e['type'], self.maze_size, self.cell_size, self.parsed['walls'], self.gate_obj) for e in self.parsed['enemies']]

    def _load_assets(self):
        self.backdrop_img = pygame.image.load(os.path.join(UI_PATH, 'backdrop.jpg'))
        self.floor_img = pygame.image.load(os.path.join(OBJECTS_PATH, f'floor{self.maze_size}.jpg'))
        ws = Spritesheet(os.path.join(OBJECTS_PATH, f'walls{self.maze_size}.gif'))
        if self.maze_size == 6:
            self.wall_sprites['h'] = ws.get_image(12, 0, 72, 18)
            self.wall_sprites['v'] = ws.get_image(0, 0, 12, 78)
        elif self.maze_size == 8:
            self.wall_sprites['h'] = ws.get_image(12, 0, 57, 18)
            self.wall_sprites['v'] = ws.get_image(0, 0, 12, 63)
        elif self.maze_size == 10:
            self.wall_sprites['h'] = ws.get_image(8, 0, 44, 12)
            self.wall_sprites['v'] = ws.get_image(0, 0, 8, 48)
        else:
            self.wall_sprites['h'] = ws.get_image(0, 0, 1, 1)
            self.wall_sprites['v'] = ws.get_image(0, 0, 1, 1)

        ss = Spritesheet(os.path.join(OBJECTS_PATH, f"stairs{self.maze_size}.gif"))
        sw = ss.sheet.get_width() // 4
        sh = ss.sheet.get_height()
        self.stair_sprites = {'up': ss.get_image(0,0,sw,sh), 'right': ss.get_image(sw,0,sw,sh), 'down': ss.get_image(2*sw,0,sw,sh), 'left': ss.get_image(3*sw,0,sw,sh)}
        
        try:
            self.circle_img = pygame.image.load(os.path.join(UI_PATH, f'circle{self.maze_size}.png')).convert_alpha()
            aws = pygame.image.load(os.path.join(UI_PATH, f'arrows{self.maze_size}.png')).convert_alpha()
            aw, ah = aws.get_width(), aws.get_height() // 4
            self.arrow_sprites = [aws.subsurface((0, i*ah, aw, ah)) for i in [0, 2, 1, 3]]
        except:
            pass
        
        ankh = pygame.image.load(os.path.join(UI_PATH, 'ankh.png')).convert_alpha()
        for i in range(4):
            self.ankh_frames.append(ankh.subsurface((0, i*(ankh.get_height()//4), ankh.get_width(), ankh.get_height()//4)))
        
        self.star_img = pygame.image.load(os.path.join(UI_PATH, 'star.png')).convert_alpha()
        dpath = os.path.join(UI_PATH, f'dust{self.maze_size}.png')
        if not os.path.exists(dpath):
            dpath = os.path.join(UI_PATH, 'dust6.png')
        ds = pygame.image.load(dpath).convert_alpha()
        h = ds.get_height()
        for i in range(ds.get_width() // h):
            self.dust_frames.append(ds.subsurface((i*h, 0, h, h)))

    def get_solution_path(self, player):
        if not player: return None
        snap = {
            'player': {'x': player.x, 'y': player.y},
            'exit': self.parsed['exit'],
            'enemies': [{'type':e.type, 'x':e.x, 'y':e.y} for e in self.enemies_list if not e.is_dead],
            'walls': self.parsed['walls'],
            'traps': self.parsed['traps'],
            'gate': {'x': self.gate_obj.grid_x, 'y': self.gate_obj.grid_y} if self.gate_obj else None,
            'key': {'x': self.key_obj.grid_x, 'y': self.key_obj.grid_y} if self.key_obj else None,
            'difficulty': self.parsed['difficulty']
        }
        return self.generator_instance._is_level_solvable(snap, self.maze_size)

    def check_solvability(self, player):
        if not player: return
        was_solvable = self.is_current_state_solvable
        path = self.get_solution_path(player)
        self.is_current_state_solvable = (path is not None)
        if was_solvable and not self.is_current_state_solvable:
            sfx_manager.play('badankh')

    def draw_ankh(self, surface):
        if not self.ankh_frames: return
        base = 0 if self.is_current_state_solvable else 2
        surface.blit(self.ankh_frames[base], (90, 320))
        self.ankh_timer += 0.08
        alpha = int(((math.sin(self.ankh_timer) + 1) / 2) * 255)
        glow = self.ankh_frames[base+1].copy()
        glow.set_alpha(alpha)
        surface.blit(glow, (90, 320))

    def spawn_fight_cloud(self, x, y):
        self.active_effects.append(FightEffect(x, y, self.dust_frames, self.star_img, self.cell_size))

    def init_enemy_turn_sequence(self):
        active = [e for e in self.enemies_list if not e.is_dead]
        order = {'scorpion': 0, 'red_scorpion': 1, 'white_mummy': 2, 'red_mummy': 3}
        active.sort(key=lambda e: order.get(e.type, 99))
        self.turn_queue = deque(active)
        self.last_turn_time = 0

    def update_turn_sequence(self, player_pos):
        if any(e.paused for e in self.enemies_list): return False
        if any(e.is_moving or len(e.move_queue)>0 for e in self.enemies_list):
            self.last_turn_time = pygame.time.get_ticks()
            return False
        if self.pending_deaths: return False
        if pygame.time.get_ticks() - self.last_turn_time < 50: return False
        
        if not self.turn_queue: return True
        
        nxt = self.turn_queue[0]
        if nxt.is_dead or nxt not in self.enemies_list:
            self.turn_queue.popleft()
            return self.update_turn_sequence(player_pos)
            
        self.turn_queue.popleft()
        nxt.move_logic([player_pos[0], player_pos[1]], self.parsed['difficulty'])
        
        if not nxt.move_queue: return self.update_turn_sequence(player_pos)
        return False

    def trigger_enemy_afk(self):
        for e in self.enemies_list: e.trigger_afk()

    def pause_enemies(self):
        for e in self.enemies_list: e.paused = True
    def resume_enemies(self):
        for e in self.enemies_list: e.paused = False

    def resolve_enemy_collisions(self):
        pos_map = {}
        for e in self.enemies_list:
            if e.state.name == "DIE": continue
            p = (e.x, e.y)
            if p not in pos_map: pos_map[p] = []
            pos_map[p].append(e)
        
        col = False
        for p, ens in pos_map.items():
            if len(ens) > 1:
                sfx_manager.play('pummel')
                self.spawn_fight_cloud(p[0], p[1])
                ens.sort(key=lambda x: x.strength, reverse=True)
                self.pending_deaths.extend(ens[1:])
                col = True
        return col

    def process_pending_deaths(self):
        for v in self.pending_deaths: v.trigger_die(instant=True)
        self.pending_deaths.clear()

    def update(self):
        if self.key_obj: self.key_obj.update()
        if self.gate_obj: self.gate_obj.update()
        for t in self.traps: t.update()
        for e in self.enemies_list: e.update()
        self.enemies_list = [e for e in self.enemies_list if not e.is_dead]
        for eff in self.active_effects: eff.update()
        self.active_effects = [e for e in self.active_effects if not e.finished]
        
        if self.key_obj and self.gate_obj:
            kx, ky = self.key_obj.grid_x, self.key_obj.grid_y
            for e in self.enemies_list:
                if e.x == kx and e.y == ky:
                    if e not in self.enemies_on_key:
                        self.gate_obj.toggle()
                        self.key_obj.activate()
                        sfx_manager.play('gate')
                        self.enemies_on_key.add(e)
                else:
                    if e in self.enemies_on_key: self.enemies_on_key.remove(e)

    def draw_background(self, surface):
        surface.blit(self.backdrop_img, (0,0))
        surface.blit(self.floor_img, (maze_coord_x, maze_coord_y))

    def draw(self, surface, player=None, enemies=None, mouse_pos=None):
        self.draw_stairs(surface)
        for t in self.traps: t.draw(surface)
        
        current_enemies = enemies if enemies else self.enemies_list
        for row in range(self.maze_size + 1):
            if self.gate_obj and self.gate_obj.grid_y == row: self.gate_obj.draw(surface)
            self._draw_walls(surface, row)
            if self.key_obj and self.key_obj.grid_y == row: self.key_obj.draw(surface)
            
            if player and player.is_ready() and mouse_pos:
                mx, my = mouse_pos
                gx = (mx - maze_coord_x) // self.cell_size
                gy = (my - maze_coord_y) // self.cell_size
                if gy == row and 0 <= gx < self.maze_size:
                    dx, dy = gx - player.x, gy - player.y
                    if (gx, gy) == (player.x, player.y) and self.circle_img:
                        surface.blit(self.circle_img, (maze_coord_x + gx*self.cell_size, maze_coord_y + gy*self.cell_size))
                    elif abs(dx)+abs(dy)==1 and self.arrow_sprites:
                        blocked = False
                        for e in current_enemies:
                            if e.x == gx and e.y == gy: blocked = True
                        if not blocked and player.check_eligible_move(gx, gy, self.maze_size, self.parsed['walls'], self.gate_obj):
                            idx = 2 if dx==1 else 1 if dx==-1 else 0 if dy==1 else 3 
                            surface.blit(self.arrow_sprites[idx], (maze_coord_x + gx*self.cell_size, maze_coord_y + gy*self.cell_size))

            entities = []
            if player and player.y == row: entities.append(player)
            for e in current_enemies: 
                if e.y == row: entities.append(e)
            for t in self.traps:
                if t.grid_y == row and t.is_triggered: entities.append(t)
            
            entities.sort(key=lambda x: 1 if isinstance(x, Trap) else 0)
            
            for ent in entities:
                if isinstance(ent, Trap): ent.draw_active_block(surface)
                else: ent.draw(surface)
            
            for eff in self.active_effects:
                if eff.y == row: eff.draw(surface)

    def _draw_walls(self, surface, row):
        for w in self.parsed['walls']:
            if w['y'] != row: continue
            wx, d = w['x'], w['dir']
            bx = maze_coord_x + wx*self.cell_size
            by = maze_coord_y + row*self.cell_size
            ox, oy = int(self.cell_size*0.08), int(self.cell_size*0.27)
            dx, dy = bx - ox, by - oy
            
            if d in ['horizontal', 'both'] and row > 0:
                surface.blit(self.wall_sprites['h'], (dx, dy))
            if d in ['vertical', 'both'] and wx > 0:
                surface.blit(self.wall_sprites['v'], (dx, dy))

    def draw_stairs(self, surface):
        if not self.stair_pos: return
        gx, gy = self.stair_pos['x'], self.stair_pos['y']
        s = self.stair_sprites
        cx, cy = maze_coord_x, maze_coord_y
        cs = self.cell_size
        img = None
        dx, dy = 0, 0
        
        if gx >= self.maze_size - 1:
            img = s['right']
            dx = cx + self.maze_size * cs - (15 if gx < self.maze_size else 0)
            dy = cy + gy*cs + (cs-img.get_height())//2
        elif gx <= 0:
            img = s['left']
            dx = cx - img.get_width() + (15 if gx >= 0 else 0)
            dy = cy + gy*cs + (cs-img.get_height())//2
        elif gy <= 0:
            img = s['up']
            dx = cx + gx*cs + (cs-img.get_width())//2
            dy = cy - img.get_height() + (15 if gy >= 0 else 0)
        else:
            img = s['down']
            dx = cx + gx*cs + (cs-img.get_width())//2
            dy = cy + self.maze_size*cs - (15 if gy < self.maze_size else 0)
            
        if img:
            surface.blit(img, (dx, dy))

    def check_trap_collision(self, x, y):
        for t in self.traps:
            if t.check_collision(x, y): return t
        return None

    def check_key_collision(self, x, y):
        if self.key_obj and self.key_obj.check_collision(x, y):
            self.key_obj.activate()
            if self.gate_obj:
                self.gate_obj.toggle()
            sfx_manager.play('gate')
            return True
        return False

    def face_enemies_to_player(self, player):
        for e in self.enemies_list:
            if not e.is_moving and not e.is_dead and e.state.name != 'DIE':
                e.face_target(player.x, player.y)

    def get_win_cell(self):
        if not self.stair_pos: return None
        ex, ey = int(self.stair_pos['x']), int(self.stair_pos['y'])
        return max(0, min(self.maze_size - 1, ex)), max(0, min(self.maze_size - 1, ey))

==============================
PATH: MummyMaze\api\io\Lightning\maze\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\objects\Gate.py
==============================

import os
import pygame

from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH, maze_coord_x, maze_coord_y

class Gate:
    STATE_OPEN = 'open'
    STATE_CLOSED = 'closed'

    STATE_OPENING = 'opening'
    STATE_CLOSING = 'closing'

    def __init__(self, x, y, cell_size, maze_size):
        self.grid_x = x
        self.grid_y = y
        self.cell_size = cell_size
        self.maze_size = maze_size

        self.frames = []
        self.current_frame = 0
        self.state = self.STATE_CLOSED
        self.animation_speed = 0.2
        self.animation_counter = 0

        self._load_frames()

    def _load_frames(self):
        try:
            gate_strip = pygame.image.load(os.path.join(OBJECTS_PATH, f'gate{self.maze_size}.gif')).convert_alpha()

            sheet_width = gate_strip.get_width() // 8
            sheet_height = gate_strip.get_height()

            for i in range(8):
                frame = pygame.Surface((sheet_width, sheet_height), pygame.SRCALPHA)
                frame.blit(gate_strip, (0, 0), (i * sheet_width, 0, sheet_width, sheet_height))
                self.frames.append(frame)

            print(f"[System] Loaded {len(self.frames)} gate animation frames")

        except Exception as e:
            print(f"[Error] Error loading gate frames: {e}")
            for i in range(8):
                dummy = pygame.Surface((self.cell_size, 10), pygame.SRCALPHA)
                alpha = 255 - (i * 32)
                dummy.fill((100, 100, 100))
                dummy.set_alpha(alpha)
                self.frames.append(dummy)

    def update(self):
        if self.state == self.STATE_CLOSED or self.state == self.STATE_OPEN:
            return

        self.animation_counter += self.animation_speed

        if self.animation_counter >= 1.0:
            self.animation_counter = 0

            if self.state == self.STATE_OPENING:
                self.current_frame += 1
                if self.current_frame >= len(self.frames) - 1:
                    self.current_frame = len(self.frames) - 1
                    self.state = self.STATE_OPEN

            elif self.state == self.STATE_CLOSING:
                self.current_frame -= 1
                if self.current_frame <= 0:
                    self.current_frame = 0
                    self.state = self.STATE_CLOSED

    def draw(self, surface):
        if not self.frames:
            return

        frame = self.frames[self.current_frame]

        base_x = maze_coord_x + self.grid_x * self.cell_size
        base_y = maze_coord_y + self.grid_y * self.cell_size

        offset_x = int(self.cell_size * 0.08)
        offset_y = int(self.cell_size * 0.27)

        gate_x = base_x - offset_x
        gate_y = base_y - offset_y

        surface.blit(frame, (gate_x, gate_y))

    def toggle(self):
        if self.state == self.STATE_CLOSED:
            self.state = self.STATE_OPENING
        elif self.state == self.STATE_OPEN:
            self.state = self.STATE_CLOSING

    def open(self):
        if self.state == self.STATE_CLOSED:
            self.state = self.STATE_OPENING

    def close(self):
        if self.state == self.STATE_OPEN:
            self.state = self.STATE_CLOSING

    def is_blocking(self):
        return self.state == self.STATE_CLOSED or self.state == self.STATE_CLOSING

    def is_open(self):
        return self.state == self.STATE_OPEN

==============================
PATH: MummyMaze\api\io\Lightning\objects\Key.py
==============================

import os
import pygame

from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH, maze_coord_x, maze_coord_y

class Key:
    def __init__(self, x, y, cell_size, maze_size):
        self.grid_x = x
        self.grid_y = y
        self.cell_size = cell_size
        self.maze_size = maze_size

        self.frames = []
        self.frame_index = 0
        self.animation_speed = 0.25
        self.animation_counter = 0
        self.collected = False

        self._load_frames()

    def _load_frames(self):
        try:
            key_strip = pygame.image.load(os.path.join(OBJECTS_PATH, f'key.png')).convert_alpha()

            sheet_width = key_strip.get_width()
            sheet_height = key_strip.get_height()

            frame_height = sheet_height
            frame_width = frame_height
            total_frames = sheet_width // frame_width

            for i in range(total_frames):
                frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
                frame.blit(key_strip, (0, 0), (i * frame_width, 0, frame_width, frame_height))
                self.frames.append(frame)

            print(f"[System] Loaded {len(self.frames)} key animation frames")

        except Exception as e:
            print(f"[Error] Error initializing Key: {e}")
            dummy = pygame.Surface((self.cell_size // 2, self.cell_size // 2), pygame.SRCALPHA)
            dummy.fill((255, 215, 0))
            self.frames = [dummy]

    def update(self):
        self.animation_counter += self.animation_speed

        if self.animation_counter >= 1.0:
            self.animation_counter = 0
            self.frame_index = (self.frame_index + 1) % len(self.frames)

    def draw(self, surface):
        if not self.frames:
            return

        frame = self.frames[self.frame_index]

        draw_x = maze_coord_x + self.grid_x * self.cell_size + (self.cell_size - frame.get_width()) // 2
        draw_y = maze_coord_y + self.grid_y * self.cell_size + (self.cell_size - frame.get_height()) // 2 - 6

        surface.blit(frame, (draw_x, draw_y))

    def activate(self):
        pass

    def check_collision(self, entity_x, entity_y):
        return entity_x == self.grid_x and entity_y == self.grid_y

==============================
PATH: MummyMaze\api\io\Lightning\objects\Trap.py
==============================

import os
import pygame

from api.io.Lightning.manager.Spritesheet import Spritesheet
from api.io.Lightning.utils.ConfigFile import OBJECTS_PATH, maze_coord_x, maze_coord_y

class Trap:
    def __init__(self, x, y, cell_size, maze_size):
        self.grid_x = x
        self.grid_y = y
        self.cell_size = cell_size
        self.maze_size = maze_size

        self.is_triggered = False
        self.frames = []
        self.animation_frame = 0
        self.animation_speed = 0.15
        self.animation_timer = 0

        self._load_sprites()

    def _load_sprites(self):
        self.trap_base = pygame.image.load(
            os.path.join(OBJECTS_PATH, f'trap{self.maze_size}.png')
        )

        sparkle_sheet = Spritesheet(
            os.path.join(OBJECTS_PATH, f'trapsparkle{self.maze_size}.png')
        )

        sheet_width = sparkle_sheet.sheet.get_width() // 14
        sheet_height = sparkle_sheet.sheet.get_height()

        for i in range(14):
            frame = sparkle_sheet.get_image(
                i * sheet_width, 0, sheet_width, sheet_height
            )
            self.frames.append(frame)

    def update(self):
        if not self.is_triggered:
            self.animation_timer += self.animation_speed
            if self.animation_timer >= 1:
                self.animation_timer = 0
                self.animation_frame = (self.animation_frame + 1) % len(self.frames)

    def trigger(self):
        self.is_triggered = True
        print(f"[Game] Trap triggered at ({self.grid_x}, {self.grid_y})")

    def check_collision(self, entity_x, entity_y):
        return entity_x == self.grid_x and entity_y == self.grid_y

    def draw(self, surface):
        pixel_x = maze_coord_x + self.grid_x * self.cell_size
        pixel_y = maze_coord_y + self.grid_y * self.cell_size

        trap_x = pixel_x + (self.cell_size - self.trap_base.get_width()) // 2
        trap_y = pixel_y + (self.cell_size - self.trap_base.get_height()) // 2
        surface.blit(self.trap_base, (trap_x, trap_y))

        if not self.is_triggered and len(self.frames) > 0:
            sparkle = self.frames[self.animation_frame]
            s_w = sparkle.get_width()
            s_h = sparkle.get_height()

            center_x = pixel_x + self.cell_size // 2
            center_y = pixel_y + self.cell_size // 2

            eye_offset_x = int(self.cell_size * 0.13)
            eye_offset_y = int(self.cell_size * 0.04)

            left_x = center_x - eye_offset_x - (s_w // 2)
            left_y = center_y - eye_offset_y - (s_h // 2)

            right_x = center_x + eye_offset_x - (s_w // 2)
            right_y = center_y - eye_offset_y - (s_h // 2)

            surface.blit(sparkle, (left_x, left_y))
            surface.blit(sparkle, (right_x, right_y))
    
    def draw_active_block(self, surface):
        pass # Optional: Draw visual effect when triggered

==============================
PATH: MummyMaze\api\io\Lightning\objects\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\stat\PlayerStat.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\stat\__init__.py
==============================



==============================
PATH: MummyMaze\api\io\Lightning\utils\ConfigFile.py
==============================

import os

# Thiết lập đường dẫn gốc của project
# Đi lên 4 cấp từ folder utils: utils -> Lightning -> io -> api -> MummyMaze
PROJECT_PATH = os.path.abspath(os.path.join(
    os.path.dirname(__file__), "../../../..")
)

# Thiết lập các thư mục con
API_PATH = os.path.join(PROJECT_PATH, "api")
DIST_PATH = os.path.join(PROJECT_PATH, "dist")
RESOURCE_PATH = os.path.join(PROJECT_PATH, "resources")

# Thiết lập đường dẫn dữ liệu level
LEVELS_PATH = os.path.join(DIST_PATH, "levels")

# Thiết lập đường dẫn tài nguyên (Ảnh, Nhạc, UI)
ENTITIES_PATH = os.path.join(RESOURCE_PATH, "entities")
OBJECTS_PATH = os.path.join(RESOURCE_PATH, "objects")
UI_PATH = os.path.join(RESOURCE_PATH, "ui")
SOUNDS_PATH = os.path.join(RESOURCE_PATH, "sounds")
MUSIC_PATH = os.path.join(RESOURCE_PATH, "music")

# Tọa độ vẽ mê cung trên màn hình (để căn giữa)
maze_coord_x = 213
maze_coord_y = 80
fps = 60

==============================
PATH: MummyMaze\api\io\Lightning\utils\GameType.py
==============================

from enum import Enum

class EnemyType(Enum):
    WHITE_MUMMY = "white_mummy"      # Horizontal priority, 2 moves
    RED_MUMMY = "red_mummy"          # Vertical priority, 2 moves
    SCORPION = "scorpion"            # Random/patrol, 1 move
    RED_SCORPION = "red_scorpion"    # Smart, 1 move

class Difficulty(Enum):
    EASY = "easy"
    NORMAL = "normal"
    HARD = "hard"

class GameMode(Enum):
    CLASSIC = "classic"
    ADVENTURE = "adventure"
    TUTORIAL = "tutorial"


==============================
PATH: MummyMaze\api\io\Lightning\utils\Pathfinder.py
==============================

import heapq

class Pathfinder:
    @staticmethod
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    @staticmethod
    def astar_search(start, goal, maze_size, is_valid_move_func):
        start = tuple(start)
        goal = tuple(goal)
        if start == goal: return []

        frontier = []
        heapq.heappush(frontier, (0, start))
        
        came_from = {start: None}
        cost_so_far = {start: 0}

        found = False
        while frontier:
            _, current = heapq.heappop(frontier)

            if current == goal:
                found = True
                break

            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                next_node = (current[0] + dx, current[1] + dy)
                
                if not (0 <= next_node[0] < maze_size and 0 <= next_node[1] < maze_size):
                    continue
                
                if not is_valid_move_func(current, next_node):
                    continue

                new_cost = cost_so_far[current] + 1
                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                    cost_so_far[next_node] = new_cost
                    priority = new_cost + Pathfinder.heuristic(next_node, goal)
                    heapq.heappush(frontier, (priority, next_node))
                    came_from[next_node] = current

        if not found: return []

        path = []
        curr = goal
        while curr != start:
            path.append(list(curr))
            curr = came_from[curr]
        path.reverse()
        return path

==============================
PATH: MummyMaze\api\io\Lightning\utils\__init__.py
==============================



==============================
PATH: MummyMaze\data\profiles.json
==============================

{
    "aaa": {
        "username": "aaa",
        "display_name": "aaa",
        "password_hash": "3e744b9dc39389baf0c5a0660589b8402f3dbb49b89b3e75f2c9355852a3c677",
        "data": {
            "unlocked_levels": [
                1
            ],
            "best_scores": {},
            "options": {
                "music_on": true,
                "sfx_on": true,
                "language": "en"
            }
        }
    },
    "aaaa": {
        "username": "aaaa",
        "display_name": "aaaa",
        "password_hash": "81cc5b17018674b401b42f35ba07bb79e211239c23bffe658da1577e3e646877",
        "data": {
            "unlocked_levels": [
                1
            ],
            "best_scores": {},
            "options": {
                "music_on": true,
                "sfx_on": true,
                "language": "en"
            }
        }
    },
    "admin": {
        "username": "admin",
        "display_name": "admin",
        "password_hash": "8b7293f6dd93853c83bf8c87ec5349a41789fa166a9431f108edb538e6fd82fd",
        "data": {
            "unlocked_levels": [
                1,
                2,
                3,
                4
            ],
            "best_scores": {
                "1": 9574,
                "2": 8596,
                "3": 9432
            },
            "options": {
                "music_on": true,
                "sfx_on": true,
                "language": "en"
            },
            "saved_game": {
                "level_id": null,
                "difficulty": "medium",
                "maze_size": 8,
                "player": {
                    "x": 1,
                    "y": 7,
                    "direction": "down"
                },
                "enemies": [
                    {
                        "type": "red_mummy",
                        "x": 0,
                        "y": 1,
                        "dir": "down"
                    },
                    {
                        "type": "white_mummy",
                        "x": 5,
                        "y": 0,
                        "dir": "down"
                    }
                ],
                "key": {
                    "x": 2,
                    "y": 6
                },
                "gate": {
                    "x": 1,
                    "y": 6
                },
                "gate_open": false,
                "traps": [
                    {
                        "x": 1,
                        "y": 2
                    }
                ],
                "walls": [
                    {
                        "x": 0,
                        "y": 0,
                        "dir": "vertical"
                    },
                    {
                        "x": 0,
                        "y": 1,
                        "dir": "vertical"
                    },
                    {
                        "x": 0,
                        "y": 3,
                        "dir": "vertical"
                    },
                    {
                        "x": 0,
                        "y": 5,
                        "dir": "vertical"
                    },
                    {
                        "x": 0,
                        "y": 6,
                        "dir": "vertical"
                    },
                    {
                        "x": 0,
                        "y": 7,
                        "dir": "vertical"
                    },
                    {
                        "x": 1,
                        "y": 0,
                        "dir": "horizontal"
                    },
                    {
                        "x": 1,
                        "y": 2,
                        "dir": "vertical"
                    },
                    {
                        "x": 1,
                        "y": 3,
                        "dir": "vertical"
                    },
                    {
                        "x": 1,
                        "y": 5,
                        "dir": "horizontal"
                    },
                    {
                        "x": 1,
                        "y": 7,
                        "dir": "vertical"
                    },
                    {
                        "x": 2,
                        "y": 0,
                        "dir": "both"
                    },
                    {
                        "x": 2,
                        "y": 1,
                        "dir": "horizontal"
                    },
                    {
                        "x": 2,
                        "y": 3,
                        "dir": "horizontal"
                    },
                    {
                        "x": 2,
                        "y": 4,
                        "dir": "vertical"
                    },
                    {
                        "x": 2,
                        "y": 5,
                        "dir": "vertical"
                    },
                    {
                        "x": 2,
                        "y": 6,
                        "dir": "vertical"
                    },
                    {
                        "x": 2,
                        "y": 7,
                        "dir": "horizontal"
                    },
                    {
                        "x": 3,
                        "y": 2,
                        "dir": "vertical"
                    },
                    {
                        "x": 3,
                        "y": 3,
                        "dir": "vertical"
                    },
                    {
                        "x": 3,
                        "y": 4,
                        "dir": "vertical"
                    },
                    {
                        "x": 3,
                        "y": 5,
                        "dir": "horizontal"
                    },
                    {
                        "x": 4,
                        "y": 2,
                        "dir": "horizontal"
                    },
                    {
                        "x": 5,
                        "y": 1,
                        "dir": "vertical"
                    },
                    {
                        "x": 5,
                        "y": 3,
                        "dir": "horizontal"
                    },
                    {
                        "x": 5,
                        "y": 5,
                        "dir": "vertical"
                    },
                    {
                        "x": 6,
                        "y": 2,
                        "dir": "horizontal"
                    },
                    {
                        "x": 6,
                        "y": 3,
                        "dir": "vertical"
                    },
                    {
                        "x": 6,
                        "y": 4,
                        "dir": "both"
                    },
                    {
                        "x": 6,
                        "y": 5,
                        "dir": "vertical"
                    },
                    {
                        "x": 6,
                        "y": 7,
                        "dir": "vertical"
                    },
                    {
                        "x": 7,
                        "y": 0,
                        "dir": "horizontal"
                    },
                    {
                        "x": 7,
                        "y": 1,
                        "dir": "vertical"
                    },
                    {
                        "x": 7,
                        "y": 3,
                        "dir": "horizontal"
                    },
                    {
                        "x": 7,
                        "y": 5,
                        "dir": "both"
                    }
                ],
                "exit": {
                    "x": 2,
                    "y": -1
                },
                "is_custom": true
            }
        }
    }
}

==============================
PATH: MummyMaze\dist\main.py
==============================

import os
import sys
import pygame
from pathlib import Path

# Configure system path to include project root
ROOT_DIR = Path(__file__).resolve().parent.parent
if str(ROOT_DIR) not in sys.path: sys.path.insert(0, str(ROOT_DIR))

# Import application modules
import api.io.Lightning.utils.ConfigFile as cf
from api.io.Lightning.gui.Interface import init, main_menu
from api.io.Lightning.gui.GameUI import initialize_ui, draw_screen, handle_game_input, restart_level, get_hover_state, get_clicked_state
from api.io.Lightning.gui.WinState import win_screen
from api.io.Lightning.gui.LoseState import lose_screen
from api.io.Lightning.gui.LoginScreen import login_screen
from api.io.Lightning.manager.SoundReader import music_manager
from api.io.Lightning.manager.StorageManager import storage_manager
from api.io.Lightning.manager.TextDesigner import TextDesigner
from api.io.Lightning.gui.Leaderboard import leaderboard_screen

# Define Application States
STATE_LOGIN = "LOGIN"; STATE_MENU = "MENU"; STATE_RANDOM_CFG = "RANDOM_CFG"
STATE_CAMPAIGN_SEL = "CAMPAIGN_SEL"; STATE_GAME = "GAME"; STATE_WIN = "WIN"; STATE_LOSE = "LOSE"
STATE_LEADERBOARD = "LEADERBOARD"

# Shared context
ctx = {"size": 8, "difficulty": "medium", "level_id": 1, "mode": "random"}

def random_config_screen(screen, clock, mouse_pos, clicked):
    bg = pygame.image.load(os.path.join(cf.UI_PATH, 'menuback.jpg'))
    screen.blit(bg, (0,0))
    gd = TextDesigner(color=(255, 215, 0)); wd = TextDesigner()
    
    gd.render_header("CLASSIC CONFIG", screen, 320, 50)
    
    gd.render_default("SIZE:", screen, 100, 140)
    sizes = [6, 8, 10]
    for i, s in enumerate(sizes):
        col = (255, 215, 0) if ctx["size"] == s else (200, 200, 200)
        td = TextDesigner(color=col)
        if td.draw_button(screen, f"{s}x{s}", 260 + i*120, 140, mouse_pos, clicked): ctx["size"] = s

    gd.render_default("MODE:", screen, 100, 240)
    diffs = ["easy", "medium", "hard"]
    for i, d in enumerate(diffs):
        col = (255, 215, 0) if ctx["difficulty"] == d else (200, 200, 200)
        td = TextDesigner(color=col)
        if td.draw_button(screen, d.upper(), 260 + i*120, 240, mouse_pos, clicked): ctx["difficulty"] = d

    if wd.draw_button(screen, "START GAME", 320, 380, mouse_pos, clicked):
        pygame.event.clear()
        screen.fill((0,0,0)); 
        txt = wd.render("GENERATING...", color=(255,255,0)); screen.blit(txt, (250, 220))
        pygame.display.flip()
        
        ctx["mode"] = "random"
        initialize_ui(mode="random", size=ctx["size"], difficulty=ctx["difficulty"])
        music_manager.start_classic_mode_music()
        return STATE_GAME
        
    if wd.draw_button(screen, "BACK", 320, 440, mouse_pos, clicked): return STATE_MENU
    
    return STATE_RANDOM_CFG

def campaign_select_screen(screen, clock, mouse_pos, clicked):
    bg = pygame.image.load(os.path.join(cf.UI_PATH, 'menuback.jpg'))
    screen.blit(bg, (0,0))
    gd = TextDesigner(color=(255, 215, 0)); wd = TextDesigner()
    
    gd.render_header("CAMPAIGN", screen, 320, 50)
    
    unlocked = [1]
    if storage_manager.current_user:
        unlocked = storage_manager.current_user.data.get("unlocked_levels", [1])
    
    start_x = 160
    for i in range(1, 4): 
        x = start_x + (i-1)*160; y = 200; lvl_str = f"LV {i}"
        
        if i in unlocked:
            col = (255, 215, 0) if ctx.get("level_id") == i else (255, 255, 255)
            td = TextDesigner(color=col)
            if td.draw_button(screen, lvl_str, x, y, mouse_pos, clicked): ctx["level_id"] = i
        else:
            grey = TextDesigner(color=(100, 100, 100))
            grey.render_default(lvl_str, screen, x, y)

    if wd.draw_button(screen, f"PLAY LEVEL {ctx.get('level_id', 1)}", 320, 380, mouse_pos, clicked):
        pygame.event.clear()
        ctx["mode"] = "campaign"
        initialize_ui(mode="campaign", level_id=ctx.get('level_id', 1))
        music_manager.start_classic_mode_music()
        return STATE_GAME
        
    if wd.draw_button(screen, "BACK", 320, 440, mouse_pos, clicked): return STATE_MENU
    
    return STATE_CAMPAIGN_SEL

def main():
    screen = init()
    clock = pygame.time.Clock()
    state = STATE_LOGIN
    running = True
    last_score, last_time = 0, 0
    
    while running:
        mouse_pos = pygame.mouse.get_pos()
        clicked = False
        pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)

        for e in pygame.event.get():
            if e.type == pygame.QUIT: running = False
            if e.type == pygame.MOUSEBUTTONDOWN and e.button == 1: clicked = True
            
            if state == STATE_GAME:
                music_manager.handle_event(e)
                res = handle_game_input(e, mouse_pos)
                if res == "quit": state = STATE_MENU

        # State Machine Logic
        if state == STATE_LOGIN:
            res = login_screen(screen, clock)
            if res == "__QUIT__": running = False
            elif res == "success": 
                state = STATE_MENU
                pygame.event.clear()

        elif state == STATE_MENU:
            music_manager.start_menu_music()
            act = main_menu(screen, clock)
            
            if act == "__QUIT__": running = False
            
            elif act == "continue_game":
                saved_data = storage_manager.load_game_state()
                if saved_data:
                    pygame.event.clear()
                    initialize_ui(saved_state=saved_data)
                    music_manager.start_classic_mode_music()
                    state = STATE_GAME
            
            elif act == "leaderboard":
                state = STATE_LEADERBOARD
                pygame.event.clear()

            elif act == "classic_mode": 
                state = STATE_RANDOM_CFG
                pygame.event.clear()
            elif act == "campaign_mode": 
                state = STATE_CAMPAIGN_SEL
                pygame.event.clear()
            
        elif state == STATE_RANDOM_CFG:
            state = random_config_screen(screen, clock, mouse_pos, clicked)
            pygame.display.flip()
            clock.tick(60)
            
        elif state == STATE_CAMPAIGN_SEL:
            state = campaign_select_screen(screen, clock, mouse_pos, clicked)
            pygame.display.flip()
            clock.tick(60)
            
        elif state == STATE_LEADERBOARD:
            res = leaderboard_screen(screen, clock, mouse_pos, clicked)
            if res == "BACK": state = STATE_MENU
            pygame.display.flip()
            clock.tick(60)

        elif state == STATE_GAME:
            if not running: break
            hover = get_hover_state(mouse_pos)
            clk = get_clicked_state()
            res = draw_screen(screen, hover, clk)
            
            if res == "lose": state = STATE_LOSE
            elif isinstance(res, tuple) and res[0] == "win":
                last_score, last_time = res[1], res[2]
                if ctx["mode"] == "campaign":
                    storage_manager.unlock_level(ctx["level_id"]+1)
                    storage_manager.update_high_score(ctx["level_id"], last_score)
                state = STATE_WIN
            
            pygame.display.flip()
            clock.tick(60)
            
        elif state == STATE_LOSE:
            act = lose_screen(screen, clock)
            if act == "quit": running = False
            elif act == "menu": state = STATE_MENU
            elif act == "retry": 
                restart_level() 
                state = STATE_GAME
            
        elif state == STATE_WIN:
            act = win_screen(screen, clock, score=last_score, time_ms=last_time)
            if act == "quit": running = False
            elif act == "menu": state = STATE_MENU
            elif act == "next_level":
                if ctx["mode"] == "campaign":
                    ctx["level_id"] += 1
                    if ctx["level_id"] > 3: 
                        state = STATE_MENU; ctx["level_id"] = 1
                    else:
                        initialize_ui(mode="campaign", level_id=ctx["level_id"])
                        state = STATE_GAME
                else:
                    initialize_ui(mode="random", size=ctx["size"], difficulty=ctx["difficulty"])
                    state = STATE_GAME
            elif act == "reset": restart_level(); state = STATE_GAME

    pygame.quit()

if __name__ == "__main__":
    main()

==============================
PATH: MummyMaze\dist\__init__.py
==============================



==============================
PATH: MummyMaze\dist\levels\level_1.json
==============================

{
  "difficulty": "easy",
  "mazeType": "6",
  "player": {"x": 0, "y": 0, "direction": "right"},
  "exit": {"x": 5, "y": 2},
  "enemies": [
    {"type": "white_mummy", "x": 2, "y": 4}
  ],
  "key": {},
  "gate": {},
  "traps": [],
  "walls": [
    {"x": 1, "y": 2, "dir": "vertical"},
    {"x": 1, "y": 4, "dir": "horizontal"},
    {"x": 2, "y": 1, "dir": "horizontal"},
    {"x": 2, "y": 4, "dir": "vertical"},
    {"x": 3, "y": 1, "dir": "vertical"},
    {"x": 4, "y": 2, "dir": "both"},
    {"x": 5, "y": 4, "dir": "both"}
  ]
}

==============================
PATH: MummyMaze\dist\levels\level_2.json
==============================

{
  "difficulty": "normal",
  "mazeType": "8",
  "player": {"x": 7, "y": 0, "direction": "down"},
  "exit": {"x": 0, "y": 7},
  "enemies": [
    {"type": "white_mummy", "x": 4, "y": 0},
    {"type": "white_mummy", "x": 0, "y": 5},
    {"type": "scorpion", "x": 1, "y": 7}
  ],
  "key": {"x": 0, "y": 2},
  "gate": {"x": 6, "y": 1},
  "traps": [
    {"x": 6, "y": 4}
  ],
  "walls": [
    {"x": 0, "y": 3, "dir": "horizontal"},
    {"x": 1, "y": 2, "dir": "horizontal"},
    {"x": 1, "y": 3, "dir": "horizontal"},
    {"x": 1, "y": 4, "dir": "horizontal"},
    {"x": 1, "y": 5, "dir": "both"},
    {"x": 1, "y": 6, "dir": "vertical"},
    {"x": 2, "y": 3, "dir": "both"},
    {"x": 2, "y": 4, "dir": "vertical"},
    {"x": 2, "y": 5, "dir": "vertical"},
    {"x": 3, "y": 4, "dir": "vertical"},
    {"x": 3, "y": 7, "dir": "horizontal"},
    {"x": 4, "y": 1, "dir": "both"},
    {"x": 4, "y": 2, "dir": "horizontal"},
    {"x": 4, "y": 4, "dir": "horizontal"},
    {"x": 4, "y": 7, "dir": "vertical"},
    {"x": 5, "y": 1, "dir": "horizontal"},
    {"x": 5, "y": 3, "dir": "horizontal"},
    {"x": 5, "y": 7, "dir": "horizontal"},
    {"x": 6, "y": 2, "dir": "vertical"},
    {"x": 6, "y": 3, "dir": "horizontal"},
    {"x": 6, "y": 4, "dir": "both"},
    {"x": 6, "y": 6, "dir": "horizontal"},
    {"x": 7, "y": 2, "dir": "horizontal"},
    {"x": 7, "y": 4, "dir": "vertical"}
  ]
}

==============================
PATH: MummyMaze\dist\levels\level_3.json
==============================

{
  "difficulty": "hard",
  "mazeType": "10",
  "player": {
    "x": 2,
    "y": 1,
    "direction": "down"
  },
  "exit": {
    "x": 9,
    "y": 0
  },
  "enemies": [
    {
      "type": "red_mummy",
      "x": 0,
      "y": 9
    },
    {
      "type": "red_scorpion",
      "x": 9,
      "y": 5
    }
  ],
  "key": {
    "x": 9,
    "y": 9
  },
  "gate": {
    "x": 7,
    "y": 1
  },
  "traps": [
    { "x": 4, "y": 7 },
    { "x": 5, "y": 7 }
  ],
  "walls": [
    { "x": 1, "y": 0, "dir": "vertical" },
    { "x": 3, "y": 0, "dir": "vertical" },
    { "x": 5, "y": 0, "dir": "vertical" },
    { "x": 8, "y": 0, "dir": "vertical" },

    { "x": 2, "y": 1, "dir": "horizontal" },
    { "x": 6, "y": 1, "dir": "horizontal" },
    { "x": 7, "y": 1, "dir": "vertical" },

    { "x": 1, "y": 2, "dir": "vertical" },
    { "x": 3, "y": 2, "dir": "vertical" },
    { "x": 5, "y": 2, "dir": "vertical" },
    { "x": 9, "y": 2, "dir": "horizontal" },

    { "x": 0, "y": 3, "dir": "horizontal" },
    { "x": 2, "y": 3, "dir": "horizontal" },
    { "x": 4, "y": 3, "dir": "horizontal" },
    { "x": 6, "y": 3, "dir": "vertical" },

    { "x": 1, "y": 4, "dir": "vertical" },
    { "x": 3, "y": 4, "dir": "vertical" },
    { "x": 5, "y": 4, "dir": "vertical" },
    { "x": 7, "y": 4, "dir": "horizontal" },

    { "x": 2, "y": 5, "dir": "horizontal" },
    { "x": 5, "y": 5, "dir": "vertical" },
    { "x": 8, "y": 5, "dir": "vertical" },

    { "x": 0, "y": 6, "dir": "horizontal" },
    { "x": 3, "y": 6, "dir": "vertical" },
    { "x": 5, "y": 6, "dir": "vertical" },
    { "x": 6, "y": 6, "dir": "horizontal" },

    { "x": 1, "y": 7, "dir": "vertical" },
    { "x": 2, "y": 7, "dir": "horizontal" },
    { "x": 7, "y": 7, "dir": "vertical" },

    { "x": 4, "y": 8, "dir": "vertical" },
    { "x": 5, "y": 8, "dir": "vertical" },
    { "x": 8, "y": 8, "dir": "horizontal" },

    { "x": 1, "y": 9, "dir": "vertical" },
    { "x": 3, "y": 9, "dir": "vertical" },
    { "x": 6, "y": 9, "dir": "vertical" }
  ]
}